<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Laravel-辅助函数auth与JWT扩展详解</title>
      <link href="/2018/05/08/Laravel-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0auth%E4%B8%8EJWT%E6%89%A9%E5%B1%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/08/Laravel-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0auth%E4%B8%8EJWT%E6%89%A9%E5%B1%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<pre><code>/** * Get the guard to be used during authentication. * * @return \Illuminate\Contracts\Auth\Guard */public function guard(){    return JWTAuth::guard();}</code></pre><p>// 增加 auth 中间件<br>// 第一个 GetUserFromToken 去源代码下找并没有，但其实就是 Authenticate 那一个<br>$app-&gt;routeMiddleware([<br>    ‘jwt.auth’ =&gt; ‘Tymon\JWTAuth\Middleware\GetUserFromToken’,<br>    ‘jwt.refresh’ =&gt; ‘Tymon\JWTAuth\Middleware\RefreshToken’,<br>]);</p><blockquote><h3 id="2-1-一个值得注意的地方"><a href="#2-1-一个值得注意的地方" class="headerlink" title="2.1 一个值得注意的地方"></a>2.1 一个值得注意的地方</h3><blockquote><p>这里有一个十分令人疑惑的地方： <code>&#39;middleware&#39; =&gt; &#39;auth:api&#39;</code>，你会发现把 <code>:api</code> 去掉也是没问题的，到底怎么回事？</p></blockquote><p>去文档看，这种 <code>路由名:参数</code> 的写法是用来传参的。但是这里并不是传参的，打开 <code>config/auth.php</code>：</p><pre><code class="php">&#39;guards&#39; =&gt; [    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;jwt&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],    &#39;web&#39; =&gt; []],</code></pre><p>仔细想了想，终于理解了：在 <code>Laravel</code> 中有 <code>web.php</code>、<code>api.php</code> 等多个路由，这个几个路由会分别对应这 <code>guards</code> 中一个数组，而 <code>JWT</code> 用 <code>auth</code> 中间件，后面的 <code>:api</code> 就表示用 <code>guards</code> 中 <code>api</code> 数组指定的 <code>driver</code> 和 <code>provider</code>，当只有一个 <code>api</code> 数组的时候，就可以省去 <code>:api</code>。</p></blockquote><p>  $exp = auth()-&gt;payload()-&gt;get(‘exp’);</p><p>​        $json = auth()-&gt;payload()-&gt;toJson();</p><p>​        $array = auth()-&gt;payload()-&gt;jsonSerialize();</p>]]></content>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>投票系统的重构</title>
      <link href="/2018/05/04/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%87%8D%E6%9E%84/"/>
      <url>/2018/05/04/%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%87%8D%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>曾经用原生 PHP 写过一个功能较为完善的投票系统，但是扩展性和可维护性都非常差，后来学了 Laravel ，打算用 Laravel 来重构这个项目。记录如下：</p><h1 id="一、项目要求"><a href="#一、项目要求" class="headerlink" title="一、项目要求"></a>一、项目要求</h1><h2 id="1-功能要求"><a href="#1-功能要求" class="headerlink" title="1. 功能要求"></a>1. 功能要求</h2><p>作为一个简单的投票系统，基本功能要求如下：</p><ul><li>活动的创建和控制</li><li>候选人的添加和修改</li><li>每一个投票参与者的信息记录</li><li>每一票的信息记录</li><li>票数的可视化展示</li></ul><p>然后除此之外，需要让整个投票系统能够尽可能的承受大流量的冲击，保证每一票的正常到位：</p><ul><li>能够承受大流量、高并发的流量冲击（做压力测试）</li><li>能够自动根据投票的数据，检测投票数据的异常（即刷票检测）</li></ul><h2 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2. 开发工具"></a>2. 开发工具</h2><ul><li>Laravel 框架</li><li>Redis</li><li>Mysql</li></ul><h2 id="3-扩展性"><a href="#3-扩展性" class="headerlink" title="3. 扩展性"></a>3. 扩展性</h2><p>后期整理出开发 API 接口，便于进行小程序版和原生应用的开发。</p><h1 id="二、项目设计"><a href="#二、项目设计" class="headerlink" title="二、项目设计"></a>二、项目设计</h1><h2 id="1-对象设计"><a href="#1-对象设计" class="headerlink" title="1. 对象设计"></a>1. 对象设计</h2><h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><p>由管理员添加和修改</p><h3 id="候选者"><a href="#候选者" class="headerlink" title="候选者"></a>候选者</h3><p>隶属于一个活动，可以由管理员创建或者自主报名</p><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p>自动记录每一个活动的每一个参与者</p><h2 id="2-数据采集"><a href="#2-数据采集" class="headerlink" title="2. 数据采集"></a>2. 数据采集</h2><h3 id="票数"><a href="#票数" class="headerlink" title="票数"></a>票数</h3><p>每一票的来源和去向以及时间等信息都必需采集好</p><h3 id="参与者信息"><a href="#参与者信息" class="headerlink" title="参与者信息"></a>参与者信息</h3><p>收集每一个参与者的基本信息，用于进行票的有效性鉴定</p><h1 id="三、-数据库"><a href="#三、-数据库" class="headerlink" title="三、 数据库"></a>三、 数据库</h1><ul><li>尽量使用满足条件的最小数据类型</li></ul><h2 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1. 数据库设计"></a>1. 数据库设计</h2><h3 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h3><h4 id="activitys-info-活动信息"><a href="#activitys-info-活动信息" class="headerlink" title="activitys_info-活动信息"></a>activitys_info-活动信息</h4><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(10)</td><td>自增 ID。主键。</td></tr><tr><td>uniquekey</td><td>char(36)</td><td>活动唯一ID，UUID， Str::uuid() 获取。唯一。</td></tr><tr><td>intro</td><td>varchar(512)</td><td>活动介绍</td></tr><tr><td>host</td><td>varchar</td><td>主办方。可选。</td></tr><tr><td>undertake</td><td>varchar</td><td>承办方。可选</td></tr><tr><td>sponsored</td><td>varchar</td><td>赞助方。可选</td></tr><tr><td>refresh_period</td><td>int</td><td>票数刷新周期，默认为 1</td></tr><tr><td>refresh_ballot</td><td>int</td><td>每周期可投票数，默认为 1</td></tr><tr><td>user_from</td><td>enum(1,2,3,4)</td><td>投票者来源：1-QQ，2-weibo，3-Wechat，4-Other</td></tr><tr><td>rules</td><td>json</td><td>活动规则，字符串数组，可选</td></tr><tr><td>ava_type</td><td>json</td><td>开放的参赛作品类型，1-4的键值数组并各自对应一个布尔值</td></tr><tr><td>creator</td><td>varchar</td><td>活动创建者，来自 users 表的 email</td></tr><tr><td>backimg</td><td>varchar(512)</td><td>投票页面的背景图，有默认值</td></tr><tr><td>logo</td><td>varchar(512)</td><td>投票页面的logo，有默认值</td></tr><tr><td>start_at</td><td>timestamp</td><td>活动开始时间</td></tr><tr><td>end_at</td><td>timestamp</td><td>活动结束时间</td></tr><tr><td>create_at</td><td>timestamp</td><td>活动创建时间</td></tr><tr><td>update_at</td><td>timestamp</td><td>活动上次更新时间</td></tr></tbody></table><h4 id="activitys-record-活动记录"><a href="#activitys-record-活动记录" class="headerlink" title="activitys_record-活动记录"></a>activitys_record-活动记录</h4><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(10)</td><td>主键，自增ID</td></tr><tr><td>activity_key</td><td>char(36)</td><td>活动唯一性 key，来自 activitys_info 的 uniquekey， 外键</td></tr><tr><td>pv</td><td>int</td><td>浏览量，默认为 0</td></tr><tr><td>uv</td><td>int</td><td>浏览人数，默认为 0</td></tr></tbody></table><h4 id="candidates-info-候选人信息"><a href="#candidates-info-候选人信息" class="headerlink" title="candidates_info-候选人信息"></a>candidates_info-候选人信息</h4><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(10)</td><td>主键，自增ID</td></tr><tr><td>uniquekey</td><td>char(36)</td><td>候选人唯一ID，UUID， Str::uuid() 获取。唯一。</td></tr><tr><td>name</td><td>varchar</td><td>候选单位-名称</td></tr><tr><td>tel</td><td>varchar</td><td>手机号，可选</td></tr><tr><td>QQ</td><td>varchar</td><td>QQ号，可选</td></tr><tr><td>intro</td><td>varchar(512)</td><td>候选单位-介绍</td></tr><tr><td>belong_ac</td><td>char(36)</td><td>所属活动唯一性 key，来自 activitys_info 的 uniquekey， 外键</td></tr><tr><td>type</td><td>enum(1,2,3,4)</td><td>参赛作品类型：1-图片，2-视频，3-音频，4-外链</td></tr><tr><td>img_url</td><td>varchar(512)</td><td>图片链接</td></tr><tr><td>video_url</td><td>varchar(512)</td><td>视频链接</td></tr><tr><td>audio_url</td><td>varchar(512)</td><td>音频链接</td></tr><tr><td>link_info</td><td>json</td><td>外链的链接和封面，linkurl + linkcoverurl</td></tr><tr><td>create_at</td><td>timestamp</td><td>候选人创建时间</td></tr><tr><td>update_at</td><td>timestamp</td><td>候选人上次更新时间</td></tr></tbody></table><h4 id="candidates-record-候选人票数"><a href="#candidates-record-候选人票数" class="headerlink" title="candidates_record-候选人票数"></a>candidates_record-候选人票数</h4><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(10)</td><td>主键，自增ID</td></tr><tr><td>candidate_key</td><td>char(36)</td><td>候选人唯一ID，UUID， Str::uuid() 获取。唯一。</td></tr><tr><td>ballot</td><td>int</td><td>所得票数，默认 0</td></tr></tbody></table><p>####participant_info-参与者信息</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(10)</td><td>主键，自增ID</td></tr><tr><td>uniquekey</td><td>char(36)</td><td>参与者唯一ID，UUID， Str::uuid() 获取。唯一。</td></tr><tr><td>name</td><td>varchar</td><td>参与者昵称</td></tr><tr><td>plat_from</td><td>enum(1,2,3,4)</td><td>参与者来源：1-QQ，2-weibo，3-Wechat，4-Other</td></tr><tr><td>detail</td><td>text</td><td>详细信息，从 Oauth2.0 登录的接口获取的信息</td></tr><tr><td>create_at</td><td>timestamp</td><td>候选人创建时间</td></tr></tbody></table><h4 id="vote-record-投票记录"><a href="#vote-record-投票记录" class="headerlink" title="vote_record-投票记录"></a>vote_record-投票记录</h4><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键，自增ID</td></tr><tr><td>plat_form</td><td>enum(1,2,3,4)</td><td>投票来源：1-QQ，2-weibo，3-Wechat，4-Other</td></tr><tr><td>ip</td><td>char(15)</td><td>投票者ip</td></tr><tr><td>area</td><td>varchar</td><td>投票者所属地区</td></tr><tr><td>vote_at</td><td>timestamp</td><td>投票时间</td></tr><tr><td>voter_name</td><td>varchar</td><td>投票者昵称</td></tr><tr><td>voter_key</td><td>char(36)</td><td>投票者唯一ID，UUID， Str::uuid() 获取。唯一。外键</td></tr><tr><td>activity_key</td><td>char(36)</td><td>投票活动唯一ID，UUID， Str::uuid() 获取。唯一。外键</td></tr><tr><td>candidate_key</td><td>char(36)</td><td>投票对象唯一ID，UUID， Str::uuid() 获取。唯一。外键</td></tr></tbody></table><h4 id="user-系统管理员"><a href="#user-系统管理员" class="headerlink" title="user-系统管理员"></a>user-系统管理员</h4><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键，自增ID</td></tr><tr><td>name</td><td>varchar</td><td>姓名</td></tr><tr><td>email</td><td>varchar</td><td>邮箱</td></tr><tr><td>password</td><td>varchar</td><td>密码</td></tr><tr><td>role</td><td>enum(1,2,3,4)</td><td>角色：1-超级管理员，2-高级账户，3-一般账户，4-封禁账户</td></tr></tbody></table><h2 id="2-逻辑部分"><a href="#2-逻辑部分" class="headerlink" title="2. 逻辑部分"></a>2. 逻辑部分</h2><p>###编写数据库迁移</p><p>可以顺便写一条 seeder，填充点测试数据。</p><h3 id="编写模型绑定数据库"><a href="#编写模型绑定数据库" class="headerlink" title="编写模型绑定数据库"></a>编写模型绑定数据库</h3><p>值得注意的是模型除了管理表，还可以互相进行管理，进行更加方便的操作。</p><h1 id="四、具体逻辑"><a href="#四、具体逻辑" class="headerlink" title="四、具体逻辑"></a>四、具体逻辑</h1><h2 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1. 控制器"></a>1. 控制器</h2><h3 id="定义资源控制器和路由"><a href="#定义资源控制器和路由" class="headerlink" title="定义资源控制器和路由"></a>定义资源控制器和路由</h3><p>资源路由，有转门的 API 资源路由。</p><p>###表单验证</p><p>定义了表单验证，值的注意的是，在 Laravel 中，如果表单验证没有通过会有两种情况：</p><ul><li><p>如果是页面表单提交的会重定向，这时候可以利用模板引擎从一个变量中取得错误并显示</p></li><li><p>如果是 Ajax 调教的会返回一个 Json，如果想用 Postman 测试，要添加一个 header</p><pre><code>X-Requested-With:XMLHttpRequest</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> 项目 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel-数据库迁移的版本管理</title>
      <link href="/2018/04/23/Laravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/23/Laravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Laravel 中的数据库迁移时用来管理数据库的，你可以把表结构写入到代码中，然后运行一条 artisan 命令既可以快速生成所需要的数据库，这些命令如何敲，官方文档里面已经很详细的介绍。</p><p>但是不可忽视的是：migrate 还可以用于数据库的版本控制，那这个版本控制体现在哪？如何进行版本控制？在官方文档中并没有比较详细的介绍，只是一笔带过，很多新手对此就会很迷惑。</p><p>这是本文讨论的核心就是：<strong>数据库迁移的版本管理</strong>。</p><h1 id="一、迁移"><a href="#一、迁移" class="headerlink" title="一、迁移"></a>一、迁移</h1><h2 id="1-迁移的生成"><a href="#1-迁移的生成" class="headerlink" title="1. 迁移的生成"></a>1. 迁移的生成</h2><p>在文档中，说下面的第一句可以用来生成数据表，而第二句的 <code>--create</code> 参数用来显示指定数据表的名称。</p><p>对于第三句的 <code>--table</code> 参数也是说指定数据表的名称。</p><p><strong>但其实第三句创建的这个迁移其实才是版本管理的核心。</strong></p><pre><code class="shell">php artisan make:migration create_users_tablephp artisan make:migration create_users_table --create=usersphp artisan make:migration add_votes_to_users_table --table=users</code></pre><h2 id="2-down-和-up"><a href="#2-down-和-up" class="headerlink" title="2. down 和 up"></a>2. down 和 up</h2><pre><code class="shell">php artisan migrate                # 执行迁移命令php artisan migrate:install        # 生成 migrations 表，记录迁移的执行情况php artisan migrate:refresh        # 回滚之后再生成php artisan migrate:reset        # 回滚所有迁移php artisan migrate:rollback    # 回滚最近一次迁移，可以指定回滚次数php artisan migrate:status        # 查看迁移的执行情况</code></pre><p>你需要注意的是，执行迁移执行的是迁移文件中的 up 方法，而执行回滚执行的是迁移文件中的 down 方法，也就是说：</p><blockquote><p>如果对于你自己新建的迁移文件，如果你执行回滚并没有发生任何变化，其实是因为你忘记编写 down 方法了。</p></blockquote><p>以 Laravel 自带的迁移文件为例：</p><pre><code class="php">&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class CreateUsersTable extends Migration{    public function up()    {        Schema::create(&#39;users&#39;, function (Blueprint $table) {            $table-&gt;increments(&#39;id&#39;);            $table-&gt;string(&#39;name&#39;);            $table-&gt;string(&#39;email&#39;)-&gt;unique();            $table-&gt;string(&#39;password&#39;);            $table-&gt;string(&#39;phone&#39;);            $table-&gt;rememberToken();            $table-&gt;timestamps();        });    }    public function down()    {        DB::statement(&#39;SET FOREIGN_KEY_CHECKS = 0&#39;);        Schema::dropIfExists(&#39;users&#39;);        DB::statement(&#39;SET FOREIGN_KEY_CHECKS = 1&#39;);    }}</code></pre><p>up 方法生成数据库，而 down 会在执行回滚时被执行。</p><p>另外值得注意的是，这里还有一个小坑，如果你在别的迁移表中使用了外键约束，而外键来自于这个表，就会导致回滚失败，所以你需要添加下面这两行，把要 drop 表的命令夹在中间：</p><pre><code class="php">Schema::disableForeignKeyConstraints();Schema::dropIfExists(&#39;users&#39;);Schema::enableForeignKeyConstraints();// 如果是非默认数据库的Schema::connection(&#39;mysql-passport&#39;)-&gt;disableForeignKeyConstraints();</code></pre><blockquote><p>值得注意的是：执行回滚时，回滚会按照迁移执行的顺序逆向执行，而迁移执行的顺序是按照迁移文件的文件名前缀时间顺序执行的，例如：</p><p>2014_10_12_100000_create_users_table 会在 2010_04_23_100442_add_votes_to_users_table 的背后执行。</p></blockquote><h2 id="3-迁移的修改"><a href="#3-迁移的修改" class="headerlink" title="3. 迁移的修改"></a>3. 迁移的修改</h2><p>先安装一个插件，如果不安装，有些修改命令无法使用：</p><pre><code class="shell">composer require doctrine/dbal</code></pre><p>执行下面命令生成一个修改 user 表的迁移文件：</p><pre><code class="shell">php artisan make:migration add_votes_to_users_table --table=users</code></pre><p>生成后里面的内容是这样的：</p><pre><code class="php">&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class AddVotesToUsersTable extends Migration{    public function up()    {        Schema::table(&#39;users&#39;, function (Blueprint $table) {            // 这是我加上去的，把字段 name 更名为 myname            $table-&gt;renameColumn(&#39;name&#39;, &#39;myname&#39;);            // 这是我加上去的，修改字段长度            $table-&gt;string(&#39;item_key&#39;, 50)-&gt;change();        });    }    public function down()    {        Schema::table(&#39;users&#39;, function (Blueprint $table) {            //        });    }}</code></pre><blockquote><p>值得注意的是，利用迁移修改字段属性时，只需加上需要修改的属性，而无需把以前生成时有的属性重复。</p></blockquote><h1 id="二、迁移的“一对多”"><a href="#二、迁移的“一对多”" class="headerlink" title="二、迁移的“一对多”"></a>二、迁移的“一对多”</h1><p>Laravel 中给的几个表，都是一个迁移文件对应一个表，一次修改对应一个表，但是这样如果表一多，整个文件夹就会很乱，所以我个人倾向于，把一个项目分成多个系统，然后每个系统的所有表放在一个迁移文件里面，把每次 的迁移修改放在一个迁移文件里。</p><h2 id="1-生成"><a href="#1-生成" class="headerlink" title="1. 生成"></a>1. 生成</h2><p>在一个迁移文件中生成多个表：</p><pre><code class="shell">php artisan make:migration create_api_sys</code></pre><p><strong>2018_01_21_074602_create_api_sys.php</strong></p><pre><code class="php">&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class CreateApiSys extends Migration{    public function up()    {        Schema::create(&#39;api_items&#39;, function (Blueprint $table) {            $table-&gt;increments(&#39;id&#39;);            $table-&gt;string(&#39;item_key&#39;, 30)-&gt;unique()-&gt;comment(&#39;API唯一性key&#39;);            $table-&gt;string(&#39;url&#39;, 150)-&gt;comment(&#39;API URL地址&#39;);            $table-&gt;string(&#39;method&#39;, 10)-&gt;comment(&#39;API 调用方法&#39;);            $table-&gt;string(&#39;intro&#39;, 500)-&gt;comment(&#39;API介绍&#39;);            $table-&gt;timestamps();        });        Schema::create(&#39;api_groups&#39;, function (Blueprint $table) {            $table-&gt;increments(&#39;id&#39;);            $table-&gt;string(&#39;group_key&#39;, 30)-&gt;unique()-&gt;comment(&#39;group唯一性key&#39;);            $table-&gt;string(&#39;intro&#39;, 500)-&gt;comment(&#39;Group介绍&#39;);            $table-&gt;timestamps();        });    }    public function down()    {        // 回滚用        Schema::dropIfExists(&#39;api_items&#39;);        Schema::dropIfExists(&#39;api_groups&#39;);    }}</code></pre><h2 id="2-修改"><a href="#2-修改" class="headerlink" title="2. 修改"></a>2. 修改</h2><p>在一个迁移文件中修改多个表：</p><pre><code class="shell">php artisan make:migration change_2018_4_24_api_sys</code></pre><p><strong>2018_04_24_113610_change_2018_4_24_api_sys.php</strong></p><pre><code class="php">&lt;?phpuse Illuminate\Support\Facades\Schema;use Illuminate\Database\Schema\Blueprint;use Illuminate\Database\Migrations\Migration;class Change2018426ApiSys extends Migration{    public function up()    {        Schema::table(&#39;password_resets&#39;, function (Blueprint $table) {            $table-&gt;string(&#39;token&#39;)-&gt;comment(&#39;my comment&#39;)-&gt;change();        });        Schema::table(&#39;users&#39;, function (Blueprint $table) {            $table-&gt;string(&#39;left_times&#39;)-&gt;comment(&#39;my comment&#39;)-&gt;change();        });    }    public function down()    {        // 在这里写上面的反操作（能够让表变为之前状态的操作）    }}</code></pre><blockquote><p>这里有个坑：有着外键约束或唯一约束的表，在这里基本不能操作成功</p></blockquote>]]></content>
      
      <categories>
          
          <category> Laravel </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>舍弃phpStudy用Homestead搭建Laravel环境</title>
      <link href="/2018/04/20/%E8%88%8D%E5%BC%83phpstudy%E7%94%A8Homestead%E6%90%AD%E5%BB%BALaravel%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/04/20/%E8%88%8D%E5%BC%83phpstudy%E7%94%A8Homestead%E6%90%AD%E5%BB%BALaravel%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>前面在 <a href="/2017/12/30/Laravel-Lumen教程1——基础环境搭建">Laravel-Lumen教程——基础环境搭建</a> 一文中，我用 Docker 和 phpStudy 搭建了开发环境，今天决定再尝试用 Homestead 来搭建一次开发环境，主要是看了<a href="https://laravel-china.org/docs/laravel-development-environment/5.5" target="_blank" rel="noopener">社区的建议</a>。</p><p><a href="https://laravel-china.org/docs/laravel-development-environment/5.5" target="_blank" rel="noopener">社区的建议</a>中非常完整详细的介绍了安装步骤，所以我并不需要锦上添花，在此仅仅提取概要，便于快速翻阅，另外记录我所遇到的问题。</p><h1 id="一、基础环境"><a href="#一、基础环境" class="headerlink" title="一、基础环境"></a>一、基础环境</h1><h2 id="1-步骤概要"><a href="#1-步骤概要" class="headerlink" title="1. 步骤概要"></a>1. 步骤概要</h2><ol><li>安装 VirtualBox</li><li>安装 Vagrant</li><li>导入 Homestead Box 虚拟机盒子</li><li>安装 Git</li><li>安装 Homestead 管理脚本</li><li>配置 <code>Homestead.yaml</code> 文件</li><li>启动 Homestead 虚拟机</li></ol><h2 id="2-遇到的问题"><a href="#2-遇到的问题" class="headerlink" title="2. 遇到的问题"></a>2. 遇到的问题</h2><h3 id="导入-Box-时报错"><a href="#导入-Box-时报错" class="headerlink" title="导入 Box 时报错"></a>导入 Box 时报错</h3><h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><p><img src="舍弃phpstudy用Homestead搭建Laravel环境.assets/1524249062756.png" alt="1524249062756"></p><h4 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h4><pre><code class="shell">$ vagrant box add metadata.json==&gt; box: Loading metadata for box &#39;metadata.json&#39;    box: URL: file://D:/Laravel/metadata.jsonAn error occurred while downloading the remote file. The errormessage, if any, is reproduced below. Please fix this error and tryagain.Invalid file://hostname/, expected localhost or 127.0.0.1 or none</code></pre><p><img src="舍弃phpstudy用Homestead搭建Laravel环境.assets/1524249036620.png" alt="1524249036620"></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p><img src="舍弃phpstudy用Homestead搭建Laravel环境.assets/1524249208360.png" alt="1524249208360"></p><p><img src="舍弃phpstudy用Homestead搭建Laravel环境.assets/1524249195636.png" alt="1524249195636"></p><h2 id="3-快捷命令查看"><a href="#3-快捷命令查看" class="headerlink" title="3. 快捷命令查看"></a>3. 快捷命令查看</h2><h3 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h3><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>vagrant init</td><td>初始化 vagrant</td></tr><tr><td>vagrant up</td><td>启动 vagrant</td></tr><tr><td>vagrant halt</td><td>关闭 vagrant</td></tr><tr><td>vagrant ssh</td><td>通过 SSH 登录 vagrant（需要先启动 vagrant）</td></tr><tr><td>vagrant provision</td><td>重新应用更改 vagrant 配置（添加的新的站点的时候）</td></tr><tr><td>vagrant destroy</td><td>删除 vagrant</td></tr><tr><td>$ exit</td><td>从虚拟机中退出</td></tr><tr><td>vagrant box list</td><td>查看所有盒子</td></tr></tbody></table><h1 id="二、Laravel-环境"><a href="#二、Laravel-环境" class="headerlink" title="二、Laravel 环境"></a>二、Laravel 环境</h1><h2 id="1-安装-Laravel"><a href="#1-安装-Laravel" class="headerlink" title="1. 安装 Laravel"></a>1. 安装 Laravel</h2><pre><code class="shell">composer global require &quot;laravel/installer&quot;# 新建项目laravel new blog</code></pre><h2 id="2-虚拟机的-Mysql-密码"><a href="#2-虚拟机的-Mysql-密码" class="headerlink" title="2. 虚拟机的 Mysql 密码"></a>2. 虚拟机的 Mysql 密码</h2><p>用户名：homestead</p><p>密码：secret</p><p>命令行登陆：$ mysql -uhomestead -psecret</p><blockquote><p>如果你想的话，你可以自己装一个 PHPmyadmin 用来管理你的数据库</p></blockquote><h2 id="3-虚拟机的-ssh-登录账户"><a href="#3-虚拟机的-ssh-登录账户" class="headerlink" title="3. 虚拟机的 ssh 登录账户"></a>3. 虚拟机的 ssh 登录账户</h2><h3 id="默认账户"><a href="#默认账户" class="headerlink" title="默认账户"></a>默认账户</h3><p>vagrant/vagrant</p><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><pre><code class="shell">sudo passwd root   # 需要你自己手动设置</code></pre><h2 id="4-修改时区"><a href="#4-修改时区" class="headerlink" title="4. 修改时区"></a>4. 修改时区</h2><pre><code class="shell">sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre><h1 id="三、坑"><a href="#三、坑" class="headerlink" title="三、坑"></a>三、坑</h1><h2 id="1-Swagger-assets加载-404"><a href="#1-Swagger-assets加载-404" class="headerlink" title="1. Swagger assets加载 404"></a>1. Swagger assets加载 404</h2><p><img src="舍弃phpstudy用Homestead搭建Laravel环境.assets/1524593084760.png" alt="1524593084760"></p><p>不知道为什么，在 Homestead 配置好的环境下，这些 UI 素材会加载 404，我猜可能是：</p><pre><code class="shell">php artisan swagger-lume:publish   # 执行没有生效</code></pre><p><strong>手动配置一下</strong></p><pre><code class="shell">cp -a vendor/swagger-api/swagger-ui/dist public/swagger-ui-assets</code></pre><p><strong>或者修改 nginx 配置文件</strong></p><pre><code class="shell"># 删除这样的部分，如果你有的话（我的没有，但是GitHub上有人提出了这样的解决办法）location ~* .(jpg|jpeg|png|gif|ico|css|js)$ {    expires 365d;}</code></pre>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快查-JavaScript</title>
      <link href="/2018/04/12/%E5%BF%AB%E6%9F%A5-JavaScript/"/>
      <url>/2018/04/12/%E5%BF%AB%E6%9F%A5-JavaScript/</url>
      <content type="html"><![CDATA[<p>整理一些基础语法，主要记了下容易和其他语言混淆的一些地方和 JavaScript 的一些特点。</p><h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><p>在 JavaScript 中有 5 种不同的数据类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>object</li><li>function</li></ul><p>3 种对象类型：</p><ul><li>Object</li><li>Date</li><li>Array</li></ul><p>2 个不包含任何值的数据类型：</p><ul><li>null</li><li>undefined</li></ul><p>声明新变量时，可以使用关键词 “new” 来声明其类型：</p><pre><code class="javascript">var carname=new String;var x=      new Number;var y=      new Boolean;var cars=   new Array;var person= new Object;</code></pre><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组-Array"></a>数组-Array</h3><p>三种方式</p><pre><code class="javascript">// #1var cars=new Array();cars[0]=&quot;Saab&quot;;cars[1]=&quot;Volvo&quot;;cars[2]=&quot;BMW&quot;;// #2var cars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);// #3var cars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];// array 会把数值字符串转化为合适的数字var a=new Array();a[&#39;a1&#39;]=1;    // 这是对象属性a[2]=2;        // 这才是数组元素a.length  // 输出3var b = new Array();b[&#39;100&#39;] = 100;b.length  // 输出101</code></pre><h3 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象-Object"></a>对象-Object</h3><pre><code class="JavaScript">// #1 对象定义方式var person = {    firstName: &quot;John&quot;,    lastName : &quot;Doe&quot;,    id : 5566,    fullName : function()     {       return this.firstName + &quot; &quot; + this.lastName;    }};// #2 或者先创建一个对象再赋予赋予一个新方法var person=new Object();person.firstName = &quot;John&quot;;person.lastName = &quot;Doe&quot;;person.method=function(){  return this.firstname+this.lastname;}// #3 对象构造器的方法创建function person(firstname,lastname,age,eyecolor){    this.firstname=firstname;    this.lastname=lastname;    this.age=age;    this.eyecolor=eyecolor;}var myFather=new person(&quot;John&quot;,&quot;Doe&quot;,50,&quot;blue&quot;);// 取值name=person.lastname;name=person[&quot;lastname&quot;];</code></pre><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串-String"></a>字符串-String</h3><p>字符串属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>返回创建字符串属性的函数</td></tr><tr><td>length</td><td>返回字符串的长度</td></tr><tr><td>prototype</td><td>向对象添加属性和方法</td></tr></tbody></table><p>常用方法</p><table><thead><tr><th style="text-align:left">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">charAt()</td><td>返回指定索引位置的字符，也可以直接 str[7] 这样取</td></tr><tr><td style="text-align:left">indexOf()</td><td>返回字符串中检索指定字符第一次出现的位置</td></tr><tr><td style="text-align:left">lastIndexOf()</td><td>返回字符串中检索指定字符最后一次出现的位置</td></tr><tr><td style="text-align:left">match()</td><td>找到一个或多个正则表达式的匹配</td></tr><tr><td style="text-align:left">replace()</td><td>替换与正则表达式匹配的子串</td></tr><tr><td style="text-align:left">search()</td><td>检索与正则表达式相匹配的值</td></tr><tr><td style="text-align:left">slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分，参数为开始和结束（可选）</td></tr><tr><td style="text-align:left">split()</td><td>把字符串分割为子字符串数组，第二个参数表示切割出多少个</td></tr><tr><td style="text-align:left">substr()</td><td>从起始索引号提取字符串中指定数目的字符</td></tr><tr><td style="text-align:left">substring()</td><td>提取字符串中两个指定的索引号之间的字符</td></tr><tr><td style="text-align:left">toString()</td><td>返回一个字符串对象值，Number.toSring()</td></tr><tr><td style="text-align:left">valueOf()</td><td>返回某个字符串对象的原始值</td></tr><tr><td style="text-align:left">trim()</td><td>移除字符串首尾空白</td></tr><tr><td style="text-align:left">String()</td><td>String(100 + 23)  // 将数字表达式转换为字符串并返回</td></tr></tbody></table><h3 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字-Number"></a>数字-Number</h3><p><strong>无穷大 Infinity：</strong></p><pre><code class="JavaScript">var x = 2/0;    // Infinity    var y = -2/0;    // -Infinity</code></pre><p><strong>非数字值 NaN：</strong></p><p>可以用 <code>isNaN</code> 这个函数来判断一个值是否为 NaN 值</p><pre><code class="JavaScript">var x = 1000 / &quot;Apple&quot;;isNaN(x); // 返回 true    var y = 100 / &quot;1000&quot;;isNaN(y); // 返回 false</code></pre><h3 id="日期-Date"><a href="#日期-Date" class="headerlink" title="日期-Date"></a>日期-Date</h3><p>实现一个网页钟表</p><pre><code class="JavaScript">function startTime(){    var today=new Date();        // 获取当前时间    var h=today.getHours();        // 获取时间的小时    var m=today.getMinutes();    var s=today.getSeconds();    m=checkTime(m);    s=checkTime(s);    document.getElementById(&#39;txt&#39;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s;    t=setTimeout(function(){startTime()},500);}// 在小于10的数字前加一个‘0’function checkTime(i){    if (i&lt;10){        i=&quot;0&quot; + i;    }    return i;}</code></pre><p>四种初始化日期的方法</p><pre><code class="JavaScript">new Date() // 当前日期和时间new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数new Date(dateString)new Date(year, month, day, hours, minutes, seconds, milliseconds)var today = new Date()var d1 = new Date(&quot;October 13, 1975 11:13:00&quot;)var d2 = new Date(79,5,24)var d3 = new Date(79,5,24,11,33,0)</code></pre><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof 用来检测变量的数据类型。</p><pre><code class="JavaScript">typeof &quot;John&quot;                // 返回 string typeof 3.14                  // 返回 numbertypeof false                 // 返回 booleantypeof [1,2,3,4]             // 返回 objecttypeof {name:&#39;John&#39;, age:34} // 返回 objecttypeof null                    // 返回 objecttypeof NaN                    // 返回 numbertypeof myCar                  // 返回 undefined (如果 myCar 没有声明)// 由于 Date 和 Array 的返回都为 Object ，所以无法通过它来判断一个对象到底是日期还是数组// 所以可以通过以下这种方式function isArray(myArray) {    return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;    // 为数组时返回 true}function isDate(myDate) {    return myDate.constructor.toString().indexOf(&quot;Date&quot;) &gt; -1;        // 为Date时返回 true}</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>可通过 instanceof 操作符来判断对象的具体类型，语法格式:</p><pre><code class="JavaScript">// var result = objectName instanceof objectType   返回布尔值arr = [1,2,3];if(arr instanceof Array){    document.write(&quot;arr 是一个数组&quot;);} else {    document.write(&quot;arr 不是一个数组&quot;);}</code></pre><h3 id="undifined-和-null"><a href="#undifined-和-null" class="headerlink" title="undifined 和 null"></a>undifined 和 null</h3><p>undefined 这个值表示变量不含有值，可以用来将变量清空，也可以通过将变量的值设置为 null 来清空变量。</p><p><strong>null</strong> 用于对象, <strong>undefined</strong> 用于变量，属性和方法。</p><pre><code class="javascript">var x = 5;typeof x;    // 5var x = null;    typeof x;    // nullvar x = undefined;typeof x     // undefinded// 两者的布尔属性都为 falseif(typeof a!=&quot;undefined&quot;){}    // 最好还是以这种方法，不然如果 a 没有被定义就会报错</code></pre><h3 id="debugger-关键字"><a href="#debugger-关键字" class="headerlink" title="debugger 关键字"></a>debugger 关键字</h3><p>相当于设置一个断点；</p><pre><code class="JavaScript">var x = 15 * 5;debugger;document.getElementbyId(&quot;demo&quot;).innerHTML = x;</code></pre><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>返回构造函数</p><pre><code class="JavaScript">&quot;John&quot;.constructor                 // 返回函数 String()  { [native code] }(3.14).constructor                 // 返回函数 Number()  { [native code] }false.constructor                  // 返回函数 Boolean() { [native code] }[1,2,3,4].constructor              // 返回函数 Array()   { [native code] }{name:&#39;John&#39;, age:34}.constructor  // 返回函数 Object()  { [native code] }new Date().constructor             // 返回函数 Date()    { [native code] }function () {}.constructor         // 返回函数 Function(){ [native code] }</code></pre><h2 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3. 正则表达式"></a>3. 正则表达式</h2><h3 id="正则式和修饰符"><a href="#正则式和修饰符" class="headerlink" title="正则式和修饰符"></a>正则式和修饰符</h3><pre><code class="JavaScript">var patt = /runoob/i;</code></pre><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>执行对大小写不敏感的匹配。</td></tr><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td>m</td><td>执行多行匹配。</td></tr></tbody></table><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>返回子串的起始位置</p><pre><code class="javascript">var n = str.search(/Runoob/i);    // 用正则var n = str.search(&quot;Runoob&quot;);    // 用字符串</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>查找并替换</p><pre><code class="JavaScript">var txt = str.replace(/microsoft/i,&quot;Runoob&quot;);var txt = str.replace(&quot;Microsoft&quot;,&quot;Runoob&quot;);    // 同样可以用字符串</code></pre><h3 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h3><pre><code class="javascript">var pattern = /e/;     // 构建一个正则对象// test 方法，用于检测是否匹配，匹配则返回true，否则返回falsepatt.test(&quot;The best things in life are free!&quot;);    // true/e/.test(&quot;The best things in life are free!&quot;);     // 你也可以这么写// exec 方法，用于返回一个匹配结果的数组/e/.exec(&quot;The best things in life are free!&quot;);</code></pre><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code class="JavaScript">var x = function (a, b) {return a * b};var z = x(4, 3);</code></pre><h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。这种函数的的定义和调用是一体的。</p><pre><code class="JavaScript">// 实际上是一个匿名自调用函数(function () {    var x = &quot;Hello!!&quot;;      // 我将调用自己})();</code></pre><h3 id="显式参数-Parameters"><a href="#显式参数-Parameters" class="headerlink" title="显式参数(Parameters)"></a>显式参数(Parameters)</h3><pre><code class="JavaScript">function functionName(parameter1, parameter2, parameter3) {    // 要执行的代码……}</code></pre><h3 id="隐式参数-Arguments"><a href="#隐式参数-Arguments" class="headerlink" title="隐式参数(Arguments)"></a>隐式参数(Arguments)</h3><ul><li>arguments不管函数声明时的参数个数，而是调用实际传递给函数的参数;</li><li>arguments[index]获得参数值；</li><li>arguments.length获得实际传递的参数个数；</li></ul><pre><code class="javascript">function functionName(){    console.log(arguments);}// 还有一个 callee 属性，实现递归调用var sum = function(n){      if(1==n) {          return 1;  　  } else {          return n + arguments.callee(n-1);      }  }  console.log(sum(10));  </code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>两种写法：</p><pre><code class="JavaScript">function myFunction(x, y) {    if (y === undefined) {          y = 0;    } }// orfunction myFunction(x, y) {    y = y || 0;}</code></pre><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call() 和 apply()"></a>call() 和 apply()</h3><p>在特定的作用域中调用函数,能改变函数的作用域，实际上是改变函数体内 <code>this</code> 的值 。</p><p>说通俗一点就是，借你家函数用一下，call 和 apply 效果一行，只是传参不同。</p><pre><code class="javascript">foo.call(this, arg1,arg2,arg3) == foo.apply(this, [arg1, arg2, arg3]) == this.foo(arg1, arg2, arg3)</code></pre><p><strong>call方法:</strong><br>语法：call(thisObj，Object)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p><p><strong>apply方法:</strong><br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是指浏览器和用户的某种行为，以下是一些常见的事件：</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onchange</td><td>HTML 元素改变</td></tr><tr><td>onclick</td><td>用户点击 HTML 元素</td></tr><tr><td>onmouseover</td><td>用户在一个HTML元素上移动鼠标</td></tr><tr><td>onmouseout</td><td>用户从一个HTML元素上移开鼠标</td></tr><tr><td>onkeydown</td><td>用户按下键盘按键</td></tr><tr><td>onload</td><td>浏览器已完成页面的加载</td></tr></tbody></table><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code class="JavaScript">// JS 支持的一种遍历写法var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25}; for (x in person)  // x 为属性名{    txt=txt + person[x];}</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>给一段代码块打上标签，然后就能通过 <code>continue</code> 和 <code>break</code> 跳出代码块。</p><pre><code class="JavaScript">cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];list:                                 // 这里是标签{    document.write(cars[0] + &quot;&lt;br&gt;&quot;);     document.write(cars[1] + &quot;&lt;br&gt;&quot;);     document.write(cars[2] + &quot;&lt;br&gt;&quot;);     break list;    document.write(cars[3] + &quot;&lt;br&gt;&quot;);     document.write(cars[4] + &quot;&lt;br&gt;&quot;);     document.write(cars[5] + &quot;&lt;br&gt;&quot;); }</code></pre><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><pre><code class="javascript">function myFunction() {    var message, x;    message = document.getElementById(&quot;message&quot;);    message.innerHTML = &quot;&quot;;    x = document.getElementById(&quot;demo&quot;).value;    try {                                         // 测试错误        if(x == &quot;&quot;)  throw &quot;值为空&quot;;                // 抛出错误        if(isNaN(x)) throw &quot;不是数字&quot;;        x = Number(x);        if(x &lt; 5)    throw &quot;太小&quot;;        if(x &gt; 10)   throw &quot;太大&quot;;    }    catch(err) {                                // 处理错误        message.innerHTML = &quot;错误: &quot; + err;    }}</code></pre><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p><p>所以 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p><p>但是初始化是不会被提升的。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式是 ES5 新增的，在这个模式下你不能使用未声明的变量</p><pre><code class="JavaScript">&quot;use strict&quot;;    // 只允许出现在脚本或函数的开头x = 3.14;       // 报错 (x 未定义)var x = 3.14    // 不报错</code></pre><h3 id="“-”-号运算符"><a href="#“-”-号运算符" class="headerlink" title="“+” 号运算符"></a>“+” 号运算符</h3><ol><li><p>和逻辑值进行运算时，false 变成 0，true 变成 1：</p><pre><code class="javascript">var one=13;var two=true;var three=one+two;// 结果 three:14</code></pre></li><li><p>取模运算的结果符号只与左边值的符号有关：</p><pre><code class="javascript">var x = 7 % 3; // 结果为 1var y = 7 % (-3); // 结果为 1var z = (-7) % 3; // 结果为 -1</code></pre></li><li><p>数字与 null(空值) 相加，null 转化为数字 0：</p><pre><code class="javascript">var car=null+3+4;    // 结果为7</code></pre><p>字符串与 null(空值) 相加，null 转化为字符串：</p><pre><code class="javascript">var car=null+&quot;a&quot;;    // 结果为 nulla</code></pre></li><li><p>将变量转换为数字，不能转换的话变成 NaN：</p><pre><code class="javascript">var y = &quot;5&quot;;      // y 是一个字符串var x = + y;      // x 是一个数字var y = &quot;John&quot;;   // y 是一个字符串var x = + y;      // x 是一个数字 (NaN)</code></pre></li><li><p>“-” 号</p><pre><code class="javascript">&quot;5&quot; - 1     // 返回 4         &quot;5&quot; 转换为 5</code></pre></li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>注意 json 是键值都是包在双引号之中的：</p><pre><code class="json">{    &quot;name&quot;:&quot;yangf&quot;,    &quot;sex&quot;:1}</code></pre><p>把 Json 字符串解析为 JavaScript 对象：</p><pre><code class="JavaScript">var obj = JSON.parse(text);        // text 为 Json 格式的字符串var jsonStr = JSON.stringify(obj);     // 上面的反函数</code></pre><h3 id="javascript-void-0"><a href="#javascript-void-0" class="headerlink" title="javascript:void(0)"></a>javascript:void(0)</h3><p>表示一个死链接，和 <code>href=&quot;#[pos]&quot;</code> 存在区别，后者是一个锚点，默认为页面上端，而前者是纯粹的一个死链接。你也可以这么用 <code>href=&quot;javascript:void(alert(&#39;Warning!!!&#39;))&quot;</code></p><h1 id="二、常见用法"><a href="#二、常见用法" class="headerlink" title="二、常见用法"></a>二、常见用法</h1><h3 id="1-正则校验中文"><a href="#1-正则校验中文" class="headerlink" title="1. 正则校验中文"></a>1. 正则校验中文</h3><pre><code class="JavaScript">var reg=/^[\u4E00-\u9FA5]{2,4}$/;   /*定义验证表达式*/</code></pre><h3 id="2-表单校验"><a href="#2-表单校验" class="headerlink" title="2. 表单校验"></a>2. 表单校验</h3><p><strong>onsubmit=”return validateForm()”</strong></p><pre><code class="html">&lt;script&gt;function validateForm() {    var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;    if (x == null || x == &quot;&quot;) {        alert(&quot;需要输入名字。&quot;);        return false;    }}&lt;/script&gt;&lt;form name=&quot;myForm&quot; action=&quot;demo_form.php&quot; onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre><h3 id="3-算术运算"><a href="#3-算术运算" class="headerlink" title="3. 算术运算"></a>3. 算术运算</h3><p>主要用到 <code>Math</code> 对象，进行算术运算。</p><pre><code class="JavaScript">Math.round(4.7);  // 5</code></pre><h1 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h1><h3 id="1-var-与变量作用域"><a href="#1-var-与变量作用域" class="headerlink" title="1. var 与变量作用域"></a>1. var 与变量作用域</h3><pre><code class="JavaScript">var int a;        // 全局int b;            // 全局function get(){    int x;        // 全局    var int y;    // 局部}</code></pre><h3 id="2-this"><a href="#2-this" class="headerlink" title="2. this"></a>2. this</h3><p>总是指向调用它所在方法的对象，或者说：this指向函数执行时的当前对象。</p><h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h3><p>JavaScript 中子函数可以访问父函数的变量，但是父函数不可以访问子变量。</p><p><strong>能够读取其他函数内部变量的函数</strong>，放到 JavaScript 中就是，定义在函数内部的函数，以为 JavaScript 是链式作用域，即子对象可以访问父对象的数据，但是反过来不行。所以父对象需要访问子对象变量数据时就要用到闭包。</p><p><strong>闭包的用途：</strong></p><ul><li>读取函数内部的变量（这个前面解释了）</li><li>让变量的值始终保存在内存中：如果闭包函数被赋给一个全局变量，那么闭包函数用到的局部变量将不会被回收</li></ul><p><strong>闭包的注意点：</strong></p><ul><li>由于闭包会使函数变量保存在内存中是，所以不能滥用闭包</li><li>由于闭包函数可以在函数外改变函数内的变量，所以要注意你对函数变量的定义是公有还是私有</li></ul><h3 id="4-DOM"><a href="#4-DOM" class="headerlink" title="4. DOM"></a>4. DOM</h3><p>文档对象模型（Document Object Model），一棵树。获取 DOM 元素，操纵 HTML 文档：</p><pre><code class="JavaScript">// 获取getElementById(&quot;main&quot;);getElementsByTagName(&quot;p&quot;);getElementsByClassName(&quot;intro&quot;);// 改变HTML属性document.getElementById(id).attribute=新属性值document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;// 改变CSSdocument.getElementById(id).style.property=新样式document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;// 事件document.getElementById(&quot;myBtn&quot;).onclick=function(){displayDate()};// 添加监听，最后一个参数选择冒泡（类元素先触发）或者捕获（外元素先触发）// 冒泡：false   捕获：trueelement.addEventListener(&quot;click&quot;, function(){ alert(&quot;Hello World!&quot;); }[, true/false]);// 移除监听element.removeEventListener(&quot;mousemove&quot;, myFunction);// 增删DOM元素// 增元素var para=document.createElement(&quot;p&quot;);var node=document.createTextNode(&quot;这是一个新段落。&quot;);para.appendChild(node);// 删除一个元素必需知道它的父元素var child=document.getElementById(&quot;p1&quot;);child.parentNode.removeChild(child);</code></pre><blockquote><p>onclick 和 addEventListener 的区别，前者定义第二个动作时会把第一个覆盖掉，而后者不会</p></blockquote><h3 id="5-BOM"><a href="#5-BOM" class="headerlink" title="5. BOM"></a>5. BOM</h3><p>浏览器对象模型 (<strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel (BOM)) 使 JavaScript 有能力与浏览器”对话”。</p><p>最常用的有诸如 <code>alert</code> 和 <code>location</code></p><h4 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h4><ul><li>setInterval() - 间隔指定的毫秒数不停地执行指定的代码。</li><li>setTimeout() - 在指定的毫秒数后执行指定代码。</li></ul><pre><code class="JavaScript">// 每三秒弹出一次var myVar = setInterval(function(){alert(&quot;Hello&quot;)},3000);// 停止执行clearInterval(myVar);// 三秒后执行var myVar = setTimeout(function(){alert(&quot;Hello&quot;)},3000);// 取消执行clearTimeout(myVar);</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><pre><code class="JavaScript">// 设置cookiedocument.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/&quot;;// 获取cookievar x = document.cookie;</code></pre><h3 id="6-浮点型数据"><a href="#6-浮点型数据" class="headerlink" title="6. 浮点型数据"></a>6. 浮点型数据</h3><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储。</p><p>所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定：</p><pre><code class="JavaScript">var x = 0.1;var y = 0.2;var z = x + y            // z 的结果为 0.3if (z == 0.3)            // 返回 falsevar z = (x * 10 + y * 10) / 10;       // z 的结果为 0.3，可以这么写   </code></pre><h3 id="7-传值和传址"><a href="#7-传值和传址" class="headerlink" title="7. 传值和传址"></a>7. 传值和传址</h3><p>在JS中，有两种不同的方式可以操作数据的值，分别是 <strong>传值</strong> 和 <strong>传址</strong>。</p><p><strong>传值：</strong>数字(Number)、布尔类型(Boolean)、字符串(String)</p><p><strong>传址：</strong>对象(Object) 、数组(Array)、函数(Function)</p><p>如果要复制一个对象，简单的新建然后赋值是不行的，所以就涉及到了深拷贝和浅拷贝。</p><p><a href="http://www.css88.com/archives/8319" target="_blank" rel="noopener"><strong>这里有一篇文章，后面好好整理一下</strong></a></p><h1 id="四、框架"><a href="#四、框架" class="headerlink" title="四、框架"></a>四、框架</h1><h2 id="1-jQuery"><a href="#1-jQuery" class="headerlink" title="1. jQuery"></a>1. jQuery</h2><pre><code class="JavaScript">// 第一种写法：把要执行的函数用 $(document).ready(); 包起来$(document).ready(function(){  $(&quot;#hide&quot;).click(function(){    $(&quot;p&quot;).hide();  });  $(&quot;#show&quot;).click(function(){    $(&quot;p&quot;).show();  });});// 第二种写法：把要执行的函数作为参数传入function myFunction(){    $(&quot;#h01&quot;).attr(&quot;style&quot;,&quot;color:red&quot;).html(&quot;Hello jQuery&quot;)}$(document).ready(myFunction);</code></pre>]]></content>
      
      <categories>
          
          <category> 快查 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++刷题常用操作</title>
      <link href="/2018/04/11/C-%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/04/11/C-%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>整理一些常用 C++ 刷题操作。</p><h1 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h1><h3 id="1-常用容器"><a href="#1-常用容器" class="headerlink" title="1. 常用容器"></a>1. 常用容器</h3><pre><code class="c++">// 建议用 C++ 支持的数组array&lt;int, 3&gt; arr = {0,1,2};// 可自动增删的容器，方便的后端增删vector&lt;int&gt; vec;// 可自动增删的容器，方便的双端增删deque&lt;int&gt; deq;// 可自动增删的容器，方便地删除指定值（remove），和去除重复值（unique），不支持下标访问list&lt;int&gt; list;// 可自动增删的容器，自动去重，方便的查找元素位置（find-迭代器）,数元素（count），不支持下标访问set&lt;int&gt; set;  // multset-可重复的set// 键值数组map&lt;string, int&gt; m;// 对pair&lt;int, int&gt; p(1, 1.2);// = 赋值p = make_pair(1, 1.2);// 元素访问p.first；p.second；</code></pre><blockquote><p>以上容器都支持如下操作：</p><ul><li>size - 返回有效元素个数，但是对于 array 只会返回预定义的大小</li><li>empty - 判断是否为空</li></ul><p>某些容器支持如下操作：</p><ul><li>front - 获取第一个元素</li><li>back - 获取最后一个元素</li><li>insert - 插入一个元素</li><li>erase - 删除一个元素</li></ul><p>所有容器都支持如下操作：</p><ul><li>begin - 获取第一个元素的迭代器，加 * 号获取其值</li><li>end - 获取最后一个元素的迭代器，加 * 号获取其值</li></ul><p>容器之间如何选择：</p><ul><li>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</li><li>如果你需要大量的插入和删除，而不关心随即存取，则应使用list</li><li>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</li><li>在搞不清状态时，通常vector是最佳选择。</li></ul></blockquote><h3 id="2-容器的遍历"><a href="#2-容器的遍历" class="headerlink" title="2. 容器的遍历"></a>2. 容器的遍历</h3><h4 id="通过下标"><a href="#通过下标" class="headerlink" title="通过下标"></a>通过下标</h4><pre><code class="c++">for(int n = 0; n &lt; vec.size(); n++)</code></pre><h4 id="通过迭代器"><a href="#通过迭代器" class="headerlink" title="通过迭代器"></a>通过迭代器</h4><pre><code class="c++">for(auto it = vec.begin(); it != s.end(); it++)// 如果你想逆向遍历for(auto it = vec.rbegin(); it != s.rend(); it++)// 求两个迭代器之间的距离distance(first, last);//返回last - first的距离      </code></pre><h4 id="std-for-each"><a href="#std-for-each" class="headerlink" title="std::for_each"></a>std::for_each</h4><pre><code class="c++">// func 在这可以用 Lambdastd::for_each(vec.begin(), vec.end(), func);</code></pre><h4 id="each"><a href="#each" class="headerlink" title="each"></a>each</h4><pre><code class="c++">for each(auto item in vec)</code></pre><h4 id="C-11-最新的写法"><a href="#C-11-最新的写法" class="headerlink" title="C++11 最新的写法"></a>C++11 最新的写法</h4><pre><code class="c++">for(auto item : vec)  </code></pre><h1 id="二、STL"><a href="#二、STL" class="headerlink" title="二、STL"></a>二、STL</h1><h3 id="1-STL-常用函数"><a href="#1-STL-常用函数" class="headerlink" title="1. STL 常用函数"></a>1. STL 常用函数</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>count</td><td>返回某个元素的个数——还有 count_if</td></tr><tr><td>find</td><td>查找某个元素的位置，返回迭代器——还有 find_if</td></tr><tr><td>search</td><td>从左向右查找符合的子串位置，返回迭代器</td></tr><tr><td>find_end</td><td>从右向左查找符合的子串位置，返回迭代器</td></tr><tr><td>fill</td><td>给一个范围的元素赋予给定值</td></tr><tr><td>remove</td><td>删除一个范围中等价于给定值得元素</td></tr><tr><td>reverse</td><td>反转一个容器的元素</td></tr><tr><td>swap</td><td>交换两个元素的位置</td></tr><tr><td>unique</td><td>删除容器中的重复元素</td></tr><tr><td>sort</td><td>升序排序一个范围的元素</td></tr><tr><td>sort-降序</td><td>sort(begin,end,greater\<data-type>())     less是升序</data-type></td></tr><tr><td>stable_sort</td><td>稳定排序</td></tr><tr><td>includes</td><td>输入需排好序，判断一个集合是否是另一个集合的子集，返回 bool</td></tr><tr><td>binary_search</td><td>二分查找判断是否存在给定元素</td></tr><tr><td>max</td><td>返回两个值中的最大值</td></tr><tr><td>max_element</td><td>返回容器中的最大值</td></tr><tr><td>min</td><td>返回两个值中的最小值</td></tr><tr><td>min_element</td><td>返回容器中的最小值</td></tr><tr><td>accumulate</td><td>累加范围内的元素，第三个参数为初值</td></tr><tr><td>rotate</td><td>旋转元素，就是头部按顺序放到尾部，尾部按顺序放到头部</td></tr><tr><td>next_permutation</td><td>传入前最后先排序，不然返回的只是从输入串开始的排列，下一个全排列，最大排列，返回false，反之返回true</td></tr><tr><td>prev_permutation</td><td>传入前最后先排序，不然返回的只是从输入串开始的排列，上一个全排列，最小排列，返回false，反之返回true</td></tr><tr><td>lower_bound</td><td>传入前要先排序， 返回第一个大于等于给定值的元素的迭代器，如果没有则返回最后一个元素之后的位置</td></tr><tr><td>upper_bound</td><td>传入前要先排序， 返回第一个大于给定值的元素的迭代器，如果没有则返回最后一个元素之后的位置</td></tr><tr><td>partition</td><td>按照比较函数将元素分别置于容器两端，返回第二个序列开始的一个元素的迭代器， stable_partition 是稳定划分</td></tr></tbody></table><pre><code class="c++">// 在普通数组中使用 sortsort(&amp;arr[i], &amp;arr[j]);sort(arr, arr + n);        // 另外注意这里的范围写法，在迭代器慢的时候可以这么写// 全排列while (next_permutation(str.begin(), str.end())){    cout &lt;&lt; str &lt;&lt; endl;}</code></pre><h3 id="2-更多参考-ClassFoo"><a href="#2-更多参考-ClassFoo" class="headerlink" title="2. 更多参考-ClassFoo"></a>2. <a href="http://classfoo.com/ccby/article/tZTzs#sec_17PStx" target="_blank" rel="noopener">更多参考-ClassFoo</a></h3><h1 id="三、更快"><a href="#三、更快" class="headerlink" title="三、更快"></a>三、更快</h1><h2 id="1-cin-的优化"><a href="#1-cin-的优化" class="headerlink" title="1. cin 的优化"></a>1. cin 的优化</h2><p><a href="https://liam0205.me/2016/11/19/the-speed-of-reading-files-in-Cpp/" target="_blank" rel="noopener">这篇博客以及他提到的几篇博客</a> 详细的解释了这个问题，总结如下：</p><pre><code class="c++">// 通过解除 cin 和 cout 的流绑定加速std::cin.tie(nullptr);// 通过解除 cin 和scanf 的流绑定加速std::ios::sync_with_stdio(false);// 通用的一个模板static const auto __ = [](){    ios::sync_with_stdio(false);    cin.tie(nullptr);    return nullptr;}();ios::sync_with_stdio(false);cin.tie(nullptr);</code></pre><h2 id="2-指针的指针"><a href="#2-指针的指针" class="headerlink" title="2. 指针的指针"></a>2. 指针的指针</h2><p>通过双重指针可以修改原指针的值，但是通过单指针却不可以：</p><pre><code class="c++">int a = 3;int b = 4;int* c = &amp;a;int* x = c;        // 指针int** y = &amp;c;    // 指针的指针x = &amp;b;   cout &lt;&lt; *c; // 结果为 3*y = &amp;b;  cout &lt;&lt; *c; // 结果为 4    </code></pre><p>如果看不懂的话，看下面这个就知道什么意思了：</p><pre><code class="c++">int a = 3;int b = 4;int c = a;int* d = &amp;a;c = b;   cout &lt;&lt; a; // 结果为 3d = &amp;b;  cout &lt;&lt; a; // 结果为 4</code></pre><blockquote><p>把一个指针的值赋给另一个指针，然后修改指针</p><p>====== 等价于 ======</p><p>把 a 变量的值赋给 c，然后修改 c 的值</p><p>把一个指针的地址值赋给一个指针的指针，然后修改指针的指针</p><p>====== 等价于 ======</p><p>把 a 变量的地址赋给一个指针 c，然后修改 c 的值</p></blockquote><h1 id="四、一些注意"><a href="#四、一些注意" class="headerlink" title="四、一些注意"></a>四、一些注意</h1><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h2><p>LeetCode 上链表的题大部分所给的样例都是不带头结点的链表。</p><pre><code class="c++">// 数据结构struct ListNode {    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) {}};// 不带头结点的空单链表，该怎么表示？head 为头结点指针head == NULL;</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快查-C++</title>
      <link href="/2018/04/09/%E5%BF%AB%E6%9F%A5-CXX/"/>
      <url>/2018/04/09/%E5%BF%AB%E6%9F%A5-CXX/</url>
      <content type="html"><![CDATA[<p>为了刷题。</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;    return 0;}</code></pre><h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><p>支持面向对象开发的四大特性：封装、抽象、继承、多态。</p><h2 id="1-标准库"><a href="#1-标准库" class="headerlink" title="1. 标准库"></a>1. 标准库</h2><ul><li>C++ 标准库：提供大量常用函数</li><li>标准模板库（STL）：提供大量方法，用于操作数据结构</li></ul><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>仅列出比 C 语言多的。</p><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>布尔型</td><td>bool</td></tr><tr><td>宽字符型</td><td>wchar_t（2~4字节）</td></tr><tr><td>字符串型</td><td>string（#include \&lt;string>）</td></tr></tbody></table><blockquote><p>wechar_t 是为了国际化，因为 char 的长度只有 1 字节，存储汉字等字符时会乱码。</p></blockquote><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>C++ 新增的更便于操作的字符串类型。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main (){   string str1 = &quot;Hello&quot;;   string str2 = &quot;World&quot;;   string str3;   string name[5];     // 一个容量为 5 的字符串数组   int  len ;   // 复制 str1 到 str3   str3 = str1;   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;   // 连接 str1 和 str2   str3 = str1 + str2;   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;   // 连接后，str3 的总长度   len = str3.size();    // str3.length() 一样的效果   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;    // 10   // 可通过下标的方式及其简单的遍历   for (int i = 0;i &lt; len; i++) cout &lt;&lt; str3[i] &lt;&lt; endl;   return 0;}</code></pre><blockquote><p>通过此例可以看出，C++ 下的 string 数据类型出奇的方便：</p><ul><li>用 = 赋值</li><li>用 + 连接</li><li>用 size() / length() 求长度，C++ 中的 string 不会包含 ‘\0’</li><li>可通过下标的方式及其简单的遍历</li></ul></blockquote><p>string 类型还提供很多针对字符串的操作</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){    // 定义一个string类对象，下面都是假设 http 每一次操作后又恢复原状    string http = &quot;blog.yfree.cc&quot;;       // 打印字符串长度       cout&lt;&lt;http.length()&lt;&lt;endl;    // 拼接    http.append(&quot;/C++&quot;);    // blog.yfree.cc/C++    // 插入    http.insert(2，&quot;--&quot;); // bl--og.yfree.cc     // 删除字符    cout &lt;&lt; http.erase (2, 3); &lt;&lt; endl;  // 删除从位置 2 开始的 3 个字符 blyfree.cc      // 替换    http.replace(0,4,&quot;md&quot;);        // 位置，长度，要替换的串 md.yfree.cc    // 删除最后一个字符    http.pop_back();        // blog.yfree.c    // 查找，返回第一次找到的位置    http.find(&quot;blog&quot;, 0);     // 第二个参数可以省略，默认为 0，也可以字符 &#39;b&#39;    // 查找，返回最后一次找到的位置    http.rfind(&quot;blog&quot;, 0);    // 其他查找    find_first_of(&quot;.&quot;);        //从头开始寻找字符&#39;.&#39;的位置    find_last_of(&quot;.&quot;);        //从尾开始寻找字符&#39;.&#39;的位置    find_first_not_of(&quot;.&quot;);    // 从头开始找不是字符&#39;.&#39;的位置    find_last_not_of(&quot;.&quot;);  // 从尾开始找不是字符&#39;.&#39;的位置    // 找子串 yfree    int first = http.find_first_of(&quot;.&quot;);     int last = http.find_last_of(&quot;.&quot;);     // 子串截取    cout&lt;&lt;http.substr(first+1, last-first-1)&lt;&lt;endl; //提取&quot;yfree&quot;子串并打印    // 比较字符串    string str1=&quot;hi,test,hello&quot;;      string str2=&quot;hi,test&quot;;    // 第一种方式    if(str1.compare(str2)&gt;0)          printf(&quot;str1&gt;str2\n&quot;);      else if(str1.compare(str2)&lt;0)          printf(&quot;str1&lt;str2\n&quot;);      else          printf(&quot;str1==str2\n&quot;);      // str1的子串（从索引3开始，包含4个字符）与str2进行比较      if(str1.compare(3,4,str2)==0)          printf(&quot;str1的指定子串等于str2\n&quot;);      else          printf(&quot;str1的指定子串不等于str2\n&quot;);      // str1指定子串与str2的指定子串进行比较      if(str1.compare(3,4,str2,3,4)==0)          printf(&quot;str1的指定子串等于str2的指定子串\n&quot;);      else          printf(&quot;str1的指定子串不等于str2的指定子串\n&quot;);      // str1指定子串与字符串的前n个字符进行比较      if(str1.compare(0,2,&quot;hi,hello&quot;,2)==0)          printf(&quot;str1的指定子串等于指定字符串的前2个字符组成的子串\n&quot;);      else          printf(&quot;str1的指定子串不等于指定字符串的前2个字符组成的子串\n&quot;);      // 类型转换    std::stoi                // 将字符串转化成带符号（Signed）整数    std::stol             // 将字符串转化成带符号整数    std::stoll             // 将字符串转化成带符号整数    std::stoul             // 将字符串转化成无符号（Unsigned）整数    std::stoull         // 将字符串转化成无符号整数    std::stof             // 将字符串转化成浮点数    std::stod             // 将字符串转化成浮点数    std::stold             // 将字符串转化成浮点数    std::to_string         // 将一个整数或浮点数转化成字符串    std::to_wstring     // 将一个整数或浮点数转化成宽字符串    return 0;}</code></pre><blockquote><ul><li>append() – 在字符串的末尾添加字符</li><li>insert() – 插入字符</li><li>erase() – 删除</li><li>replace() – 替换字符串</li><li>find() – 在字符串中查找字符串</li><li>substr() – 返回某个子字符串</li><li>compare() – 比较</li></ul><ul><li>empty() – 检验是否为空 – 返回 0 / 1 </li><li>pop_back() – 删除最后一个字符</li><li>back() – 返回最后一个元素 – front() – 返回第一个元素</li></ul></blockquote><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><pre><code class="c++">struct ListNode {  int val;  ListNode *next;  ListNode(int x) : val(x), next(NULL) {}    // 这是结构体的构造函数};</code></pre><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>C++11 中的标准，代表空指针，所以后表示空指针就不要使用 NULL 了，因为 NULL 会被编译器翻译成 0。</p><h2 id="3-输入-amp-输出"><a href="#3-输入-amp-输出" class="headerlink" title="3. 输入 &amp; 输出"></a>3. 输入 &amp; 输出</h2><h3 id="cin-和-cout"><a href="#cin-和-cout" class="headerlink" title="cin 和 cout"></a>cin 和 cout</h3><pre><code class="c++">// 输入cin &gt;&gt; a;// 输出cout &lt;&lt; &quot;我的名字是&quot; &lt;&lt; &quot;Arony&quot; &lt;&lt; endl;  // &lt;&lt; 用于向屏幕打印多个值，加上 endl 表示换行</code></pre><blockquote><p>\n 和 endl 的区别: <code>std::endl</code> 不仅换行还会立即刷新缓冲区。</p></blockquote><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h2><p>相当于别名，和指针很相似，但是也有不同之处。</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><pre><code class="c++">// 创建引用int i = 17;int&amp; r = i;void swap(int&amp; x, int&amp; y)； // 把引用当做参数int&amp; func(int x) {   int arr[2] = {0,1};   return arr[x];     // 返回 arr[x] 的引用}    </code></pre><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h2><p>与C语言的不同之处：</p><h3 id="支持设置默认参数"><a href="#支持设置默认参数" class="headerlink" title="支持设置默认参数"></a>支持设置默认参数</h3><pre><code class="c++">int sum(int a, int b=20){  int result;  result = a + b;  return (result);}</code></pre><h3 id="Lambada-函数"><a href="#Lambada-函数" class="headerlink" title="Lambada 函数"></a>Lambada 函数</h3><p>匿名函数，也叫 Lambada 表达式，可以像对象一样使用，可以赋给变量和作为参数传递。</p><pre><code class="c++">[capture](parameters) mutable -&gt;return-type{body}    // mutable 取消传入捕获的常量性// 典型样例[](int x, int y){ return x &lt; y ; }// 没有返回值的样例[]{ ++global_x; } // 明确指定返回类型[](int x, int y) -&gt; int { int z = x + y; return z + x; }// 最简单的 lambda 函数， parameters 和 返回值 在没有填入时可以连同符号一起省略[]{};// auto 可以在这这么用auto closure = [](const int&amp;, const int&amp;) {}</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>可以在 Lambda 表达式中访问当前作用域的变量，这是 Lambda 表达式的闭包行为。在 C++ 中，变量的有传值和传引用的区别，可以通过前面的 [] 来指定：</p><pre><code class="c++">[]      // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。// this 指针显式传入[this]() { this-&gt;someFunc(); }();// this 使用样例void hello() {    cout &lt;&lt; &quot;test hello!&quot;;};auto fun = [this]{ // 捕获了 this 指针    this-&gt;hello(); // 这里 this 调用的就是 class test 的对象了};fun();</code></pre><h2 id="6-类-amp-面向对象"><a href="#6-类-amp-面向对象" class="headerlink" title="6. 类 &amp; 面向对象"></a>6. 类 &amp; 面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code class="c++">void set(int n, int m){    ;}class Box{    public:      double length;   // 盒子的长度      double breadth;  // 盒子的宽度      double height;   // 盒子的高度    // 成员函数的定义    double getVolume(void)    {      return length * breadth * height;    }    // 在类的内部先声明，然后在外部利用 :: 定义    void setLength( double len );};// 使用 :: 在类的外部定义成员函数double Box::getVolume(void){    ::set(n, m);     // 直接用 :: 表示调用全局函数或数据    return length * breadth * height;}Box box1;Box box2；box1.length = 10.1；</code></pre><blockquote><p>类和结构体的区别：</p><ul><li>class中默认的成员访问权限是private的，而struct中则是public的。　　</li><li>从class继承默认是private继承，而从struct继承默认是public继承。</li></ul></blockquote><blockquote><p>:: 可以不跟类名，表示全局数据或全局函数（即非成员函数）。</p></blockquote><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><pre><code class="c++">class Line{   public:      void setLength( double len );      double getLength( void );      Line();   // 这是构造函数声明      ~Line();  // 这是析构函数声明   private:      double length;};// 成员函数定义，包括构造函数Line::Line(void){    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;}Line::~Line(void){    cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;}</code></pre><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>类的对象需要拷贝时，拷贝构造函数将被调用。如以下三种情况：</p><ul><li>一个对象以值传递的方式传入函数体</li><li>一个对象以值传递的方式从函数返回</li><li>一个对象需要通过另外一个对象进行初始化</li></ul><pre><code class="c++">A x(2);　　//直接初始化，调用构造函数A y = x;　　//拷贝初始化，调用拷贝构造函数</code></pre><pre><code class="c++">class Line{   public:      int getLength( void );      Line( int len );             // 简单的构造函数      Line( const Line &amp;obj);      // 拷贝构造函数      ~Line();                     // 析构函数   private:      int *ptr;};// 成员函数定义，包括构造函数Line::Line(int len){    cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;    // 为指针分配内存    ptr = new int;    *ptr = len;}Line::Line(const Line &amp;obj){    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;    ptr = new int;    *ptr = *obj.ptr; // 拷贝值}Line::~Line(void){    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;    delete ptr;}</code></pre><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>声明在类的内部，但是定义在类的外部，有权调用类的 private 和 protected 成员。</p><pre><code class="c++">class Box {  public:    friend void printWidth( Box box );};// 请注意：printWidth() 不是任何类的成员函数void printWidth( Box box ) {   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;}</code></pre><blockquote><ol><li>用关键字 friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。</li><li>一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。</li><li>友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。</li><li>友元函数在调用上同一般函数一样，不必通过对对象进行引用。</li></ol></blockquote><h3 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h3><p>子类在 C++ 中叫做派生类</p><pre><code class="c++">// 基类class Shape {   public:      int width;      int height;};// 派生类class Rectangle: public Shape        // public 在这里表示继承类型{   public:      int getArea(){          return (width * height);       }};</code></pre><p><strong>继承类型：</strong></p><ul><li>公有继承（public）：当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li>保护继承（protected）： 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li>私有继承（private）：当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ul><blockquote><p>一般用 public 继承类型，其他两个比较少用到</p></blockquote><h3 id="多继承和虚继承"><a href="#多继承和虚继承" class="headerlink" title="多继承和虚继承"></a>多继承和虚继承</h3><pre><code class="c++">// 多继承class Rectangle: public Shape, public PaintCost {};// 虚继承class D{......};class B: public D{......};class A: public D{......};class C: public B, public A{.....};        // 这个会使 D 创建两个对象，要解决这个问题要用虚拟继承格式class D{......};class B: virtual public D{......};class A: virtual public D{......};class C: public B, public A{.....};</code></pre><h3 id="重载运算符和重载函数"><a href="#重载运算符和重载函数" class="headerlink" title="重载运算符和重载函数"></a>重载运算符和重载函数</h3><p>编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>比如很多语言定义好的函数，在输入参数不同时会有不同的效果。</p><pre><code class="c++">class printData {   public:      void print(int i) {        cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl;      }      void print(double  f) {        cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl;      }};int main(void){   printData pd;   // 输出整数   pd.print(5);   // 输出浮点数   pd.print(500.263);   return 0;}</code></pre><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>运算符的重载能够让你定义你自己的运算符计算，如把 + 重载一个适用于对象之间的 +。</p><pre><code class="c++">class Box{   public:      // 重载 + 运算符，用于把两个 Box 对象相加      Box operator+(const Box&amp; b)      {         Box box;         box.length = this-&gt;length + b.length;         box.breadth = this-&gt;breadth + b.breadth;         box.height = this-&gt;height + b.height;         return box;      }};// 程序的主函数int main( ){   Box Box1;                // 声明 Box1，类型为 Box   Box Box2;                // 声明 Box2，类型为 Box   Box Box3;                // 声明 Box3，类型为 Box   // 把两个对象相加，得到 Box3   Box3 = Box1 + Box2;}</code></pre><blockquote><p>还有很多其他运算符的样例，看<a href="http://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="noopener">这里</a></p></blockquote><h2 id="7-多态"><a href="#7-多态" class="headerlink" title="7. 多态"></a>7. 多态</h2><p>调用成员函数时，根据调用函数的对象的类型来执行不同的函数。多态需要结合<strong>虚函数</strong>才能正常使用。<strong>动态链接</strong></p><pre><code class="c++">class Shape {   protected:      int width, height;   public:      Shape( int a=0, int b=0) {         width = a;         height = b;      }      virtual int area() {                       // 需要加上虚函数的声明         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;         return 0;      }};class Rectangle: public Shape{   public:      Rectangle( int a=0, int b=0):Shape(a, b) { }        // 继承基类的构造函数并传入默认值      virtual int area () {          cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;         return (width * height);       }};class Triangle: public Shape{   public:      Triangle( int a=0, int b=0):Shape(a, b) { }      virtual int area () {          cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;         return (width * height / 2);       }};// 程序的主函数int main( ) {   Shape *shape;   Rectangle rec(10,7);   Triangle  tri(10,5);   // 存储矩形的地址   shape = &amp;rec;   // 调用矩形的求面积函数 area   shape-&gt;area();   // 存储三角形的地址   shape = &amp;tri;   // 调用三角形的求面积函数 area   shape-&gt;area();   return 0;}</code></pre><blockquote><p>形成多态必须具备的三个条件：</p><ol><li>必须存在继承关系；</li><li>继承关系必须有同名虚函数（<strong>其中虚函数是在基类中使用关键字Virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数</strong>）；</li><li>存在基类类型的指针或者引用，通过该指针或引用调用虚函数；</li></ol></blockquote><h2 id="8-抽象和接口"><a href="#8-抽象和接口" class="headerlink" title="8. 抽象和接口"></a>8. 抽象和接口</h2><p>C++ 中抽象和接口通过<strong>纯虚函数</strong>来实现。带有纯虚函数的类为<strong>抽象类</strong>，无法实例化，只有实现了这个纯虚函数的子类才能实例化。纯虚函数只提供声明，是对子类的约束。</p><pre><code class="c++">class Shape {   protected:      int width, height;   public:      Shape( int a=0, int b=0)      {         width = a;         height = b;      }      // 以下是一个纯虚函数      virtual int area() = 0;};</code></pre><h2 id="9-STL"><a href="#9-STL" class="headerlink" title="9. STL"></a>9. STL</h2><p>可以快速随机访问的，修改慢。可以快速随机修改的，随机访问慢。这是和数据结构相对应的。</p><p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类。</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>容器（Containers）</td><td>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td>算法（Algorithms）</td><td>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td>迭代器（iterators）</td><td>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td></tr></tbody></table><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array-数组"></a>Array-数组</h3><pre><code>array&lt;int,3&gt; = {0,1,2};</code></pre><h3 id="Vector-向量"><a href="#Vector-向量" class="headerlink" title="Vector-向量"></a>Vector-向量</h3><ul><li>快速的随机访问</li><li>快速的尾部增删</li><li>按需修改大小</li></ul><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;                            // 头文件using namespace std;int main(){   // 创建一个向量存储 int   vector&lt;int&gt; vec;    int i;   // 显示 vec 的原始大小   cout &lt;&lt; &quot;vector size = &quot; &lt;&lt; vec.size() &lt;&lt; endl;   // 推入 5 个值到向量中，注意无法通过下标的方式添加元素！！！！   for(i = 0; i &lt; 5; i++){      vec.push_back(i);   }  // 一种读入一组数字的方法  int tem;  while(cin&gt;&gt;tem){      if(cin.get() != &#39;\n&#39;) vec.push_back(tem);      else {          vec.push_back(tem);          break;      };  }   // 访问向量中的 5 个值   for(i = 0; i &lt; 5; i++){      cout &lt;&lt; &quot;value of vec [&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; vec[i] &lt;&lt; endl;   }   // 使用迭代器 iterator 访问值   vector&lt;int&gt;::iterator v = vec.begin();   while( v != vec.end()) {      cout &lt;&lt; &quot;value of v = &quot; &lt;&lt; *v &lt;&lt; endl;      v++;   }   return 0;}</code></pre><blockquote><ul><li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li><li>pop_back() 删除最后一个元素</li><li>size( ) 函数显示向量的大小。</li><li>begin( ) 函数返回一个指向向量开头的迭代器。</li><li>end( ) 函数返回一个指向向量末尾的迭代器。</li></ul></blockquote><pre><code class="C++">vector&lt;int&gt; v1(10);         // v1有10个元素，每个的值都是0vector&lt;int&gt; v2{10};         // v2有1个元素，该元素的值是10vector&lt;int&gt; v3(10,1);       // v3有10个元素，每个的值都是1vector&lt;int&gt; v4{10,1};       // v4有2个元素，值分别是10和1vector&lt;string&gt; v5{&quot;hi&quot;};    // v5有一个元素&quot;hi&quot;vector&lt;string&gt; v6(&quot;hi&quot;);    // 错误，不能用字符串字面值构建vector对象vector&lt;string&gt; v7{10};      // v7有10个默认初始化的元素vector&lt;string&gt; v8{10,&quot;hi&quot;}; // v8有10个值为&quot;hi&quot;的元素</code></pre><h3 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque-双端队列"></a>Deque-双端队列</h3><p>两段都可以插入删除的队列，可通过下标访问。</p><ul><li>快速的随机访问</li><li>快速的双端操作</li><li>按需修改大小</li></ul><pre><code class="c++">deque&lt;int&gt; d;deque&lt;int&gt;::iterator d;push_back;push_front;pop_back;pop_front;</code></pre><h3 id="List-双向链表"><a href="#List-双向链表" class="headerlink" title="List-双向链表"></a>List-双向链表</h3><p>可以双向操作的链表，不支持随机访问（下标访问）。</p><ul><li>快速的随机插入和删除</li><li>按需修改大小</li></ul><pre><code class="c++">list&lt;int&gt; l;list&lt;int&gt;::iterator l;splice        // 使元素从一个列表移动到另一个列表remove         // 删除值为指定值的元素remove_if    // 删除满足指定条件的元素  foo.remove_if([](int n){ return n &gt; 10; }); unique         // 删除重复值merge         // 合并已排序的列表sort         // 为容器中的所有元素排序reverse         // 反转元素的顺序</code></pre><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set-集合"></a>Set-集合</h3><p>内部是红黑二叉树的实现，不能重复的有序容器，不支持随机访问（下标访问）。</p><ul><li>快速的随机插入和删除</li><li>自动排序</li></ul><pre><code class="c++">set&lt;int&gt; s;list&lt;int&gt;::iterator s;find    // 通过给定值查找元素count    // 返回匹配给定值的元素的个数</code></pre><h3 id="MultiSet-多键集合"><a href="#MultiSet-多键集合" class="headerlink" title="MultiSet-多键集合"></a>MultiSet-多键集合</h3><p>可以重复的 set。</p><h3 id="Map-映射表"><a href="#Map-映射表" class="headerlink" title="Map-映射表"></a>Map-映射表</h3><p>内部是 hash 实现，相当于其他语言中的键值数组，可通过 key 访问。</p><pre><code class="c++">map&lt;string, int&gt; m1; // &lt;&gt;里的第一个参数表示key的类型,第二个参数表示value的类型m1[&quot;Kobe&quot;] = 100;m1[&quot;James&quot;] = 99;m1[&quot;Curry&quot;] = 98;m1.insert(pair&lt;string, int&gt;(&quot;Harris&quot;, 89)); // 也可以通过insert函数来实现增加元素m1.erase(&quot;Curry&quot;); // 通过关键字来删除if(m1.count(&quot;Lee&quot;)){}  // 可以这样判断元素是否存在</code></pre><h3 id="MultiMap-多键映射"><a href="#MultiMap-多键映射" class="headerlink" title="MultiMap-多键映射"></a>MultiMap-多键映射</h3><p>键值关系是一对多的关系，不能通过 key 访问。</p><pre><code class="c++">multimap&lt;string, int&gt; m2;m2.insert(pair&lt;string, int&gt;(&quot;Harris&quot;, 89)); // 新增m2.find(&quot;Harris&quot;);  // 返回第一个m2.count(&quot;Harris&quot;); // 数有多少个指定 key 的元素lower_bound(k); // 查找第一个与键 k 关联的值upper_bound(k)：// 查找第一个键值比 k 大的元素</code></pre><h3 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack-栈"></a>Stack-栈</h3><p>先进后出。</p><pre><code class="c++">stack&lt;int&gt; s;</code></pre><table><thead><tr><th>函数名</th><th>功能</th><th>复杂度</th></tr></thead><tbody><tr><td>size()</td><td>返回栈的元素数</td><td>O(1)</td></tr><tr><td>top()</td><td>返回栈顶的元素</td><td>O(1)</td></tr><tr><td>pop()</td><td>从栈中取出并删除元素</td><td>O(1)</td></tr><tr><td>push(x)</td><td>向栈中添加元素x</td><td>O(1)</td></tr><tr><td>empty()</td><td>在栈为空时返回true</td><td>O(1)</td></tr></tbody></table><h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue-队列"></a>Queue-队列</h3><p>先进先出。</p><pre><code class="c++">queue&lt;int&gt; q;</code></pre><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>front()</td><td>返回第一个元素</td></tr><tr><td>back()</td><td>返回最后一个元素</td></tr><tr><td>empty()</td><td>为空是返回true</td></tr><tr><td>size()</td><td>返回有效元素个数</td></tr><tr><td>push()</td><td>压入一个元素</td></tr><tr><td>pop()</td><td>弹出一个元素</td></tr></tbody></table><h3 id="priority-queue-优先级队列"><a href="#priority-queue-优先级队列" class="headerlink" title="priority_queue-优先级队列"></a>priority_queue-优先级队列</h3><p>底层是用堆来实现的。其第一个元素总是容器所包含的元素中按特定的严格弱序排序规则排序后最大的一个。</p><pre><code class="c++">priority_queue&lt;int&gt; q;  // 这个和默认等价priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;  // 堆顶为最大元素priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q;     // 默认 - 堆顶为最大元素// 优先函数bool cmp(int a, int b) {    return a &gt; b;    // 符号右边的优先级高}</code></pre><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>top</td><td>访问堆顶元素</td></tr><tr><td>pop</td><td>移除堆顶元素</td></tr><tr><td>push</td><td>在顶部插入元素，插入后会自动排序</td></tr></tbody></table><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>大顶堆：</strong>根结点的值要大于左右孩子</p><p><strong>小顶堆：</strong>根结点的值要小于左右孩子</p><pre><code class="c++">vector&lt;int&gt; vec = {8,3,4,8,9,2,3,4};make_heap(vec.begin(), vec.end());    // 进行堆排序，默认为大顶堆make_heap(vec.begin(), vec.end(), greater&lt;int&gt; ());    // 进行堆排序，小顶堆// push_heap()，在已经构造好的堆结构中插入一个元素vec.push_back(56);                    // 首先压入堆数组的末尾push_heap(vec.begin(), vec.end());     // 进行一次排序调整// pop_heap()，在已经构造好的堆结构中弹出一个元素pop_heap(vec.begin(), vec.end());    // 实际上是把顶部元素放到了末尾vec.pop_back();                      // 到了这一步才是实际删除</code></pre><h3 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator-迭代器"></a>iterator-迭代器</h3><p>迭代器可以方便的遍历标准库中提供的各种容器</p><pre><code class="c++">for(auto it = s.begin(); it != s.end(); ++it) *it = toupper(*it); vector&lt;int&gt;::iterator it;           // it能读写vector&lt;int&gt;的元素string::iterator it2;               // it2能读写string对象中的字符vector&lt;int&gt;::const_iterator it3;    // it3只能读元素，不能写元素string::const_iterator it4;         // it4只能读字符，不能写字符</code></pre><p>auto 数据类型在这里达到很方便、简洁的书写效果。</p><pre><code class="c++">vector&lt;int&gt; v;vector&lt;int&gt;::interator iter = v.begin(); // 完整的写法auto I = v.begin();   // 使用 auto 的简便写法</code></pre><blockquote><p>begin() 和 end() 分别指向容器的首元素和尾元素</p><p>cbegin() 和 cend() 和上面类似，只是获取的只是可读</p><p>*iter   返回迭代器所指向的元素</p></blockquote><h3 id="10-正则"><a href="#10-正则" class="headerlink" title="10. 正则"></a>10. 正则</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><pre><code class="c++">#include &lt;regex&gt;</code></pre><h4 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h4><p>构建正则表达式对象，basic_regex 是一个用来构建正则表达式的通用类模板：</p><pre><code class="c++">regex re(&quot;(http[s]?)&quot;);               // 构建正则式对象</code></pre><table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td>regex re</td><td>产生空的正则式，可以匹配任何字符序列</td></tr><tr><td>regex re(str)</td><td>正则式为str，str可以为basic_string，也可以是0结尾的char*字符串。</td></tr><tr><td>regex re(re2)</td><td>拷贝构造。</td></tr><tr><td>regex re(str,flag)</td><td>正则式为str，使用flag语法选项，flag是一组常量的组合。例如：icase可以使正则式匹配忽略大小写。</td></tr><tr><td>regex re(beg,end)</td><td>使用迭代器构造正则式。可以是basic_string的迭代器，也可以是const char*。</td></tr><tr><td>regex re(beg,end,flag)</td><td>使用迭代器构造正则式，flag是语法选项。</td></tr></tbody></table><table><thead><tr><th>flag_type</th><th>效果</th></tr></thead><tbody><tr><td>icase</td><td>在匹配过程中忽略大小写</td></tr><tr><td>nosubs</td><td>不保存匹配的子表达式</td></tr><tr><td>optimize</td><td>执行速度优于构造速度</td></tr></tbody></table><h4 id="存储容器"><a href="#存储容器" class="headerlink" title="存储容器"></a>存储容器</h4><table><thead><tr><th>实现类</th><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td>sub_match</td><td>无</td><td>用来表示匹配的一个结果</td></tr><tr><td>match_results</td><td>smatch</td><td>用来表示一次搜索或匹配算法的所有结果，类似于vector \&lt;sub_match>，可以下标访问</td></tr></tbody></table><pre><code class="c++">smatch m;  // 存放匹配的字符串</code></pre><h4 id="匹配结果"><a href="#匹配结果" class="headerlink" title="匹配结果"></a>匹配结果</h4><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>regex_match</td><td>尝试将一个正则表达式匹配<strong>一整个</strong>字符序列</td></tr><tr><td>regex_search</td><td>尝试将一个正则表达式匹配字符序列的<strong>任意部份</strong></td></tr><tr><td>regex_replace</td><td>用格化式过的替换文本（Formatted replacement text）替换正则表达式所匹配的序列</td></tr></tbody></table><pre><code class="c++">#include &lt;iostream&gt;#include &lt;regex&gt;#include &lt;string&gt;int main(int argc, char* argv[]){    std::string str = &quot;Hello World!&quot;;    std::string str2 = &quot;My first program is Hello World! oh&quot;;    std::smatch match;          // match是regex正则表达式对象    std::regex re(&quot;(Hel)(.*)&quot;); // 匹配字符串以Hel开头，后可跟任意字符    // regex_match    if ( std::regex_match(str,re))        std::cout &lt;&lt; &quot;字符串(Hel)(.*) \n&quot;;    if ( std::regex_match(str.begin(), str.end(), re) )        std::cout &lt;&lt; &quot;字符串(Hel)(.*) \n&quot;;    // regex_search    std::regex_search(str2,match,re);    for (auto x : match)        std::cout &lt;&lt; x &lt;&lt; std::endl;    // regex_replace    std::string str3 = &quot;My first program is Hello World! oh yeah\n&quot;;    std::regex r(&quot;Hel[a-zA-z]+&quot;);    std::cout &lt;&lt; std::regex_replace(str, r, &quot;Fuck&quot;) &lt;&lt; std::endl;    return 0;}</code></pre><h2 id="11-不常用"><a href="#11-不常用" class="headerlink" title="*11. 不常用"></a>*11. 不常用</h2><h3 id="日期-amp-时间"><a href="#日期-amp-时间" class="headerlink" title="日期 &amp; 时间"></a>日期 &amp; 时间</h3><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><ul><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><h1 id="二、开发"><a href="#二、开发" class="headerlink" title="二、开发"></a>二、开发</h1><p>前面是刷题可能会用到的，后面试开发会用到的。</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><ul><li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li><li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>泛型编程</p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="Web编程"><a href="#Web编程" class="headerlink" title="Web编程"></a>Web编程</h2>]]></content>
      
      <categories>
          
          <category> 快查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快查-C语言</title>
      <link href="/2018/04/03/%E5%BF%AB%E6%9F%A5-C%E8%AF%AD%E8%A8%80/"/>
      <url>/2018/04/03/%E5%BF%AB%E6%9F%A5-C%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>平常除了刷题不常用 C ，为了方便能够快速拾起，整理了此文档，前面的仅是常用的部分，不常的内容会单独列出。</p><pre><code class="c">#include &lt;stdio.h&gt;int main(){    printf(&quot;Hello World!&quot;);}</code></pre><h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="数据类型、运算符"><a href="#数据类型、运算符" class="headerlink" title="数据类型、运算符"></a>数据类型、运算符</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><p><img src="快查-C语言.assets/timg.jpg" alt="C语言数据类型"></p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">所占字节数</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">short int</td><td style="text-align:center">2</td><td style="text-align:center">-32768~32767</td></tr><tr><td style="text-align:center">unsigned short inrt</td><td style="text-align:center">2</td><td style="text-align:center">0~65535</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">2/4/4（16/32/64）</td><td style="text-align:center">-21亿~21亿（4）</td></tr><tr><td style="text-align:center">long int</td><td style="text-align:center">2/4/4/8（16/32/64Win/64Unix）</td><td style="text-align:center">-21亿~21亿（4）</td></tr><tr><td style="text-align:center">long long int</td><td style="text-align:center">8/8（32/64）</td><td style="text-align:center">2^64^ 1844亿亿</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">long double</td><td style="text-align:center">8</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">sizeof</td><td style="text-align:center">计算字节数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指针</td><td style="text-align:center">4/8（32/64）</td></tr></tbody></table><blockquote><p>关于 int 和 long 的位数该怎么记：记为 2/4/8 即可，只有 win 的 long 为 4。</p></blockquote><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h3><p>仅记录位运算</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">&lt;&lt;  &gt;&gt;</td><td style="text-align:center">左移，右移</td><td style="text-align:center">左乘以2,，右除以2</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">按位与</td><td style="text-align:center">全1为1</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">按位异或</td><td style="text-align:center">相同为0，不同为1</td></tr><tr><td style="text-align:center">｜</td><td style="text-align:center">按位或</td><td style="text-align:center">存1为1</td></tr></tbody></table><h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h3><h4 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h4><pre><code class="c">#define PI 3.1415    // 没有数据类型</code></pre><h4 id="const-类型修饰符"><a href="#const-类型修饰符" class="headerlink" title="const 类型修饰符"></a>const 类型修饰符</h4><pre><code class="c">const float pi 3.1415    // 有数据类型</code></pre><h4 id="宏定义-define-和常量-const-的区别"><a href="#宏定义-define-和常量-const-的区别" class="headerlink" title="宏定义 #define 和常量 const 的区别"></a>宏定义 #define 和常量 const 的区别</h4><p><strong>类型和安全检查不同</strong></p><p>宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；</p><p>const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查</p><p><strong>编译器处理不同</strong></p><p>宏定义是一个”编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；</p><p>const常量是一个”运行时”概念，在程序运行使用，类似于一个只读行数据</p><p><strong>存储方式不同</strong></p><p>宏定义是直接替换，不会分配内存，存储与程序的代码段中；</p><p>const常量需要进行内存分配，存储与程序的数据段中</p><p><strong>定义域不同</strong></p><pre><code>void f1 (){    #define N 12    const int n 12;}void f2 (){    cout&lt;&lt;N &lt;&lt;endl; //正确，N已经定义过，不受定义域限制    cout&lt;&lt;n &lt;&lt;endl; //错误，n定义域只在f1函数中}</code></pre><p><strong>定义后能否取消</strong></p><p>宏定义可以通过#undef来使之前的宏定义失效</p><p>const常量定义后将在定义域内永久有效</p><pre><code>void f1(){  #define N 12  const int n = 12;  #undef N //取消宏定义后，即使在f1函数中，N也无效了  #define N 21//取消后可以重新定义}</code></pre><p><strong>是否可以做函数参数</strong></p><p>宏定义不能作为参数传递给函数</p><p>const常量可以在函数的参数列表中出现</p><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">‘\n’</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center">‘\r’</td><td style="text-align:center">回车但不换行</td></tr><tr><td style="text-align:center">‘\0’</td><td style="text-align:center">空字符，通常用做字符串结束标志</td></tr><tr><td style="text-align:center">‘\t’</td><td style="text-align:center">水平制表</td></tr><tr><td style="text-align:center">‘\”‘</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:center">‘\’’</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center">‘\?’</td><td style="text-align:center">问号</td></tr><tr><td style="text-align:center">‘\\’</td><td style="text-align:center">反斜线</td></tr></tbody></table><blockquote><p>双引号包起来的是字符串 (String)，单引号包起来的是字符常量 (char)</p></blockquote><p>###数组</p><pre><code class="c">int array[5];     // 容量为50的整型数组int array[5] = {0,1,2,3,4}；    // 容量为5的整型数组int array[] = {0,1,2,3,4}     // 容量为5的整型数组char str[6];        // 容量为5的字符数组，因为&#39;\0&#39;要占一个char str[6] = &quot;hello&quot;;    char str[] = &quot;hello&quot;;int array[10][20];        // 二维数组</code></pre><h2 id="输入-amp-输出"><a href="#输入-amp-输出" class="headerlink" title="输入 &amp; 输出"></a>输入 &amp; 输出</h2><p>更多格式化输入输出，可以参考<a href="http://c.biancheng.net/cpp/html/3100.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="1-输入"><a href="#1-输入" class="headerlink" title="1. 输入"></a>1. 输入</h3><p>####scanf</p><pre><code class="c">int a,b;char c;scanf(&quot;%2d%*2d%2d&quot;,a,b);    // 输入“123456”，“12” 会赋给 a，“56” 会赋给 b</code></pre><table><thead><tr><th style="text-align:center">格式转化符</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">%d 或 %i</td><td style="text-align:center">十进制整数</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%%</td><td style="text-align:center">百分号%</td></tr></tbody></table><h4 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h4><pre><code class="c">char a[10];  gets(a);puts(a);</code></pre><h4 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h4><pre><code class="c">char a;a = getchar();putchar(a);</code></pre><h3 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h3><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><pre><code class="c">char s[]=&quot;小明&quot;;  int n = 100;char c = &#39;A&#39;;printf(&quot;%s得了%3.1d分，评了%c\n&quot;, s,n,c);    // 小明得了100.0分，评了A</code></pre><table><thead><tr><th style="text-align:center">格式转换符</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">%d 或 %i</td><td style="text-align:center">带符号的十进制整数</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">无符号的十进制整数</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">浮点</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">科学计数法</td></tr><tr><td style="text-align:center">%g</td><td style="text-align:center">自动选取 %f 和 %e 中合适的</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:center">printf(“%p”,&amp;i);  输出地址或指针</td></tr><tr><td style="text-align:center">%%</td><td style="text-align:center">百分号%</td></tr><tr><td style="text-align:center">%m.n</td><td style="text-align:center">%3.2d 表示 3 位整数，2 位小数，m 超过整数位时在前面补空格</td></tr></tbody></table><h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><pre><code class="c">char a[10];  gets(a);puts(a);    // puts(a);</code></pre><h4 id="putchar"><a href="#putchar" class="headerlink" title="putchar"></a>putchar</h4><pre><code class="c">char a = &#39;a&#39;;putchar(a);</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="1-函数的声明"><a href="#1-函数的声明" class="headerlink" title="1. 函数的声明"></a>1. 函数的声明</h3><pre><code class="c">// 函数：求和int sum(int x, int y){    return x + y;}// 函数的声明int sum(int x, int y);// 函数声明中，参数名并不是必要的，只有参数类型是必要的，所以也可以用下面的写法int sum(int, int);    // 但是如果是指针不能这么写</code></pre><blockquote><p>C语言中，函数必须写在 main() 函数前面才能被调用。或者先把函数声明写在前面，然后在 main() 函数后面再补写完整函数。</p></blockquote><h3 id="2-函数的传参"><a href="#2-函数的传参" class="headerlink" title="2. 函数的传参"></a>2. 函数的传参</h3><h4 id="传值调用"><a href="#传值调用" class="headerlink" title="传值调用"></a>传值调用</h4><p>把参数复制一份传入，不会影响实际的参数。</p><pre><code class="c">// 传数组作为函数参数int getAverage(int param[10]){}int getAverage(int param[]){}int balance[5] = {1,2,3,4,5};int avg = getAverage(balance) ;// 传二维数组给函数double MatrixMultiple(double a[][], double b[][]);      /* 这会报错 */double MatrixMultiple(double a[][2], double b[][3]);  /* 这才是正确的 */</code></pre><h4 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h4><p>通过指针传递，对其操作相当于对实参本身进行操作。</p><pre><code class="c">// 函数1int sum(int *arr){}// 函数2：交换 x 和 y 的值void swap(int *x, int *y){    *x = *x + *y;    *y = *x - *y;    *x = *x - *y;}int main() {    int a = 13;    int b = 2;    swap(&amp;a, &amp;b);    // 函数 2 的使用    printf(&quot;%d-%d&quot;, *x, *y) ;    return 0;}</code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="1-指针的理解"><a href="#1-指针的理解" class="headerlink" title="1. 指针的理解"></a>1. 指针的理解</h3><p>使用连字号（&amp;）运算符可以访问变量的内存地址。</p><pre><code class="c">int  var1;char var2[10];printf(&quot;var1 变量的地址： %p\n&quot;, &amp;var1);  // var1 变量的地址： 0x7fff5cc109d4printf(&quot;var2 变量的地址： %p\n&quot;, &amp;var2);  // var2 变量的地址： 0x7fff5cc109de ，不加 &amp; 也可以</code></pre><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</p><pre><code class="c">int *p;  // 指针的声明char *a = &quot;hello&quot;; // 声明一个指向字符串的指针// 如果这么写，更好理解指针int a = 3;int* p = &amp;a;</code></pre><p>所有指针的值的实际数据类型都是一样的，都是一个代表内存地址的长的十六进制数。</p><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>为没有确切地址的指针，赋一个 NULL 值是良好的习惯。</p><pre><code class="c">int  *ptr = NULL;printf(&quot;%p\n&quot;, ptr);  // 0</code></pre><h3 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2. 指针的使用"></a>2. 指针的使用</h3><p>使用（<em>）号可以访问指针变量值所指的变量。==要充分理解，指针变量 ip 只是一个地址，\</em>ip 才是指向其变量值。==</p><pre><code class="c">int  var = 20;   /* 实际变量的声明 */int  *ip;        /* 指针变量的声明 */ip = &amp;var;  /* 在指针变量中存储 var 的地址 */printf(&quot;%p\n&quot;, &amp;var  );        // 0x7fff5cc109d4printf(&quot;%p\n&quot;, ip );        // 0x7fff5cc109d4/* 使用指针访问值 */printf(&quot;%d\n&quot;, *ip );  // 20</code></pre><p>指针的自增和自减。</p><pre><code class="c">// 利用指针的自增遍历数组int  var[] = {10, 100, 200};int  i, *ptr, MAX=3;ptr = var;                        // 数组的形参代表了该数组在内存中的第一个地址for ( i = 0; i &lt; MAX; i++){  // handle  ptr++;}// 利用指针的自减遍历数组int  var[] = {10, 100, 200};int  i, *ptr, MAX=3;ptr = &amp;var[MAX-1];for ( i = 0; i &lt; MAX; i++){  // handle  ptr--;}</code></pre><p>指针的比较。</p><pre><code class="c">// 利用指针的比较遍历数组int  var[] = {10, 100, 200};int  i*ptr, MAX=3;ptr = var;while (ptr &lt;= &amp;var[MAX-1]){  // handle  ptr++;}</code></pre><p>利用指针从函数返回数组。</p><p>C 语言不允许函数返回一个完整的数组，但是指针可以完成这一操作。</p><pre><code class="c">// 返回一个数组int *getArray(){    static int a[] = {1,2,3,4};        // 如果是返回函数内部的局部变量到外部最好用上 static    return a;}int main() {    int *p;    p = getArray();    printf(&quot;%d-%d-%d-%d&quot;,p[0],p[1],p[2],p[3]);    return 0;}</code></pre><blockquote><p>在C语言中，static关键字有三种用途：</p><ol><li><p>用于全局变量定义时。</p><p>全局变量定义时加上static修饰，表示该变量为静态全局变量。作用域为当前文件。</p></li><li><p>用于函数定义或声明。</p><p>任意函数的定义或声明中包含了static修饰，表示该函数为静态函数，只能在本文件中被调用。</p></li><li><p>用于局部变量定义。</p><p>局部变量定义时，带有static关键字，表示其为静态局部变量，只被初始化一次，之后每次调用函数时，该变量值为上次函数退出时的值。即，改变量的生存周期被扩展到整个程序运行时间段内。</p></li></ol><p>static 关键字修饰的变量只有一次能被初始化，即时在此调用这个函数，也不会再被初始化。</p></blockquote><h3 id="3-复杂指针"><a href="#3-复杂指针" class="headerlink" title="3. 复杂指针"></a>3. 复杂指针</h3><h4 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h4><pre><code class="c">double *p;double balance[10];p = balance;        // 数组的形参指向数组的第一个元素的地址double a = *(balance + 4);  // 这样可以访问数组的第五个元素，即 balance[4]int array[3][4];int *pa = array;array[0] == *pa          // truearray[1] == *pa + 1        // true    array[0] == &amp;a[0][0]    // true    array[0]+1 == &amp;a[0][1]    // true    int (*p)[4];    // 定义一个指向一维4元数组的指针</code></pre><h4 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><p>函数在 C 语言中也会占据一片内存地址，而这内存地址有一个起始地址，称为函数的入口地址，即函数的指针，和数组类似，函数的入口地址是用函数名表示的。</p><pre><code class="c">int add(int x, int y);int main(){    int a[] = {1,2,2,3};    int (*pt)(int b[], int n);      // 声明一个指向函数的指针    pt = add;                    // 让指针指向函数的入口地址    int total = (*pt)(a, 6)         // 利用指针来调用函数    return 0;}</code></pre><h4 id="由指针组成的数组"><a href="#由指针组成的数组" class="headerlink" title="由指针组成的数组"></a>由指针组成的数组</h4><pre><code class="c">int *p[4];    // 定义一个可以存储四个指针元的数组</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code class="c">// 指向数组的指针int (*p)[3];// 指向函数的指针 int (*p)(int);// 由指针组成的数组int *p[4];// 指针的指针int **p;// 以下两种其实是一样的int* n；int *n;</code></pre><h2 id="结构体-amp-共用体"><a href="#结构体-amp-共用体" class="headerlink" title="结构体 &amp; 共用体"></a>结构体 &amp; 共用体</h2><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1. 结构体"></a>1. 结构体</h3><p>结构体的声明，调用，指向结构体的指针。所占用的内存空间是各成员所占的长度之和。</p><pre><code class="c">struct Books{   char  title[50];   char  author[50];   char  subject[100];   int   book_id;} book;                    // 在定义的同时声明几个这样的变量void printBook( struct Books book );  // 函数声明int main(){    struct Books book1;        // 像平常变量一样声明    book1.book_id = 6495407; // 使用 . 访问    printBook(book1);    struct Books *struct_pointer;    // 声明    struct_pointer = &amp;book1；       // 赋值    struct_pointer-&gt;title;            // 通过指针访问的方式    return 0；}</code></pre><blockquote><p>值得注意的是：使用 . 或 -&gt; 运算符时，前者的前缀是结构体变量，而后者要是结构体指针</p></blockquote><h3 id="2-共用体"><a href="#2-共用体" class="headerlink" title="2. 共用体"></a>2. 共用体</h3><p>一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。为了节省内存，比如一个共用体，里面定义了老师和学生，但这两者不会同时用到。</p><pre><code class="c">// 共用体所占用的内存应足够存储共用体中最大的成员，如下面的例子是20字节。union Data{   int i;   float f;   char  str[20];} data,class[5];    // 同时定义一个结构体数组，可以去掉 5 ，但同时需要赋初始值// 在下面的例子中，前两个变量的值会被最后的字符串损坏。int main(){    union Data data;       data.i = 10;    data.f = 220.5;       strcpy( data.str, &quot;C Programming&quot;);    return 0;}</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="1-字符串操作"><a href="#1-字符串操作" class="headerlink" title="1. 字符串操作"></a>1. 字符串操作</h3><pre><code class="c">#include &lt;string.h&gt;</code></pre><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">strcpy(s1, s2);</td><td style="text-align:center">复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:center">strcat(s1, s2);</td><td style="text-align:center">连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td style="text-align:center">strlen(s1);</td><td style="text-align:center">返回字符串 s1 的长度。</td></tr><tr><td style="text-align:center">strcmp(s1, s2);</td><td style="text-align:center">如果 s1 和 s2 是相同的，则返回 0；<br>如果 s1\&lt;s2 则返回小于 0；<br>如果 s1>s2 则返回大于 0。</td></tr><tr><td style="text-align:center">strchr(s1, ch);</td><td style="text-align:center">返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:center">strstr(s1, s2);</td><td style="text-align:center">返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h3 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2. 数学函数"></a>2. 数学函数</h3><pre><code class="c">#include &lt;math.h&gt;</code></pre><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">sqrt(x)</td><td style="text-align:center">计算平方根</td></tr><tr><td style="text-align:center">fabs(x)</td><td style="text-align:center">求绝对值</td></tr><tr><td style="text-align:center">log(x)  log10(x)</td><td style="text-align:center">计算 lnx（e）   计算 lgx（10）</td></tr><tr><td style="text-align:center">exp(x)</td><td style="text-align:center">计算 e^x^</td></tr><tr><td style="text-align:center">pow(x ,y)</td><td style="text-align:center">计算 x^y^</td></tr><tr><td style="text-align:center">ceil(x)</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">floor(x)</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">fmod(x, y)</td><td style="text-align:center">计算 x 除以 y 的余数</td></tr></tbody></table><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h2 id="不常用"><a href="#不常用" class="headerlink" title="*不常用"></a>*不常用</h2><h3 id="1-枚举常量"><a href="#1-枚举常量" class="headerlink" title="1. 枚举常量"></a>1. 枚举常量</h3><p>用于定义一些离散的数据。</p><pre><code class="c">enum DAY{      MON=1,       TUE,       WED,       THU,       FRI,       SAT,       SUN};    // 枚举常量中，一个常量若没有被赋值，则默认为前面的值加上 1，若全未指定，第一个就为 0</code></pre><h3 id="2-位域"><a href="#2-位域" class="headerlink" title="2. 位域"></a>2. 位域</h3><p>用来压缩存储，其大致规则为：</p><ol><li>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li><li>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li><li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；</li><li>如果位域字段之间穿插着非位域字段，则不进行压缩；</li><li>整个结构体的总大小为最宽基本类型成员大小的整数倍。</li></ol><pre><code class="c">// 一个位域必须存储在同一个字节中，不能跨两个字节，因此最大为8struct bs{    unsigned a:4;    unsigned  :4;    /* 空域 */    unsigned b:4;    /* 从下一单元开始存放 */    unsigned c:4}struct  AA{   unsigned int b1:5;   unsigned int b2:5;   unsigned int b3:5;   unsigned int b4:5;   unsigned int b5:5;   unsigned int b6:5;   unsigned int b7:5;}AA;// 只算5个成员,按第一条规则,共占25位,按第五条规则,即sizeof(AA)=4// 算7个成员，按第一条规则,共占35位,按第五条规则,即sizeof(AA)=8,</code></pre><h3 id="3-typedef"><a href="#3-typedef" class="headerlink" title="3. typedef"></a>3. <strong>typedef</strong></h3><p>用来取别名</p><pre><code class="c">// 给数据类型取别名typedef int INTERGE;INTERGE n = 10;// 给结构体取别名typedef struct stu{    char name[20];    int age;    char sex;} STU;STU body1,body2;// 等价于struct stu body1, body2;</code></pre><p>与宏定义的区别</p><pre><code class="c">#define INTERGE intunsigned INTERGE n;  //没问题typedef int INTERGE;unsigned INTERGE n;  //错误，不能在 INTERGE 前面添加 unsigned</code></pre><h1 id="二、附录"><a href="#二、附录" class="headerlink" title="二、附录"></a>二、附录</h1><h2 id="ASCII表"><a href="#ASCII表" class="headerlink" title="ASCII表"></a>ASCII表</h2><p>标准 ASCII 编码共收录了 128 个字符，其中包含了 33 个控制字符（具有某些特殊功能但是无法显示的字符）和 95 个可显示字符。’A’(65) 和 ‘a’(97) 之差为 32。</p><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>字符/缩写</th><th>解释</th></tr></thead><tbody><tr><td>00000000</td><td>0</td><td>00</td><td>NUL (NULL)</td><td>空字符</td></tr><tr><td>00000001</td><td>1</td><td>01</td><td>SOH (Start Of Headling)</td><td>标题开始</td></tr><tr><td>00000010</td><td>2</td><td>02</td><td>STX (Start Of Text)</td><td>正文开始</td></tr><tr><td>00000011</td><td>3</td><td>03</td><td>ETX (End Of Text)</td><td>正文结束</td></tr><tr><td>00000100</td><td>4</td><td>04</td><td>EOT (End Of Transmission)</td><td>传输结束</td></tr><tr><td>00000101</td><td>5</td><td>05</td><td>ENQ (Enquiry)</td><td>请求</td></tr><tr><td>00000110</td><td>6</td><td>06</td><td>ACK (Acknowledge)</td><td>回应/响应/收到通知</td></tr><tr><td>00000111</td><td>7</td><td>07</td><td>BEL (Bell)</td><td>响铃</td></tr><tr><td>00001000</td><td>8</td><td>08</td><td>BS (Backspace)</td><td>退格</td></tr><tr><td>00001001</td><td>9</td><td>09</td><td>HT (Horizontal Tab)</td><td>水平制表符</td></tr><tr><td>00001010</td><td>10</td><td>0A</td><td>LF/NL(Line Feed/New Line)</td><td>换行键</td></tr><tr><td>00001011</td><td>11</td><td>0B</td><td>VT (Vertical Tab)</td><td>垂直制表符</td></tr><tr><td>00001100</td><td>12</td><td>0C</td><td>FF/NP (Form Feed/New Page)</td><td>换页键</td></tr><tr><td>00001101</td><td>13</td><td>0D</td><td>CR (Carriage Return)</td><td>回车键</td></tr><tr><td>00001110</td><td>14</td><td>0E</td><td>SO (Shift Out)</td><td>不用切换</td></tr><tr><td>00001111</td><td>15</td><td>0F</td><td>SI (Shift In)</td><td>启用切换</td></tr><tr><td>00010000</td><td>16</td><td>10</td><td>DLE (Data Link Escape)</td><td>数据链路转义</td></tr><tr><td>00010001</td><td>17</td><td>11</td><td>DC1/XON(Device Control 1/Transmission On)</td><td>设备控制1/传输开始</td></tr><tr><td>00010010</td><td>18</td><td>12</td><td>DC2 (Device Control 2)</td><td>设备控制2</td></tr><tr><td>00010011</td><td>19</td><td>13</td><td>DC3/XOFF(Device Control 3/Transmission Off)</td><td>设备控制3/传输中断</td></tr><tr><td>00010100</td><td>20</td><td>14</td><td>DC4 (Device Control 4)</td><td>设备控制4</td></tr><tr><td>00010101</td><td>21</td><td>15</td><td>NAK (Negative Acknowledge)</td><td>无响应/非正常响应/拒绝接收</td></tr><tr><td>00010110</td><td>22</td><td>16</td><td>SYN (Synchronous Idle)</td><td>同步空闲</td></tr><tr><td>00010111</td><td>23</td><td>17</td><td>ETB (End of Transmission Block)</td><td>传输块结束/块传输终止</td></tr><tr><td>00011000</td><td>24</td><td>18</td><td>CAN (Cancel)</td><td>取消</td></tr><tr><td>00011001</td><td>25</td><td>19</td><td>EM (End of Medium)</td><td>已到介质末端/介质存储已满/介质中断</td></tr><tr><td>00011010</td><td>26</td><td>1A</td><td>SUB (Substitute)</td><td>替补/替换</td></tr><tr><td>00011011</td><td>27</td><td>1B</td><td>ESC (Escape)</td><td>逃离/取消</td></tr><tr><td>00011100</td><td>28</td><td>1C</td><td>FS (File Separator)</td><td>文件分割符</td></tr><tr><td>00011101</td><td>29</td><td>1D</td><td>GS (Group Separator)</td><td>组分隔符/分组符</td></tr><tr><td>00011110</td><td>30</td><td>1E</td><td>RS (Record Separator)</td><td>记录分离符</td></tr><tr><td>00011111</td><td>31</td><td>1F</td><td>US (Unit Separator)</td><td>单元分隔符</td></tr><tr><td>00100000</td><td>32</td><td>20</td><td>(Space)</td><td>空格</td></tr><tr><td>00100001</td><td>33</td><td>21</td><td>!</td><td></td></tr><tr><td>00100010</td><td>34</td><td>22</td><td>“</td><td></td></tr><tr><td>00100011</td><td>35</td><td>23</td><td>#</td><td></td></tr><tr><td>00100100</td><td>36</td><td>24</td><td>$</td><td></td></tr><tr><td>00100101</td><td>37</td><td>25</td><td>%</td><td></td></tr><tr><td>00100110</td><td>38</td><td>26</td><td>&amp;</td><td></td></tr><tr><td>00100111</td><td>39</td><td>27</td><td>‘</td><td></td></tr><tr><td>00101000</td><td>40</td><td>28</td><td>(</td><td></td></tr><tr><td>00101001</td><td>41</td><td>29</td><td>)</td><td></td></tr><tr><td>00101010</td><td>42</td><td>2A</td><td>*</td><td></td></tr><tr><td>00101011</td><td>43</td><td>2B</td><td>+</td><td></td></tr><tr><td>00101100</td><td>44</td><td>2C</td><td>,</td><td></td></tr><tr><td>00101101</td><td>45</td><td>2D</td><td>-</td><td></td></tr><tr><td>00101110</td><td>46</td><td>2E</td><td>.</td><td></td></tr><tr><td>00101111</td><td>47</td><td>2F</td><td>/</td><td></td></tr><tr><td>00110000</td><td>48</td><td>30</td><td>0</td><td></td></tr><tr><td>00110001</td><td>49</td><td>31</td><td>1</td><td></td></tr><tr><td>00110010</td><td>50</td><td>32</td><td>2</td><td></td></tr><tr><td>00110011</td><td>51</td><td>33</td><td>3</td><td></td></tr><tr><td>00110100</td><td>52</td><td>34</td><td>4</td><td></td></tr><tr><td>00110101</td><td>53</td><td>35</td><td>5</td><td></td></tr><tr><td>00110110</td><td>54</td><td>36</td><td>6</td><td></td></tr><tr><td>00110111</td><td>55</td><td>37</td><td>7</td><td></td></tr><tr><td>00111000</td><td>56</td><td>38</td><td>8</td><td></td></tr><tr><td>00111001</td><td>57</td><td>39</td><td>9</td><td></td></tr><tr><td>00111010</td><td>58</td><td>3A</td><td>:</td><td></td></tr><tr><td>00111011</td><td>59</td><td>3B</td><td>;</td><td></td></tr><tr><td>00111100</td><td>60</td><td>3C</td><td>&lt;</td><td></td></tr><tr><td>00111101</td><td>61</td><td>3D</td><td>=</td><td></td></tr><tr><td>00111110</td><td>62</td><td>3E</td><td>&gt;</td><td></td></tr><tr><td>00111111</td><td>63</td><td>3F</td><td>?</td><td></td></tr><tr><td>01000000</td><td>64</td><td>40</td><td>@</td><td></td></tr><tr><td>01000001</td><td>65</td><td>41</td><td>A</td><td></td></tr><tr><td>01000010</td><td>66</td><td>42</td><td>B</td><td></td></tr><tr><td>01000011</td><td>67</td><td>43</td><td>C</td><td></td></tr><tr><td>01000100</td><td>68</td><td>44</td><td>D</td><td></td></tr><tr><td>01000101</td><td>69</td><td>45</td><td>E</td><td></td></tr><tr><td>01000110</td><td>70</td><td>46</td><td>F</td><td></td></tr><tr><td>01000111</td><td>71</td><td>47</td><td>G</td><td></td></tr><tr><td>01001000</td><td>72</td><td>48</td><td>H</td><td></td></tr><tr><td>01001001</td><td>73</td><td>49</td><td>I</td><td></td></tr><tr><td>01001010</td><td>74</td><td>4A</td><td>J</td><td></td></tr><tr><td>01001011</td><td>75</td><td>4B</td><td>K</td><td></td></tr><tr><td>01001100</td><td>76</td><td>4C</td><td>L</td><td></td></tr><tr><td>01001101</td><td>77</td><td>4D</td><td>M</td><td></td></tr><tr><td>01001110</td><td>78</td><td>4E</td><td>N</td><td></td></tr><tr><td>01001111</td><td>79</td><td>4F</td><td>O</td><td></td></tr><tr><td>01010000</td><td>80</td><td>50</td><td>P</td><td></td></tr><tr><td>01010001</td><td>81</td><td>51</td><td>Q</td><td></td></tr><tr><td>01010010</td><td>82</td><td>52</td><td>R</td><td></td></tr><tr><td>01010011</td><td>83</td><td>53</td><td>S</td><td></td></tr><tr><td>01010100</td><td>84</td><td>54</td><td>T</td><td></td></tr><tr><td>01010101</td><td>85</td><td>55</td><td>U</td><td></td></tr><tr><td>01010110</td><td>86</td><td>56</td><td>V</td><td></td></tr><tr><td>01010111</td><td>87</td><td>57</td><td>W</td><td></td></tr><tr><td>01011000</td><td>88</td><td>58</td><td>X</td><td></td></tr><tr><td>01011001</td><td>89</td><td>59</td><td>Y</td><td></td></tr><tr><td>01011010</td><td>90</td><td>5A</td><td>Z</td><td></td></tr><tr><td>01011011</td><td>91</td><td>5B</td><td>[</td><td></td></tr><tr><td>01011100</td><td>92</td><td>5C</td><td>\</td><td></td></tr><tr><td>01011101</td><td>93</td><td>5D</td><td>]</td><td></td></tr><tr><td>01011110</td><td>94</td><td>5E</td><td>^</td><td></td></tr><tr><td>01011111</td><td>95</td><td>5F</td><td>_</td><td></td></tr><tr><td>01100000</td><td>96</td><td>60</td><td>`</td><td></td></tr><tr><td>01100001</td><td>97</td><td>61</td><td>a</td><td></td></tr><tr><td>01100010</td><td>98</td><td>62</td><td>b</td><td></td></tr><tr><td>01100011</td><td>99</td><td>63</td><td>c</td><td></td></tr><tr><td>01100100</td><td>100</td><td>64</td><td>d</td><td></td></tr><tr><td>01100101</td><td>101</td><td>65</td><td>e</td><td></td></tr><tr><td>01100110</td><td>102</td><td>66</td><td>f</td><td></td></tr><tr><td>01100111</td><td>103</td><td>67</td><td>g</td><td></td></tr><tr><td>01101000</td><td>104</td><td>68</td><td>h</td><td></td></tr><tr><td>01101001</td><td>105</td><td>69</td><td>i</td><td></td></tr><tr><td>01101010</td><td>106</td><td>6A</td><td>j</td><td></td></tr><tr><td>01101011</td><td>107</td><td>6B</td><td>k</td><td></td></tr><tr><td>01101100</td><td>108</td><td>6C</td><td>l</td><td></td></tr><tr><td>01101101</td><td>109</td><td>6D</td><td>m</td><td></td></tr><tr><td>01101110</td><td>110</td><td>6E</td><td>n</td><td></td></tr><tr><td>01101111</td><td>111</td><td>6F</td><td>o</td><td></td></tr><tr><td>01110000</td><td>112</td><td>70</td><td>p</td><td></td></tr><tr><td>01110001</td><td>113</td><td>71</td><td>q</td><td></td></tr><tr><td>01110010</td><td>114</td><td>72</td><td>r</td><td></td></tr><tr><td>01110011</td><td>115</td><td>73</td><td>s</td><td></td></tr><tr><td>01110100</td><td>116</td><td>74</td><td>t</td><td></td></tr><tr><td>01110101</td><td>117</td><td>75</td><td>u</td><td></td></tr><tr><td>01110110</td><td>118</td><td>76</td><td>v</td><td></td></tr><tr><td>01110111</td><td>119</td><td>77</td><td>w</td><td></td></tr><tr><td>01111000</td><td>120</td><td>78</td><td>x</td><td></td></tr><tr><td>01111001</td><td>121</td><td>79</td><td>y</td><td></td></tr><tr><td>01111010</td><td>122</td><td>7A</td><td>z</td><td></td></tr><tr><td>01111011</td><td>123</td><td>7B</td><td>{</td><td></td></tr><tr><td>01111100</td><td>124</td><td>7C</td><td>\</td><td></td><td></td></tr><tr><td>01111101</td><td>125</td><td>7D</td><td>}</td><td></td></tr><tr><td>01111110</td><td>126</td><td>7E</td><td>~</td><td></td></tr><tr><td>01111111</td><td>127</td><td>7F</td><td>DEL (Delete)</td><td>删除</td></tr></tbody></table><p>上表是标准的 ASCII 编码，它共收录了 128 个字符，用一个字节中较低的 7 个比特位（Bit）足以表示（2^7^ = 128），所以还会空闲下一个比特位，它就被浪费了。</p><blockquote><p>来源：<a href="http://c.biancheng.net/cpp/html/3451.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/html/3451.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 快查 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快查 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Hexo</title>
      <link href="/2018/03/24/%E5%85%B3%E4%BA%8EHexo/"/>
      <url>/2018/03/24/%E5%85%B3%E4%BA%8EHexo/</url>
      <content type="html"><![CDATA[<p>用 Hexo 来部署博客是真的很爽，但是用起来还稍微有点小问题，具体看下面。</p><h1 id="一、部署方式"><a href="#一、部署方式" class="headerlink" title="一、部署方式"></a>一、部署方式</h1><p>部署方式有两种：</p><ol><li>本地安装 Hexo → hexo g -d 部署到 VPS 或 GitHub Page → 用户访问</li><li>VPS 上安装 Hexo → 本地编写 Markdown → 同步到 VPS 对应目录 → hexo g 解析成静态页（此时还可以选择把静态页同步到其他诸如 GitHub Page 的服务） →  hexo s 对外服务 → 用户访问</li></ol><p><strong>对于第一种方式</strong></p><p>一般大家都是用的这种方式，但是这种方式有一个问题，就是你有多台工作机时，得在几台机器上都装上 Hexo 才能实现每台机器都能部署。</p><p><strong>对于第二种方式</strong></p><p>这个方式用的人很少，但是可以解决第一种方式的问题，但是比较麻烦的就是设置，比起第一种方法要额外多很多设置的地方，如果要部署到 GitHub Page 更麻烦，哪天有空，我会把这种方式走一遍整理一下。</p><h1 id="二、多工作机的文档同步"><a href="#二、多工作机的文档同步" class="headerlink" title="二、多工作机的文档同步"></a>二、多工作机的文档同步</h1><p>这个有个解决办法是把 Hexo 目录下的 source 目录新建作为一个 Git 项目，然后同步到 GitHub，以此管理就可以了。</p><h1 id="三、Hexo-该如何备份"><a href="#三、Hexo-该如何备份" class="headerlink" title="三、Hexo 该如何备份"></a>三、Hexo 该如何备份</h1><p>一般来说备份 scaffolds（模板）、source（文档）、theme（主题及设置）、_config.yml（hexo设置）即可。然后在新环境下：</p><pre><code class="shell"># 全局安装hexonpm install hexo-cli -g# 安装部署工具npm install --save hexo-deployer-git# 安装搜索引擎，如果你用的是这个的话npm install --save hexo-generator-search# 把备份的文件复制进去即可</code></pre><h1 id="四、Hexo-的-Git-配置"><a href="#四、Hexo-的-Git-配置" class="headerlink" title="四、Hexo 的 Git 配置"></a>四、Hexo 的 Git 配置</h1><p><strong>_config.yml 设置（hexo的，不是主题的），三行一个单元，可以配置多个</strong></p><pre><code class="yml">deploy:- type: git  repo: hexo@yfree.cc:/home/hexo/hexo.git  branch: master</code></pre><p><strong>VPS 上新建一个用户</strong></p><pre><code class="shell"># 用户目录下新建 .ssh 目录，新建 authorized_keys 文件# 用户目录下新建 hexo.gitcd ~git init --bare hexo.git# hexo.git 目录下的 hooks 目录，新建 post-receive 文件，写入：#!/bin/shgit --work-tree=/data/wwwroot/blog.yfree.cc --git-dir=/home/hexo/hexo.git checkout -f# 添加可执行权限chmod +x post-receive# 新建一对 ssh 密钥，发送公钥到 VPSssh-copy-id -i ~/.ssh/hexo.pub &#39;git@vps地址&#39; -p &#39;ssh端口&#39;# 如果报错，把本地的 .ssh 文件夹中的 known_hosts 文件中的对应行删掉即可</code></pre>]]></content>
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好用的工具整理及推荐</title>
      <link href="/2018/03/19/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E5%8F%8A%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/03/19/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E5%8F%8A%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>所谓“工欲善其事必先利其器”，好用的工具能够极大的提升工作效率，让你更加注重于工作的主干而非细枝末节。但平常方便的工具找起来，除了很有名气的，其他的基本只能随缘，所以我在此整理我日常收集的各种好用工具。</p><h1 id="二、工具"><a href="#二、工具" class="headerlink" title="二、工具"></a>二、工具</h1><h2 id="1-作图类"><a href="#1-作图类" class="headerlink" title="1. 作图类"></a>1. 作图类</h2><h3 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h3><ul><li><a href="https://www.xmind.cn/" target="_blank" rel="noopener">Xmind</a>：很好用的思维导图工具，可以和印象笔记联动，本来有云服务，特别方便。但是前几个月处理个通知说要取消云服务。</li></ul><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><ul><li><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>：画流程图、P-R图什么的必备。</li></ul><h3 id="二维码："><a href="#二维码：" class="headerlink" title="二维码："></a>二维码：</h3><ul><li><a href="https://cli.im/" target="_blank" rel="noopener">草料二维码</a></li></ul><h2 id="2-多设备"><a href="#2-多设备" class="headerlink" title="2. 多设备"></a>2. 多设备</h2><h3 id="远程控制："><a href="#远程控制：" class="headerlink" title="远程控制："></a>远程控制：</h3><h4 id="局域网内："><a href="#局域网内：" class="headerlink" title="局域网内："></a>局域网内：</h4><ul><li>Windows 自带的远程登录，在手机端有 RD Client，RD Client有个特点是能够把电脑界面自适应到手机，并支持触控，很像一台 Windows系统的手机。</li><li>Chrome 远程：有这样一个应用，还没用过。</li></ul><h4 id="互联网内："><a href="#互联网内：" class="headerlink" title="互联网内："></a>互联网内：</h4><ul><li><a href="https://www.teamviewer.com/zhCN/" target="_blank" rel="noopener">TeamViewer</a>：与Windows自带的远程登录不同，这个能够让不在同一个局域子网的设备之间互相远程控制</li></ul><h2 id="3-在线工具"><a href="#3-在线工具" class="headerlink" title="3. 在线工具"></a>3. 在线工具</h2><h3 id="程序员工具集："><a href="#程序员工具集：" class="headerlink" title="程序员工具集："></a>程序员工具集：</h3><p>在线工具可以快速解决一些问题，比如：</p><ul><li>正则表达式匹配测试</li><li>各种代码格式化</li><li>各种在线编码</li></ul><p>推荐几个功能较为丰富的。</p><ul><li><a href="http://www.bejson.com/" target="_blank" rel="noopener">http://www.bejson.com/</a></li><li><a href="https://www.sojson.com/" target="_blank" rel="noopener">https://www.sojson.com/</a></li><li><a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></li><li><a href="http://tool.oschina.net/" target="_blank" rel="noopener">http://tool.oschina.net/</a></li></ul><h3 id="短网址"><a href="#短网址" class="headerlink" title="短网址"></a>短网址</h3><ul><li><a href="http://sina.lt/" target="_blank" rel="noopener">新浪</a></li><li><a href="http://dwz.cn/" target="_blank" rel="noopener">百度</a></li><li><a href="http://suo.im/" target="_blank" rel="noopener">suo.im</a></li></ul><h3 id="其他在线工具"><a href="#其他在线工具" class="headerlink" title="其他在线工具"></a>其他在线工具</h3><ul><li><a href="https://tinypng.com/" target="_blank" rel="noopener">在线图片压缩</a></li><li><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf</a>：pdf 与 doc、ppt 等文档格式之间的任意转换。</li><li><a href="http://www.99cankao.com/" target="_blank" rel="noopener">在线计算器</a>：提供了代数、线代、几何等各种数学在线计算。</li><li><a href="https://zhcn.109876543210.com/" target="_blank" rel="noopener">在线OCR</a>：在线图片识别。</li><li><a href="http://tool.chacuo.net/cryptrsakeyparse" target="_blank" rel="noopener">RSA加密解密</a></li><li><a href="https://www.tineye.com/" target="_blank" rel="noopener">搜图</a></li><li><a href="http://www.ip138.com/" target="_blank" rel="noopener">ip138</a>：IP 定位。</li><li><a href="https://www.oschina.net/p/ip2region" target="_blank" rel="noopener">开源项目：ip2region</a>：一个 IP 定位的开源项目。</li></ul><h2 id="4-云工具"><a href="#4-云工具" class="headerlink" title="4. 云工具"></a>4. 云工具</h2><h3 id="云文档"><a href="#云文档" class="headerlink" title="云文档"></a>云文档</h3><p>云文档首推石墨：</p><ul><li><a href="https://shimo.im/" target="_blank" rel="noopener">石墨文档</a></li><li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a>：用 Markdown 写作的同学。</li></ul><h3 id="云盘"><a href="#云盘" class="headerlink" title="云盘"></a>云盘</h3><p>国内的云盘已经不多了，大文件暂时没有找到比百度云更好的选择，小文件首推腾讯微云：</p><ul><li><a href="https://www.weiyun.com/" target="_blank" rel="noopener">腾讯微云</a></li></ul><h2 id="5-Markdown"><a href="#5-Markdown" class="headerlink" title="5. Markdown"></a>5. Markdown</h2><p>Markdown 虽然好使，但是有几个痛点：</p><ul><li>解析 Markdown 的颜值</li><li>Markdown 导出为 PDF 等文档</li><li>Markdown 中的图片插入</li></ul><p>第二三点基本想要较为完美的解决都要付费（稳定的图床很少，所以第三点还是痛点），但经过我不懈的努力，终于找到了几个好的解决办法。</p><ul><li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a>：颜值高，但是导出和插图要付费。</li><li><a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>：颜值高，解决了图片的痛点，而且打开浏览器就能写，云端同步，但是没有导出功能。</li><li><a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HexoEditor</a>：完美解决了所有问题。</li><li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>：解决了本地图片的问题，如果上传到服务器，服务器带宽速度够快的话不是问题，并且这绝对是写Markdown最爽的工具。</li></ul><h2 id="6-为了颜值和装逼"><a href="#6-为了颜值和装逼" class="headerlink" title="6. 为了颜值和装逼"></a>6. 为了颜值和装逼</h2><ul><li>TranslucentTB：Win10任务栏透明，只有600k。</li><li><a href="https://www.stardock.com/products/fences/" target="_blank" rel="noopener">Fences</a>：不只是桌面图标整理</li><li>QuiLlook 和 Seer：Windows下实现 Mac 上的空格快速预览效果。</li></ul><h2 id="7-工作效率"><a href="#7-工作效率" class="headerlink" title="7. 工作效率"></a>7. 工作效率</h2><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li>Microsoft To-Do：颜值高，手机端和 Win10 端都有，很好用，在 win10 的应用商店中搜。</li></ul><h2 id="8-Chrome-插件-amp-应用"><a href="#8-Chrome-插件-amp-应用" class="headerlink" title="8. Chrome 插件 &amp; 应用"></a>8. Chrome 插件 &amp; 应用</h2><ul><li>Postman：后端必备</li><li>JSON-handle：Json 的格式化</li><li>Momentum：为了首页的颜值</li><li>印象笔记-剪藏：数据收集控</li><li>绿色搜索：屏蔽百度的竞价排名广告</li></ul><h2 id="9-扒视频"><a href="#9-扒视频" class="headerlink" title="9. 扒视频"></a>9. 扒视频</h2><ul><li><a href="http://www.vidown.cn/" target="_blank" rel="noopener">维棠</a>：这个可以扒 YouTube。</li><li><a href="http://www.clipconverter.cc/" target="_blank" rel="noopener">扒 YouTube 视频</a></li></ul><h1 id="三、娱乐"><a href="#三、娱乐" class="headerlink" title="三、娱乐"></a>三、娱乐</h1>]]></content>
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用 OneinStack 快速搭建开 Linux 开发环境</title>
      <link href="/2018/03/17/%E7%94%A8OneinStack%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%BC%80Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/03/17/%E7%94%A8OneinStack%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%BC%80Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>这篇博客将介绍目前我发现最简单的配置 Linux 开发环境的方法 ——<a href="https://oneinstack.com/" target="_blank" rel="noopener">OneinStack</a>。</p><p>对于想要稍微了解一下 Linux 各项系统设置的同学可以看我的另一篇文章 —— <a href="/2018/03/16/记一次完整的Linux环境配置">记一次完整的Linux环境配置</a>，这篇文章记录了手动配置最新软件的 Linux 开发环境的方法。</p><h1 id="一、OneinStack-介绍"><a href="#一、OneinStack-介绍" class="headerlink" title="一、OneinStack 介绍"></a>一、OneinStack 介绍</h1><p>OneinStack 是一个脚本，能够极度简便的安装服务器开发环境。直接看官网的介绍可能更明了一些。</p><ul><li>持续不断更新</li><li>源码编译安装，大多数源码是最新stable版，并从官方网址下载</li><li>提供多个数据库版本(MySQL-5.7, MySQL-5.6, MySQL-5.5, MariaDB-10.1, MariaDB-10.0, MariaDB-5.5, Percona-5.7, Percona-5.6, Percona-5.5，AliSQL-5.6，PostgreSQL, MongoDB)</li><li>提供多个PHP版本(PHP-7.2,PHP-7.1,PHP-7.0,PHP-5.6, PHP-5.5,PHP-5.4,PHP-5.3)</li><li>提供Nginx、Tengine、OpenResty</li><li>提供多个Apache版本（Apache-2.4，Apache-2.2）</li><li>提供多个Tomcat版本（Tomcat-8，Tomcat-7，Tomcat-6）</li><li>提供多个JDK版本（JDK-1.8，JDK-1.7，JDK-1.6）</li><li>根据自己需求安装PHP缓存加速器，提供ZendOPcache、xcache、apcu、eAccelerator。及php加解密工具ionCube、ZendGuardLoader</li><li>根据自己需求安装Pureftpd、phpMyAdmin</li><li>根据自己需求安装Memcached、Redis</li><li>jemalloc优化MySQL、Nginx</li><li>提供添加虚拟主机脚本</li><li>提供Nginx/Tengine/OpenResty/Apache、PHP、Redis、phpMyAdmin升级脚本</li><li>提供本地备、远程（服务器之间rsync）、腾讯云和又拍云备份脚本</li><li>提供CentOS 6、7下HHVM安装</li></ul><h1 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h1><p>文档写的相当详细，所以我这以腾讯云上的 CentOS 7.4 环境为例，记录我所运行的 shell。</p><h2 id="1-先进行了我个人的部分习惯设置"><a href="#1-先进行了我个人的部分习惯设置" class="headerlink" title="1. 先进行了我个人的部分习惯设置"></a>1. 先进行了我个人的部分习惯设置</h2><pre><code class="shell"># 安装 epel 源yum install epel-release# 安装提供新版软件的 IUS 源yum -y install https://centos7.iuscommunity.org/ius-release.rpm# 安装常用软件yum install lrzsz    # 上传和下载命令</code></pre><h2 id="2-按照-OneinStack-的官方文档操作"><a href="#2-按照-OneinStack-的官方文档操作" class="headerlink" title="2. 按照 OneinStack 的官方文档操作"></a>2. 按照 OneinStack 的官方文档操作</h2><pre><code># 安装更新一波基本软件yum -y install wget screen curl python# 我这是腾讯云，下载源码和脚本wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz# 解压tar xzf oneinstack-full.tar.gz# 如果你要修改各软件的默认安装目录，不过默认设置的都挺好的cd oneinstackvi options.conf# 如果网路出现中断，可以执行命令`screen -R oneinstack`重新连接安装窗口，没有的话可以无视这个screen -S oneinstack # 注：请勿sh install.sh或者bash install.sh这样执行./install.sh # 然后安装官方文档的指示一步一步执行即可</code></pre><h3 id="2-1-安装完成"><a href="#2-1-安装完成" class="headerlink" title="2.1 安装完成"></a>2.1 安装完成</h3><p><img src="/用 OneinStack 快速搭建开 Linux 开发环境/安装完成.png" alt=""></p><h2 id="3-其他配置"><a href="#3-其他配置" class="headerlink" title="3. 其他配置"></a>3. 其他配置</h2><h3 id="3-1-添加附加组件"><a href="#3-1-添加附加组件" class="headerlink" title="3.1 添加附加组件"></a>3.1 添加附加组件</h3><pre><code class="shell">./addons.sh</code></pre><p>里面有 composer 等其他附加组件的安装。</p><h3 id="3-2-创建-FTP-虚拟用户账户"><a href="#3-2-创建-FTP-虚拟用户账户" class="headerlink" title="3.2 创建 FTP 虚拟用户账户"></a>3.2 创建 FTP 虚拟用户账户</h3><pre><code class="shell">./pureftpd_vhost.sh</code></pre><p>用来快捷创建 ftp 虚拟用户账户的脚本。</p><h3 id="3-3-增删虚拟主机"><a href="#3-3-增删虚拟主机" class="headerlink" title="3.3 增删虚拟主机"></a>3.3 增删虚拟主机</h3><pre><code class="shell"># 增加虚拟主机./vhost.sh# 删除虚拟主机./vhost.sh del</code></pre><h3 id="3-4-备份和自动备份"><a href="#3-4-备份和自动备份" class="headerlink" title="3.4 备份和自动备份"></a>3.4 备份和自动备份</h3><pre><code class="shell"># Set backup options ./backup_setup.sh # Start backup, You can add cron jobs./backup.sh # crontab -l # Examples 0 1 * * * cd ~/oneinstack;./backup.sh  &gt; /dev/null 2&gt;&amp;1 &amp;</code></pre><h3 id="3-5-更新版本"><a href="#3-5-更新版本" class="headerlink" title="3.5 更新版本"></a>3.5 更新版本</h3><pre><code class="shell">./upgrade.sh</code></pre><h3 id="3-6-卸载"><a href="#3-6-卸载" class="headerlink" title="3.6 卸载"></a>3.6 卸载</h3><pre><code class="shell">./uninstall.sh</code></pre><h2 id="4-软件安装位置和配置文件位置"><a href="#4-软件安装位置和配置文件位置" class="headerlink" title="4. 软件安装位置和配置文件位置"></a>4. 软件安装位置和配置文件位置</h2><p>如果没有更改安装前的配置文件，那么安装完成后就如上图：</p><ul><li>软件：/usr/local</li><li>数据： /data</li><li>日志：/data/wwwlogs</li><li>配置文件：/usr/local</li></ul><p><strong>1. phpMyAdmin：<a href="http://x.x.x.x/phpMyAdmin" target="_blank" rel="noopener">http://x.x.x.x/phpMyAdmin</a></strong></p><p><strong>2. Opcache Control Panel URL：<a href="http://x.x.x.x/ocp.php" target="_blank" rel="noopener">http://x.x.x.x/ocp.php</a></strong></p><p>​    可以加速php，但是PHP代码更新后，需要2～3分钟才能生效，可以打开进入这个页面点击 <code>reset</code>。</p><h3 id="4-1-服务管理"><a href="#4-1-服务管理" class="headerlink" title="4.1 服务管理"></a>4.1 服务管理</h3><p>Nginx/Tengine/OpenResty:</p><pre><code>service nginx {start|stop|status|restart|reload|configtest}</code></pre><p>MySQL/MariaDB/Percona:</p><pre><code>service mysqld {start|stop|restart|reload|status}</code></pre><p>PostgreSQL:</p><pre><code>service postgresql {start|stop|restart|status}</code></pre><p>MongoDB:</p><pre><code>service mongod {start|stop|status|restart|reload}</code></pre><p>PHP:</p><pre><code>service php-fpm {start|stop|restart|reload|status}</code></pre><p>HHVM:</p><pre><code>service supervisord {start|stop|status|restart|reload}</code></pre><p><strong>注</strong>：hhvm进程交给supervisord管理，了解更多请访问《<a href="https://blog.linuxeye.com/408.html" target="_blank" rel="noopener">Supervisor管理hhvm进程</a>》<br>Apache:</p><pre><code>service httpd {start|restart|stop}</code></pre><p>Tomcat:</p><pre><code>service tomcat {start|stop|status|restart}</code></pre><p>Pure-Ftpd:</p><pre><code>service pureftpd {start|stop|restart|status}</code></pre><p>Redis:</p><pre><code>service redis-server {start|stop|status|restart|reload}</code></pre><p>Memcached:</p><pre><code>service memcached {start|stop|status|restart|reload}</code></pre><h1 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h1><p>我在使用这个脚本前，本来还在想会不会有什么地方会不符合个人操作习惯，但是整个跑一遍后发现，无论是安装路径的设置还是数据存储路径的设置，默认都已经设置的很好了，是在无话可说。</p><p>对应想要快速搭建服务器环境的朋友，强烈推荐这个工具。</p><h1 id="四、更新"><a href="#四、更新" class="headerlink" title="四、更新"></a>四、更新</h1><blockquote><p>2018-3-23 更新</p><p>安装后我发现其中的 phpmyadmin 版本不是最新的，作为版本控必然是忍受不了的，记录更新步骤如下。</p></blockquote><pre><code># 用 www 账户操作# cd 到 /data/www 目录下，你操作的时候去官网找最新下载链接wget https://files.phpmyadmin.net/phpMyAdmin/4.7.9/phpMyAdmin-4.7.9-all-languages.zip# 解压，默认没有 upzip，用 yum 安装一下，可以顺便把 zip 安装了unzip phpMyAdmin-4.7.9-all-languages.zip# 修改目录名mv phpMyAdmin-4.7.9-all-languages phpmyadmin# 复制一份配置文件cd phpmyadmincp libraries/config.default.php config.inc.php  </code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次完整的Linux环境配置</title>
      <link href="/2018/03/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/03/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>刚学编程的时候，用腾讯云曾经尝试从头开始配置一次 Linux 环境，但当时卡在最后一步没有成功，又急着用就刷了云市场的镜像。最近打算把云主机重新装过一次，所以打算先用虚拟机完整的走一次流程。</p><p><strong>2018/3/17 更新</strong></p><p>这篇博客用较为简单的方法从头配置了常用开发环境，但是刚刚配置完、写完这篇博客我发现了更加简单的配置环境方法 —— <a href="https://oneinstack.com/" target="_blank" rel="noopener">OneinStack</a>。</p><p>对于想要稍微了解一下 Linux 各项系统设置的同学可以继续看这篇文章，回头再去了解 OneinStack。</p><p>对于只想要快速搭建系开发环境，又不想用云市场上老旧软件镜像的，建议了解 OneinStack ，可以看我另一篇文章 —— <a href="/2018/03/17/用OneinStack快速搭建开Linux开发环境">用 OneinStack 快速搭建开 Linux 开发环境</a></p><h1 id="一、配置要求"><a href="#一、配置要求" class="headerlink" title="一、配置要求"></a>一、配置要求</h1><p>除了系统使用云服务商提供的版本外，其他软件版本皆使用最新的版本（不要求最最新，至少不是上古版本）。这就导致了一个难点，本来用 <code>yum</code> 安装可以不用考虑包依赖的问题，但是要求软件版本皆为最新的话就一般得用编译安装，这样就会因为各种包之间的互相依赖问题而异常繁琐。</p><p><strong>福音：epel</strong></p><p>当我决定安装最新版软件的时候，就在想有没有哪些 yum 源，里面的软件就已经是最新的，后来发现真有，就是这个 <code>epel</code>，当然也不止这一个，还有许多其他的源。</p><pre><code class="shell"># 安装 epel 源yum install epel-release</code></pre><p>一个推荐的社区<a href="https://ius.io/GettingStarted/#install-via-automation" target="_blank" rel="noopener">IUS</a>，提供新版的软件</p><pre><code class="shell"># 下面两种方法都可以安装yum -y install https://centos7.iuscommunity.org/ius-release.rpmrpm -Uvh install https://centos7.iuscommunity.org/ius-release.rpm</code></pre><h1 id="二、系统软件版本记录"><a href="#二、系统软件版本记录" class="headerlink" title="二、系统软件版本记录"></a>二、系统软件版本记录</h1><p><strong>时间</strong>：2018-03-08</p><p><strong>系统</strong>：CentOS-7-x86_64-Everything-1708 3.10.0-693.E17.x86_64</p><p><strong>软件</strong>：</p><ul><li>Mysql 5.7.21</li><li>Nginx 1.12.2</li><li>PHP 7.2.2</li><li>Python 3.6.4</li><li>Git 1.8.3.1</li><li>phpMyAdmin 4.7.9</li></ul><h1 id="三、虚拟机配置"><a href="#三、虚拟机配置" class="headerlink" title="三、虚拟机配置"></a>三、虚拟机配置</h1><h2 id="1-虚拟机选择"><a href="#1-虚拟机选择" class="headerlink" title="1. 虚拟机选择"></a>1. 虚拟机选择</h2><p>为了方便，直接选择了 Windows10 自带的虚拟机工具 —— Hyper-V。值得注意的是这个只有 Windows 10 专业版中才有，并且需要去控制面的程序和功能中去手动开启这项功能。具体怎么使用，网上都有教程就不在赘述。</p><h2 id="2-系统安装"><a href="#2-系统安装" class="headerlink" title="2. 系统安装"></a>2. 系统安装</h2><p><a href="http://blog.csdn.net/chris_111x/article/details/52313797" target="_blank" rel="noopener">Hyper-V 安装CentOS 7</a> —— 这篇文章相当详细，照着来。</p><p>另外自己安装 CentOS 才发现，CentOS 在安装时有一个“软件选择”选项，其中可以预先选择大多数的常用软件。</p><p>我开了两台虚拟机，一台选择了“基本网页服务器”、一台选择了“最小安装”。</p><p><strong>检查点：</strong></p><p>在系统装好之后可以手动设置一个检查点，这样就可以随时滚回到这个状态来测试系统了，省去了重新安装系统的时间。</p><p><strong>注意：</strong></p><blockquote><p>安装虚拟机后，虚拟机可能没有网卡驱动，由于Hyper-v是不是支持linux网络服务的。</p></blockquote><p>上面链接文档的这个地方，我碰到的网卡驱动正常，所以没有进行这一步。</p><h2 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3. 配置系统"></a>3. 配置系统</h2><h3 id="3-1-配置网络"><a href="#3-1-配置网络" class="headerlink" title="3.1 配置网络"></a>3.1 配置网络</h3><p>CentOS 7.0默认安装好之后是没有自动开启网络连接的！</p><p><a href="http://blog.csdn.net/smart_ljh/article/details/51517232" target="_blank" rel="noopener">网络配置教程</a>，结合前面那一篇和这一篇互相对照就可以解决网络问题。</p><p>总结一下就是：</p><ol><li>配置虚拟交换机和旧版网络适配器</li><li>配置 <code>ifcfg-eth0</code>，设置 <code>ONBOOT=yes</code>、<code>DNS1</code>、<code>DNS2</code> 等必要选项（所给链接里面用的静态IP，推荐动态）</li><li>ping <a href="http://www.baidu.com，通了的话就表示网络OK了" target="_blank" rel="noopener">www.baidu.com，通了的话就表示网络OK了</a></li></ol><pre><code class="shell">#进入网络配置文件目录cd  /etc/sysconfig/network-scripts/ #编辑配置文件，添加修改以下内容vi ifcfg-eth0</code></pre><pre><code>ONBOOT=yes  #开启自动启用网络连接DNS1=8.8.8.8  #设置主DNSDNS2=8.8.4.4  #设置备DNS</code></pre><pre><code>#保存退出:wq!  #重启网络service network restart \ systemctl restart network#测试网络是否正常ping www.baidu.com  #查看IP地址ip addr  </code></pre><h3 id="3-2-设置主机名为www"><a href="#3-2-设置主机名为www" class="headerlink" title="3.2 设置主机名为www"></a>3.2 设置主机名为www</h3><pre><code class="shell">hostname  www  #设置主机名为wwwvi /etc/hostname #编辑配置文件www   #修改localhost.localdomain为www:wq!  #保存退出vi /etc/hosts #编辑配置文件127.0.0.1   localhost  www   #修改localhost.localdomain为www:wq!  #保存退出shutdown -r now  #重启系统</code></pre><h2 id="4-安装常用系统软件"><a href="#4-安装常用系统软件" class="headerlink" title="4. 安装常用系统软件"></a>4. 安装常用系统软件</h2><h3 id="4-1-gcc"><a href="#4-1-gcc" class="headerlink" title="4.1 gcc"></a>4.1 gcc</h3><p>用于编译C。</p><h3 id="4-2-wget"><a href="#4-2-wget" class="headerlink" title="4.2 wget"></a>4.2 wget</h3><p>用于下载。</p><h3 id="4-3-make"><a href="#4-3-make" class="headerlink" title="4.3 make"></a>4.3 make</h3><p>用于编译和安装。</p><h3 id="4-4-net-tools-iproute2-操作"><a href="#4-4-net-tools-iproute2-操作" class="headerlink" title="4.4 net-tools \ iproute2 操作"></a>4.4 net-tools \ iproute2 <a href="http://blog.jobbole.com/97270/" target="_blank" rel="noopener">操作</a></h3><p>iproute2的出现旨在从功能上取代net-tools</p><h3 id="4-5-rz-和-sz"><a href="#4-5-rz-和-sz" class="headerlink" title="4.5 rz 和 sz"></a>4.5 rz 和 sz</h3><p>用于通过命令行下载和上传文件，包名为 <code>lrzsz</code>，<code>rz</code> 为上传， <code>sz</code> 为下载。</p><h3 id="4-6-ftp-和-lftp"><a href="#4-6-ftp-和-lftp" class="headerlink" title="4.6 ftp 和 lftp"></a>4.6 ftp 和 lftp</h3><p>用于访问 ftp 服务器，<code>yum install ftp</code> 和 <code>yum install lftp</code> 安装。</p><h3 id="4-7-vsftp"><a href="#4-7-vsftp" class="headerlink" title="4.7 vsftp"></a>4.7 vsftp</h3><p>用户设置 ftp 账户，包名为 <code>vsftpd</code>，安装后设置开机启动然后启动。</p><h2 id="5-安装常用软件和环境"><a href="#5-安装常用软件和环境" class="headerlink" title="5. 安装常用软件和环境"></a>5. 安装常用软件和环境</h2><h3 id="5-1-PHP"><a href="#5-1-PHP" class="headerlink" title="5.1 PHP"></a>5.1 PHP</h3><p>继上面添加 <code>epel</code> 源后</p><pre><code class="shell"># 安装这个源，里面有 php7 等软件rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# 安装php 7.2，PHP-FPM方式yum install php72w-fpm php72w-opcache# 或 安装php 7.2，mod_php方式，只能用于 Apache web服务器yum install mod_php72w php72w-opcache# 扩展的安装也异常简单yum install php72w-xml# 启动 php-fpm 并设置开机启动systemctl start php-fpmsystemctl enable php-fpm</code></pre><pre><code># 一口气装完所有扩展yum install php72w-bcmath php72w-cli php72w-common php72w-dba php72w-devel php72w-embedded php72w-enchant php72w-fpm php72w-gd php72w-imap php72w-interbase php72w-intl php72w-ldap php72w-mbstring php72w-mysqlnd php72w-odbc php72w-pdo php72w-pdo_dblib php72w-pear php72w-pecl-apcu php72w-pecl-imagick php72w-pecl-mongodb php72w-pgsql php72w-phpdbg php72w-process php72w-pspell php72w-recode php72w-snmp php72w-soap php72w-tidy php72w-xml php72w-xmlrpc</code></pre><p>更多可以参考<a href="https://webtatic.com/packages/php72/" target="_blank" rel="noopener">这里</a>。</p><h3 id="5-2-Nginx"><a href="#5-2-Nginx" class="headerlink" title="5.2 Nginx"></a>5.2 Nginx</h3><pre><code class="shell"># 查看源中的 Nginx 版本yum list nginx# 我发现源中的是最新的稳定版，所以yum install nginx# 启动 Nginx 并设置开机启动systemctl start nginxsystemctl enable nginx</code></pre><p>修改配置文件：</p><pre><code>server_name localhost;  # 原本为 server_name _;location / {    index index.php index.html index.htm;    # 原本没有这一行 }# 添加以下，配置 php-fpmlocation ~ \.php$ {    root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p>网上找到的一个比较完整的配置文件说明：</p><pre><code class="python"># nginx运行的用户名user nginx;# nginx启动进程,通常设置成和cpu的数量相等，这里为自动worker_processes auto;# errorlog文件位置error_log /var/log/nginx/error.log;# pid文件地址，记录了nginx的pid，方便进程管理pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.# 用来加载其他动态模块的配置include /usr/share/nginx/modules/*.conf;# 工作模式和连接数上限events {    # 每个worker_processes的最大并发链接数    # 并发总数：worker_processes*worker_connections    worker_connections 1024;}# 与提供http服务相关的一些配置参数类似的还有mailhttp {    # 设置日志的格式    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    # access_log记录访问的用户、页面、浏览器、ip和其他的访问信息    access_log  /var/log/nginx/access.log  main;    # 这部分下面会单独解释    # 设置nginx是否使用sendfile函数输出文件    sendfile            on;    # 数据包最大时发包(使用Nagle算法)    tcp_nopush          on;    # 立刻发送数据包(禁用Nagle算法)    tcp_nodelay         on;    # 链接超时时间    keepalive_timeout   65;    # 这个我也不清楚...    types_hash_max_size 2048;    # 引入文件扩展名与文件类型映射表    include             /etc/nginx/mime.types;    # 默认文件类型    default_type        application/octet-stream;    # Load modular configuration files from the /etc/nginx/conf.d directory.    # See http://nginx.org/en/docs/ngx_core_module.html#include    # for more information.    include /etc/nginx/conf.d/*.conf;    # http服务上支持若干虚拟主机。    # 每个虚拟主机一个对应的server配置项    # 配置项里面包含该虚拟主机相关的配置。    server {        # 端口        listen       80 default_server;        listen       [::]:80 default_server;        # 访问的域名        server_name  _;        # 默认网站根目录（www目录）        root         /usr/share/nginx/html;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        # 默认请求        location / {        }        # 错误页(404)        error_page 404 /404.html;            location = /40x.html {        }        # 错误页(50X)        error_page 500 502 503 504 /50x.html;            location = /50x.html {        }    }}</code></pre><p><strong>额外：nginx 子域名设置</strong></p><p>在 http 内 server 外添加一行</p><pre><code>include vhosts/*.conf;</code></pre><p>然后在 nginx 目录新建 vhost 目录，里面新建 example.conf（你设置自己的子域名时，最好改成文件中server_name加上’.conf’），写入以下：</p><pre><code>server {        listen       80;                        # IPV4 监听端口        listen       [::]:80;                   # IPV6 监听端口        server_name  blog.***.com;              # 绑定域名        root         /data/www/blog.***.com;    # 网站根目录        location / {            index index.php index.html index.htm;             }        error_page 404 /404.html;            location = /40x.html {        }        error_page 500 502 503 504 /50x.html;            location = /50x.html {        }        # 设置php-fpm        location ~ \.php$ {            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            include        fastcgi_params;        }    }</code></pre><p>虽然不知道会不会保错，这个参考 <code>example.conf</code> 改成 <code>example.conf.bak</code> 最好。</p><h3 id="5-3-Mysql"><a href="#5-3-Mysql" class="headerlink" title="5.3 Mysql"></a>5.3 Mysql</h3><p>yum 的源中不知道为什么都没有 mysql 的包，必须先安装 mysql 的软件源</p><pre><code class="shell"># 安装源，你可以去官网找适合你系统的最新 rpm 链接rpm -Uvh https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm# 安装 mysqlyum install mysql-community-server# 启动 mysql 服务service mysqld start systemctl start mysqld.service # 对于支持这个命令的系统，这个命令更好# 查看 mysql 服务的状态service mysqld statussystemctl status mysqld.service # 对于支持这个命令的系统，这个命令更好# 随意登录一次，提示登录失败，因为最新 mysql 默认使用随机密码mysql -uroot -p# 查看初始随机密码grep &#39;temporary password&#39; /var/log/mysqld.log# 用查看到的随机密码登录并修改密码（包含大写、小写、数字和特殊字符8位以上）mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;;# 如果想去除麻烦的密码设定必须包含这些字符的限制mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;# 设置开机启动，网上有用 chkconfig 的，是旧指令，用下面的即可# 直接设置开机启动即可，不需要手动配置什么 .service 文件systemctl start mysqldsystemctl enable mysqld</code></pre><p><strong>额外：修改mysql数据库的存放路径</strong></p><p>一台服务器上存放的重要数据无外乎两种：数据库数据和网站数据。因此建议把数据库数据和网站数据放在一起，并单独放在一个挂载的盘中。<br>我个人习惯设置网站数据为目录 /data/www，因此就要把数据库文件目录设置到 /data/mysql。设置方法如下：</p><pre><code># 先停掉 mysql 服务systemctl stop mysqld# 找到文件 /etc/my.cnfdatadir=/var/lib/mysql    # 旧目录# 前往旧目录把文件复制到你想要设置的新目录，并修改新目录用户和用户组cp /var/lib/mysql /data/mysqlcd /datachown -R mysql:mysql mysql# 注释掉旧目录一行，设置新目录位置，socket 一行就别换了，不然还得额外设置一些东西# datadir=/var/lib/mysqldatadir=/data/mysql# 启动 mysql 服务systemctl start mysqld</code></pre><h3 id="5-4-Python"><a href="#5-4-Python" class="headerlink" title="5.4 Python"></a>5.4 Python</h3><p>Linux都是自带 Python 的，但是我们也可以安装最新的，不过要注意环境污染。</p><pre><code class="shell"># 添加源rpm -Uvh install https://centos7.iuscommunity.org/ius-release.rpm# 安装 pythonyum install python36u# 配置虚拟环境# Python3.3以上的版本通过venv模块原生支持虚拟环境，可以代替Python之前的virtualenv# 选择一个你喜欢的路径# 我也不知道为什么我这个安装后命令是 python3.6 ,和其他的有点不同python3.6 -m venv py3# 进入虚拟环境，进入后命令行最前面会出现（py3）source py3/bin/activate# 退出虚拟环境，经测试，任意路径都可以执行这个命令deactivate</code></pre><h3 id="5-5-phpMyadmin"><a href="#5-5-phpMyadmin" class="headerlink" title="5.5 phpMyadmin"></a>5.5 phpMyadmin</h3><p>查看源中的版本，和官网的最新版本差了一点，所以这个打算下载安装，但是不同于 php 和 nginx，phpmyadmin 的安装不需要编译，只需要下载解压然后设置配置文件即可。</p><pre><code># cd 到 /data/www 目录下，你操作的时候去官网找最新下载链接wget https://files.phpmyadmin.net/phpMyAdmin/4.7.9/phpMyAdmin-4.7.9-all-languages.zip# 解压，默认没有 upzip，用 yum 安装一下，可以顺便把 zip 安装了unzip phpMyAdmin-4.7.9-all-languages.zip# 修改目录名mv phpMyAdmin-4.7.9-all-languages phpmyadmin# 复制一份配置文件，然后编辑cd phpmyadmincp libraries/config.default.php config.inc.php  </code></pre><p><strong>各个属性</strong></p><p>当然，我测试过了，默认不改任何东西也是OK的。默认登录密码为 mysql 数据库的账户名和密码。</p><pre><code>$cfg[&#39;PmaAbsoluteUri&#39;]=&#39;http://localhost/phpmyadmin&#39;;//将该参数的值设定为phpMyAdmin所处的位置。$cfg[&#39;Servers&#39;][$i][&#39;host&#39;] = &#39;localhost&#39;;//设定MySQL所在的主机名或IP地址。如127.0.0.1这步很重要$cfg[&#39;Servers&#39;][$i][&#39;auth_type&#39;] = &#39;cookie&#39;;// 设定进入phpMyAdmin管理MySQL的方式，共有三个选项：config、http、cookie。config是按配置文件登录；http是使用HTTP登录管理，在Apache模块安装下才能支持；cookie是最通用的管理方式。后两种方式的用户名和密码都是直接到数据库中验证。$cfg[&#39;Servers&#39;][$i][&#39;user&#39;] = &#39;root&#39; ;//设定管理MySQL的账号。$cfg[&#39;Servers&#39;][$i][&#39;password&#39;] = &#39;&#39; ;//设定管理MySQL的密码。 要是你想用空密码把配置中的$cfg[&#39;Servers&#39;][$i][&#39;AllowNoPassword&#39;] = false;改成 $cfg[&#39;Servers&#39;][$i][&#39;AllowNoPassword&#39;] = true;</code></pre><p><strong>坑</strong></p><p>错误：</p><blockquote><p>phpMyAdmin - Error<br>Error during session start; please check your PHP and/or webserver log file and configure your PHP installation properly. Also ensure that cookies are enabled in your browser.</p></blockquote><blockquote><p>session_start(): open(SESSION_FILE, O_RDWR) failed: No such file or directory (2)</p></blockquote><blockquote><p>session_start(): Failed to read session data: files (path: /var/lib/php/session)</p></blockquote><p>原因：</p><blockquote><p>php-fpm 还是 nginx 没有访问 session 的保存目录的权限</p></blockquote><blockquote><p>我具体没测试是 nginx 还是 php-fpm 了，应该是 php-fpm ，不过不重要，下面会把两者的启动用户设置为同一个</p></blockquote><p>解决办法：</p><blockquote><p>把 php-fpm 的启动账户设置成和 nginx 一样（nginx账户），后面一点有说怎么设置</p></blockquote><blockquote><p>/var/lib/php/ 目录下新建 session 目录， 然后把 /var/lib/php 目录及子目录文件权限给 \etc\php-fpm.d\<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a> 中的 user 和 group 对应的用户和用户组。（即 nginx 和 php-fpm 的启动用户和启动组 —— nginx 账户）</p></blockquote><blockquote><p>你可能会问，为什么 session 的目录存在这？是在哪设置的？答案就在 <a href="http://www.conf" target="_blank" rel="noopener">www.conf</a> 的最后面。</p></blockquote><h3 id="5-6-Java环境"><a href="#5-6-Java环境" class="headerlink" title="5.6 Java环境"></a>5.6 Java环境</h3><p>还没学 Java 后台，学了再来补充。</p><h2 id="6-软件、目录和用户权限"><a href="#6-软件、目录和用户权限" class="headerlink" title="6. 软件、目录和用户权限"></a>6. 软件、目录和用户权限</h2><h3 id="6-1-nginx、mysql、php-fpm"><a href="#6-1-nginx、mysql、php-fpm" class="headerlink" title="6.1 nginx、mysql、php-fpm"></a>6.1 nginx、mysql、php-fpm</h3><p>启动这三个软件，分布运行如下命令，可以看到分布的进程权限用户所属：</p><pre><code>ps -aux | grep nginx# 父进程：root    子进程：nginx （在nginx.conf中有一行 “user nginx”）ps -aux | grep mysql# 父进程：rootps -aux | grep php-fpm# 父进程：root    子进程：apache</code></pre><p>怎样改比较好呢？</p><p>建议：php-fpm 和 nginx 都运行在 nginx 用户下，同时网站目录 www 设置为 ftp 用户，nginx组，以后碰到要写入文件的地方，手动再把需要写入的目录设置组可写权限。</p><p>修改方式如下：</p><pre><code># 打开 /etc/php-fpm.d/www.conf，修改user = nginx    # 原本是 apachegroup = nginx   # 原本是 apache</code></pre><p>然后新建一个 ftp ，即可用 ftp 账户来管理网站。</p><h3 id="6-2-新建-FTP-账户"><a href="#6-2-新建-FTP-账户" class="headerlink" title="6.2 新建 FTP 账户"></a>6.2 新建 FTP 账户</h3><h4 id="6-2-1-vsftp-的安装和配置"><a href="#6-2-1-vsftp-的安装和配置" class="headerlink" title="6.2.1 vsftp 的安装和配置"></a>6.2.1 vsftp 的安装和配置</h4><p>先安装 <code>vsftp</code>，下面介绍一下配置文件。</p><p>有一个需要了解的地方：<a href="https://www.cnblogs.com/kuliuheng/p/3209744.html" target="_blank" rel="noopener">FTP 的主动模式和被动模式</a></p><p><strong>1. /etc/vsftpd/vsftpd.conf</strong></p><p>主要的配置文件</p><pre><code># 使用本地时间use_localtime=YES# 支持被动模式，一定要设置为YES，不设置这个可能无法读取目录pasv_enable=YES# 设置被动模式的的连接端口，使用阿里云的同学请去后台开启对应端口pasv_min_port=65400pasv_max_port=65410# 解决OOPS的问题allow_writeable_chroot=YES# 新建目录或文件的默认权限local_umask=002  #（对应775）# 只允许 /etc/passwd 中的的账号以实体用户方式登录local_enable=YES# 是否开启 chroot，两个一起作用chroot_local_user=YESchroot_list_enable=YES# chroot_list_enable=YES 时才生效，此文件中的账户不会被 chroot，一行一个账号，需手动新建chroot_list_file=/etc/vsftpd/chroot_list# 可使用FTP服务的账户控制# 开启这项功能userlist_enable=YES# YES时为黑名单，NO时为白名单userlist_deny=NO# 名单文件，一行一个账户userlist_file=/etc/vsftpd/user_list# 是否允许匿名登录，默认为 YESanonymous_enable=NO# 默认以 nobody 用户作为服务执行者，提高安全性nopriv_user=nobody</code></pre><p>以上的建议都设置了，没有的补上，不是的就修改。</p><blockquote><p>①当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。<br>②当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。<br>③当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。<br>④当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。</p></blockquote><p><strong>2. /etc/vsftpd/ftpusers</strong></p><p>列在这里面的用户是无法使用 ftp 的，里面已经包含了大多数的系统账户。同时也是你禁止一个账号 ftp 权限的最快方法。</p><h4 id="6-2-2-新建一个-ftp-账户"><a href="#6-2-2-新建一个-ftp-账户" class="headerlink" title="6.2.2 新建一个 ftp 账户"></a>6.2.2 新建一个 ftp 账户</h4><pre><code># 新建账户useradd -d /data/www -s /sbin/nologin admin# 更改密码passwd admin</code></pre><h4 id="6-2-3-测试连接"><a href="#6-2-3-测试连接" class="headerlink" title="6.2.3 测试连接"></a>6.2.3 测试连接</h4><p>主动模式需要 20/21 端口，被动模式需要设置配置文件中几个 <code>pasv</code> 字段的属性。</p><h2 id="7-防火墙"><a href="#7-防火墙" class="headerlink" title="7. 防火墙"></a>7. 防火墙</h2><p>CentOS7 中有 firewalld 和 iptables 两种防火墙，firewalld 可以看成是 iptables 的替代品，所以接下来主要介绍 firewalld。</p><p>我暂时没开启这服务，找了几个详细配置的文档。</p><p><a href="https://havee.me/linux/2015-01/using-firewalls-on-centos-7.html" target="_blank" rel="noopener">firewalld 详细设置1</a><br><a href="http://blog.csdn.net/chris_111x/article/details/52313797" target="_blank" rel="noopener">firewalld 详细设置2</a></p><pre><code class="shell"># 查看状态systemctl status firewalld# 开启systemctl start firewalld# 开机启动systemctl enable firewalld# 开启端口：# --zone 作用域 # --add-port=80/tcp 添加端口，格式为：端口/通讯协议# --permanent 永久生效，没有此参数重启后失效firewall-cmd --zone=public --add-port=80/tcp --permanent# 查看所有 zone 为 public 的端口firewall-cmd --zone=dmz --list-ports# 重启防火墙firewall-cmd --reload</code></pre><h2 id="8-几个小坑"><a href="#8-几个小坑" class="headerlink" title="8. 几个小坑"></a>8. 几个小坑</h2><p><strong>1. Hyper-V 新建虚拟机时有一个选择第几代的选项，请选择第一代，否则启动不了。</strong></p><p><strong>2. 阿里云有端口保护，需要用到端口时还要到阿里云后台去打开。</strong></p><h1 id="四、常用命令和配置文件路径"><a href="#四、常用命令和配置文件路径" class="headerlink" title="四、常用命令和配置文件路径"></a>四、常用命令和配置文件路径</h1><h2 id="1-配置文件路径"><a href="#1-配置文件路径" class="headerlink" title="1. 配置文件路径"></a>1. 配置文件路径</h2><p>数据库存放路径：/data/mysql<br>网站存放路径：/data/www<br>phpmyadmin 文件存放路径：/data/www/phpmyadmin<br>nginx 配置文件路径：/etc/nginx/nginx.conf<br>nginx 子域名配置文件：<br>mysql 配置文件路径：/etc/my.cnf<br>php 配置文件路径：/etc/php.ini<br>vsftpd 配置文件路径：/etc/vsftpd 目录</p><h2 id="2-常用服务重启"><a href="#2-常用服务重启" class="headerlink" title="2. 常用服务重启"></a>2. 常用服务重启</h2><p>systemctl status\restart\start\stop mysqld\php-fpm\nginx\vsftpd</p><h2 id="3-日志文件"><a href="#3-日志文件" class="headerlink" title="3. 日志文件"></a>3. 日志文件</h2><p>请看配置文件中设置的路径。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用命令&amp;基础知识</title>
      <link href="/2018/02/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/02/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>Linux 使用过程中，经常有一些命令或者其他一些细节，有时候搜到了但是因为用的频率不高总忘。所以单独开一篇文章来纪录我经常忘的一些命令和细节，仅供自己快速翻阅，勿喷。</p><h1 id="一、命令"><a href="#一、命令" class="headerlink" title="一、命令"></a>一、命令</h1><h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h2><h3 id="1-1-搜索命令-——-grep-了解更多"><a href="#1-1-搜索命令-——-grep-了解更多" class="headerlink" title="1.1 搜索命令 —— grep 了解更多"></a>1.1 搜索命令 —— grep <a href="http://man.linuxde.net/grep" target="_blank" rel="noopener">了解更多</a></h3><p>一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>使用样例：</p><pre><code>// 从结果中搜apt list | grep python// 从文件中搜grep match_pattern file_namegrep &#39;temporary password&#39; /var/log/mysqld.log</code></pre><h3 id="1-2-md5sum-amp-sha256sum"><a href="#1-2-md5sum-amp-sha256sum" class="headerlink" title="1.2 md5sum &amp; sha256sum"></a>1.2 md5sum &amp; sha256sum</h3><p>文件校验</p><pre><code>// MD5校验md5sum /path/filename// SHA-256校验sha256sum /path/filename</code></pre><h3 id="1-3-source-bashrc"><a href="#1-3-source-bashrc" class="headerlink" title="1.3 source ~/.bashrc"></a>1.3 source ~/.bashrc</h3><p>刷新全局变量的设置</p><pre><code>source ~/.bashrc</code></pre><h3 id="1-4-安装软件"><a href="#1-4-安装软件" class="headerlink" title="1.4 安装软件"></a>1.4 安装软件</h3><p><strong>.deb文件</strong></p><pre><code>sudo dpkg -i 软件包名.deb</code></pre><p><strong>.rmp文件</strong></p><pre><code>// 转换为 .deb文件sudo alien package_file.rpm</code></pre><p><strong>.tar.gz文件</strong><br>把文件解压缩到你想安装的目录，然后在根目录下或者 <code>bin</code> 一般会有一个 <code>.sh</code> 文件用来安装。</p><h3 id="1-5-who"><a href="#1-5-who" class="headerlink" title="1.5 who"></a>1.5 who</h3><p>查看当前有哪些用户在线。</p><h3 id="1-6-ps-aux"><a href="#1-6-ps-aux" class="headerlink" title="1.6 ps -aux"></a>1.6 ps -aux</h3><p>查看当前所有任务。</p><h3 id="1-7-service-network-restart-systemctl-restart-network"><a href="#1-7-service-network-restart-systemctl-restart-network" class="headerlink" title="1.7 service network restart \ systemctl restart network"></a>1.7 service network restart \ systemctl restart network</h3><p>重启网络服务。</p><h3 id="1-8-ip-addr"><a href="#1-8-ip-addr" class="headerlink" title="1.8 ip addr"></a>1.8 ip addr</h3><p>查看IP地址。</p><h3 id="1-9-查找已安装的软件-文件位置"><a href="#1-9-查找已安装的软件-文件位置" class="headerlink" title="1.9 查找已安装的软件\文件位置"></a>1.9 查找已安装的软件\文件位置</h3><p><strong>rpm</strong></p><pre><code class="shell">#查询已安装的以 mysql 开头的包rpm  -qa mysql*#查询已安装的 mysql 包rpm -qa | grep mysql</code></pre><p><strong>yum</strong></p><pre><code class="shell"># 列出已经安装好的的包yum list | grep installed</code></pre><p><strong>whereis</strong></p><pre><code class="shell"># 有时候可以借助查找文件的方式找到对应包的路径whereis mysql</code></pre><p><strong>find</strong></p><pre><code class="shell"># find 查找路径 查找参数# 在根目录下查找以.conf结尾的文件find / -name *.conf</code></pre><p><strong>locate</strong></p><pre><code class="shell">locate 查找的文件</code></pre><p><strong>ps</strong></p><pre><code class="shell"># 可以通过查找进程的方法找到对应的包的路径ps -ef|grep mysql# 可以简写成pgrep mysql</code></pre><h3 id="1-10-CentOS-的包管理-——-yum"><a href="#1-10-CentOS-的包管理-——-yum" class="headerlink" title="1.10 CentOS 的包管理 —— yum"></a>1.10 CentOS 的包管理 —— yum</h3><p>软件的安装有 <code>rpm</code>、<code>yum</code> 和编译安装三种方法，<code>yum</code> 安装最为简单，因为它可以自动解决包之间的依赖关系。</p><p><strong>1.13.1 包的查找和安装</strong></p><pre><code class="shell"># 从源中查找可使用的包yum list 包名yum search 包关键字 #这个的区别在于会匹配到所有含关键字的包# 从源中安装指定的包yum install 包名</code></pre><p><strong>1.13.2 源的更换</strong></p><pre><code class="shell"># 备份源cd /etc/yum.repos.d/mv CentOS-Base.repo CentOS-Base.repo_bak# 更改源wget -O /etc/yum.repos.d/CentOS-Base.repo 源地址# 清除缓存yum clean allyum makecache# 查看设置好的源yum repolist</code></pre><h3 id="1-11-pwd"><a href="#1-11-pwd" class="headerlink" title="1.11 pwd"></a>1.11 pwd</h3><p>查看当前所在路径。</p><h3 id="1-12-设置开机启动，重启，启动-——-systemctl"><a href="#1-12-设置开机启动，重启，启动-——-systemctl" class="headerlink" title="1.12 设置开机启动，重启，启动 —— systemctl"></a>1.12 设置开机启动，重启，启动 —— systemctl</h3><table><thead><tr><th>任务</th><th>旧指令</th><th>新指令</th></tr></thead><tbody><tr><td>使某服务自动启动</td><td>chkconfig –level 3 httpd on</td><td>systemctl enable httpd.service</td></tr><tr><td>使某服务不自动启动</td><td>chkconfig –level 3 httpd off</td><td>systemctl disable httpd.service</td></tr><tr><td>检查服务状态</td><td>service httpd status</td><td>systemctl status httpd.service</td></tr><tr><td>显示所有已启动的服务</td><td>chkconfig –list</td><td>systemctl list-units –type=service</td></tr><tr><td>启动某服务</td><td>service httpd start</td><td>systemctl start httpd.service</td></tr><tr><td>停止某服务</td><td>service httpd stop</td><td>systemctl stop httpd.service</td></tr><tr><td>重启某服务</td><td>service httpd restart</td><td>systemctl restart httpd.service</td></tr></tbody></table><pre><code class="shell"># 查看所有 systemd 服务systemctl list-unit-files</code></pre><h3 id="1-13-压缩与解压"><a href="#1-13-压缩与解压" class="headerlink" title="1.13 压缩与解压"></a>1.13 压缩与解压</h3><h4 id="zip-文件"><a href="#zip-文件" class="headerlink" title="zip 文件"></a>zip 文件</h4><pre><code># 安装软件包zipyum list zip# 压缩，-q 表示不显示中间输出，-R表示递归压缩zip -q -r html.zip /home/Blinux/html#解压unzip test.zip</code></pre><h4 id="tar-文件"><a href="#tar-文件" class="headerlink" title="tar 文件"></a>tar 文件</h4><pre><code>-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</code></pre><p>几种 tar 文件</p><pre><code>tar -cvf log.tar log2012.log    仅打包，不压缩！ tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 </code></pre><p>在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加j选项，则以.tar.bz2来作为tar包名。</p><p><strong>压缩</strong></p><pre><code>tar -zxvf /opt/soft/test/log.tar.gz</code></pre><p><strong>查看压缩包内容</strong></p><pre><code>tar -ztvf log.tar.gz</code></pre><p><strong>解压</strong></p><pre><code># 解压部分文件tar -zxvf /opt/soft/test/log30.tar.gz log2013.log# 解压全部tar -zxvf log30.tar.g</code></pre><p><strong>其实你只要记以下这个即可</strong></p><pre><code>压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称查　询：tar -jtv -f filename.tar.bz2解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></pre><hr><h2 id="2-不常用命令"><a href="#2-不常用命令" class="headerlink" title="2. 不常用命令"></a>2. 不常用命令</h2><h3 id="2-1-uname-r"><a href="#2-1-uname-r" class="headerlink" title="2.1 uname -r"></a>2.1 uname -r</h3><p>查看内核版本。</p><h3 id="2-2-date、cal"><a href="#2-2-date、cal" class="headerlink" title="2.2 date、cal"></a>2.2 date、cal</h3><p>查看日期和日历。</p><h3 id="2-3-shutdown、-sbin-poweroff、init-0"><a href="#2-3-shutdown、-sbin-poweroff、init-0" class="headerlink" title="2.3 shutdown、/sbin/poweroff、init 0"></a>2.3 shutdown、/sbin/poweroff、init 0</h3><p>关机、重启。</p><pre><code class="shell"># 关机shutdown -h # 马上关机shutdown -h now # 重启shutdown -rrebootinit 6</code></pre><h3 id="2-4-sync"><a href="#2-4-sync" class="headerlink" title="2.4 sync"></a>2.4 sync</h3><p>将数据同步写入硬盘，避免重启或关机时的数据丢失。</p><h1 id="二、技巧"><a href="#二、技巧" class="headerlink" title="二、技巧"></a>二、技巧</h1><h2 id="1-键位"><a href="#1-键位" class="headerlink" title="1. 键位"></a>1. 键位</h2><h3 id="1-1-Tab-键"><a href="#1-1-Tab-键" class="headerlink" title="1.1 Tab 键"></a>1.1 Tab 键</h3><p>按一下补齐命令，按两下显示可选择的命令或文件。</p><h3 id="1-2-Ctrl-C"><a href="#1-2-Ctrl-C" class="headerlink" title="1.2 Ctrl + C"></a>1.2 Ctrl + C</h3><p>中止当前命令。</p><h3 id="1-3-Ctrl-D"><a href="#1-3-Ctrl-D" class="headerlink" title="1.3 Ctrl + D"></a>1.3 Ctrl + D</h3><p>相当于 exit 命令。</p><hr><h2 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h2><h3 id="2-1-man-info"><a href="#2-1-man-info" class="headerlink" title="2.1 man\info"></a>2.1 man\info</h3><p><code>man + 你想要查询的命令</code> 就会显示说吗，按 <code>q</code> 可返回。<code>\stirng</code> 和 <code>?string</code> 分布向下和向上选择字符串。</p><h3 id="2-2-usr-share-doc-下存有众多软件包的说明文档"><a href="#2-2-usr-share-doc-下存有众多软件包的说明文档" class="headerlink" title="2.2 /usr/share/doc 下存有众多软件包的说明文档"></a>2.2 /usr/share/doc 下存有众多软件包的说明文档</h3><h1 id="三、软件"><a href="#三、软件" class="headerlink" title="三、软件"></a>三、软件</h1><h2 id="1-系统常用软件"><a href="#1-系统常用软件" class="headerlink" title="1. 系统常用软件"></a>1. 系统常用软件</h2><h3 id="1-1-gcc"><a href="#1-1-gcc" class="headerlink" title="1.1 gcc"></a>1.1 gcc</h3><p>用于编译C。</p><h3 id="1-2-wget"><a href="#1-2-wget" class="headerlink" title="1.2 wget"></a>1.2 wget</h3><p>wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议 下载，并可以使用 HTTP 代理。</p><h3 id="1-3-make"><a href="#1-3-make" class="headerlink" title="1.3 make"></a>1.3 make</h3><p>用于编译和安装。</p><h3 id="1-4-net-tools-iproute2-操作"><a href="#1-4-net-tools-iproute2-操作" class="headerlink" title="1.4 net-tools \ iproute2 操作"></a>1.4 net-tools \ iproute2 <a href="http://blog.jobbole.com/97270/" target="_blank" rel="noopener">操作</a></h3><p>iproute2的出现旨在从功能上取代net-tools</p><h3 id="1-5-rz-和-sz"><a href="#1-5-rz-和-sz" class="headerlink" title="1.5 rz 和 sz"></a>1.5 rz 和 sz</h3><p>用于通过命令行下载和上传文件，包名为 <code>lrzsz</code>，<code>rz</code> 为上传， <code>sz</code> 为下载。</p><h3 id="1-6-ftp-和-lftp"><a href="#1-6-ftp-和-lftp" class="headerlink" title="1.6 ftp 和 lftp"></a>1.6 ftp 和 lftp</h3><p>用于访问 ftp 服务器，<code>yum install ftp</code> 和 <code>yum install lftp</code> 安装。</p><h3 id="1-7-vsftp"><a href="#1-7-vsftp" class="headerlink" title="1.7 vsftp"></a>1.7 vsftp</h3><p>用户设置 ftp 账户，包名为 <code>vsftpd</code>，安装后设置开机启动然后启动。</p><h1 id="四、重要系统文件"><a href="#四、重要系统文件" class="headerlink" title="四、重要系统文件"></a>四、重要系统文件</h1><h2 id="1-账户、组相关"><a href="#1-账户、组相关" class="headerlink" title="1. 账户、组相关"></a>1. 账户、组相关</h2><p>三个重要文件：</p><p><strong>/etc/passwd</strong>: 存储账户的文件。</p><p><strong>/etc/shadow</strong>: 存储密码的文件。</p><p><strong>/etc/group</strong>: 存储组的文件。</p><p>关于权限：</p><p><strong>-rwxrwxrwx</strong>: 第一个字符的含意。</p><p>d —— 目录<br>- —— 文件<br>l —— 连接文件<br>b —— 可供存储的接口设备<br>c —— 串行端口设备，例如键盘和鼠标</p><h3 id="1-1-etc-passwd-介绍"><a href="#1-1-etc-passwd-介绍" class="headerlink" title="1.1 /etc/passwd 介绍"></a>1.1 /etc/passwd 介绍</h3><p>从其中取一行作为示例：</p><pre><code># ：作为分隔符，分成七个字段root:x:0:0:root:/root:/bin/bash</code></pre><p>七个字段分别为：</p><ol><li>账户名</li><li>密码：在以前 UNIX 的时候，密码是存在这的，但后来为了安全改了，这里现在一般都是 x</li><li>UID：0 是系统管理员，1~499 是系统账号，其中 1~99 为系统自行创建的系统账号，100~499 为用户有系统账号需要时可以使用的UID，500~65535 为可登陆账号。</li><li>GID</li><li>用户信息说明</li><li>主文件夹</li><li>Shell：/bin/bash 表示能用 shell 登陆，/sbin/nologin 表示不能用 shell 登陆。</li></ol><h3 id="1-2-etc-shadow-介绍"><a href="#1-2-etc-shadow-介绍" class="headerlink" title="1.2 /etc/shadow 介绍"></a>1.2 /etc/shadow 介绍</h3><p>从中取几行作为示例：</p><pre><code># ：作为分隔符，分成九个字段root:$6$XE6mMo/$ugMPYPDW9.hv7royLYKwKg0EkBBzhT2Od.SH0KpDTI7ixp5Z4kTGm:17599:0:99999:7:::bin:*:17110:0:99999:7:::daemon:*:17110:0:99999:7:::</code></pre><ol><li>账号名称</li><li>密码</li><li>最近更动密码的日期：从1970年1月1日以来的天数。</li><li>密码不可被更动的天数（与第3个字段相比）</li><li>密码需要重新更改的天数（与第3个字段相比）</li><li>密码需要更改期限前的警告天数（与第5个字段相比）</li><li>密码过期后的账号宽限时间（密码失效日）（与第5个字段相比）：密码有效期为第三个字段 + 第五个字段。如果过期用户没有改密码，会在在用户登录的时候提醒更改密码之后才能操作，这段时间就是宽限时间。</li><li>账号失效日期：账号失效日期，无论前面的密码字段是怎么设置的密码有效期，只要超过这个日期，账号就失效了。</li><li>保留字段</li></ol><h3 id="1-3-etc-group-介绍"><a href="#1-3-etc-group-介绍" class="headerlink" title="1.3 /etc/group 介绍"></a>1.3 /etc/group 介绍</h3><p>依旧从文件中取几行来做示例：</p><pre><code># ：作为分隔符，分成四个字段root:x:0:bin:x:1:daemon:x:2:</code></pre><ol><li>用户组名称</li><li>用户组密码：和前面一样，密码已经移动到 /etc/gshadow 去了，这里只有一个 x</li><li>GID</li><li>此用户组支持的账号名称: 某个账号想要加入此用户组时，填入这个字段，多个账户用逗号隔开</li></ol><p><strong>次要用户组和初始用户组</strong><br>初始用户组是创建账号时自动拥有的，不需要填入 /etc/group 的第四个字段。填入 /etc/group 的用户属于<strong>次要用户组</strong>。</p><p><strong>有效用户组</strong><br>那当一个用户属于两个用户组并新建了一个文件或者文件夹时，这个文件或文件夹的所属组到底是哪个？<br>这就涉及到<strong>有效用户组</strong>的概念了，通过 <code>groups</code> 命令可以列出当前用户的所属组，其中排在第一个的就是有效用户组，有效用户组会是当前用户新建文件或者文件夹的所属组。</p><p><strong>更改有效用户组</strong><br>如何更改有效用户组呢？可以使用 <code>newgrp</code> 命令，当前用户输入 <code>newgrp 所属的另一个用户组</code>，即可把当前用户组更改为所选择的用户组。<br>不过值得注意的是：这个是通过新建一个 Shell 来完成的，命令运行完后，你可以用 <code>exit</code> 回到先前的 Shell。</p><h3 id="1-4-etc-gshadow-介绍"><a href="#1-4-etc-gshadow-介绍" class="headerlink" title="1.4 /etc/gshadow 介绍"></a>1.4 /etc/gshadow 介绍</h3><p>依旧从文件中取几行来做示例：</p><pre><code># ：作为分隔符，分成四个字段root:::bin:::root,binutempter:!::</code></pre><ol><li>用户组名</li><li>密码列，如果为！表示为无合法密码，所以无用户组管理员</li><li>用户组管理员账号</li><li>用户组的所属账号</li></ol><p>这个文件的主要作用是创建组管理员，例如有些只能使用 root 账户管理的事务，可能很多时候 root 账户比较忙碌，就可以添加一个用户组来解决这个问题。不过由于现在有 sudo 命名，所以这个组管理员的功能已经很少使用了。</p><h1 id="五、常用操作"><a href="#五、常用操作" class="headerlink" title="五、常用操作"></a>五、常用操作</h1><h2 id="1-账户、组操作"><a href="#1-账户、组操作" class="headerlink" title="1. 账户、组操作"></a>1. 账户、组操作</h2><h3 id="1-1-账户新建-——-useradd"><a href="#1-1-账户新建-——-useradd" class="headerlink" title="1.1 账户新建 —— useradd"></a>1.1 账户新建 —— useradd</h3><p>通过这个命令可以新建一个账户，有以下这些常用参数：</p><ol><li>[-d 目录绝对路径]：指定某个目录成为主文件夹；</li><li>[-r]：创建一个系统账户，系统账户默认不会创建用户文件夹；</li><li>[-s shell]： shell 可选 /bin/bash 和 /sbin/nologin</li></ol><pre><code># 创建一个账户，新建的账户没有密码，还无法登录useradd Test</code></pre><p>运行上面的命令会创建一个叫做 <code>Test</code> 的账户，并创建一个 /home/Test 的用户主文件夹，权限为700.同时还会创建一个和用户名一样的组。</p><p>然后你查看 /etc/passwd 和 /etc/goup 你会发现，密码字段的一些属性，已经默认规定好了，这个默认属性是哪里来的呢？<br>答案就在 /etc/default/useradd 这个文件中。</p><h3 id="1-2-账户密码修改-——-passwd"><a href="#1-2-账户密码修改-——-passwd" class="headerlink" title="1.2 账户密码修改 —— passwd"></a>1.2 账户密码修改 —— passwd</h3><p>密码的修改有两种途径，一种是用 root 账户修改指定账户的密码，一种是账户登录后自己修改自己的密码。</p><pre><code># root 修改其他账户的密码passwd Test# 账户修改自己的密码，账户修改自己的密码时要先输入旧密码passwd</code></pre><h3 id="1-3-账户删除-——-userdel"><a href="#1-3-账户删除-——-userdel" class="headerlink" title="1.3 账户删除 —— userdel"></a>1.3 账户删除 —— userdel</h3><p>建议只有在账号真的确定不要使用的时候再删除，否则可以用各种方法让账户先失效。</p><pre><code># r 参数连同主文件夹一起删除userdel -r username</code></pre><p>一般账号使用一段时间后总会生成一些属于这个账号的文件，这些文件无法通过上面的命令删除，所以可以通过 <code>find / -user username</code> 找出来一一删除。</p><h3 id="1-4-账户修改-——-chsh-usermod"><a href="#1-4-账户修改-——-chsh-usermod" class="headerlink" title="1.4 账户修改 —— chsh \ usermod"></a>1.4 账户修改 —— chsh \ usermod</h3><p>使用这个命令可以修改账户的可用shell，有两个参数。</p><pre><code># 列出系统可用的 shellchsh -l# 修改当前用户的 shellchsh -s /sbin/nologin# usermod 也可以usermod -s /bin/bash username# 添加用户的附加群组usermod -G groupname username</code></pre><h2 id="2-文件所属、权限操作"><a href="#2-文件所属、权限操作" class="headerlink" title="2. 文件所属、权限操作"></a>2. 文件所属、权限操作</h2><h2 id="3-文档新建操作"><a href="#3-文档新建操作" class="headerlink" title="3. 文档新建操作"></a>3. 文档新建操作</h2><h3 id="3-1-nano"><a href="#3-1-nano" class="headerlink" title="3.1 nano"></a>3.1 nano</h3><p>打开一个文件，不存在则新建 —— nano<br><code>F1</code> 打开帮助文档。</p><h3 id="3-2-vi"><a href="#3-2-vi" class="headerlink" title="3.2 vi"></a>3.2 vi</h3><h3 id="3-3-touch"><a href="#3-3-touch" class="headerlink" title="3.3 touch"></a>3.3 touch</h3><h1 id="六、答疑解惑"><a href="#六、答疑解惑" class="headerlink" title="六、答疑解惑"></a>六、答疑解惑</h1><h3 id="1-apt-和-apt-get-有什么区别？-了解更多"><a href="#1-apt-和-apt-get-有什么区别？-了解更多" class="headerlink" title="1. apt 和 apt-get 有什么区别？ 了解更多"></a>1. <code>apt</code> 和 <code>apt-get</code> 有什么区别？ <a href="https://www.sysgeek.cn/apt-vs-apt-get/" target="_blank" rel="noopener">了解更多</a></h3><blockquote><p>简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。另外 apt 命令可以在某些操作时显示进度条。以上应该是最直观的解释。</p></blockquote><p>而 <code>apt-cache</code> 和 <code>apt-config</code> 是低级但含有众多功能的命令，不过使用频率很低。</p><h3 id="2-deepin-桌面：对一些安装后没有图标的软件如何新建一个图标"><a href="#2-deepin-桌面：对一些安装后没有图标的软件如何新建一个图标" class="headerlink" title="2. deepin 桌面：对一些安装后没有图标的软件如何新建一个图标"></a>2. deepin 桌面：对一些安装后没有图标的软件如何新建一个图标</h3><p>管理员权限打开 <code>/usr/share/applications</code> ,新建 <code>名字.desktop</code>,写入：</p><pre><code>[Desktop Entry] Type=Application Name=Pycharm GenericName=Pycharm3 Comment=Pycharm3:The Python IDE Exec=sh /home/sky/Application/pycharm-2017.3.3/bin/pycharm.sh   # 程序路径Icon=/home/sky/Application/pycharm-2017.3.3/bin/pycharm.png     # 图标路径Terminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development;</code></pre><h3 id="3-Linux-下各目录文件的作用"><a href="#3-Linux-下各目录文件的作用" class="headerlink" title="3. Linux 下各目录文件的作用"></a>3. Linux 下各目录文件的作用</h3><p>/bin 二进制可执行命令<br>/dev 设备特殊文件<br>/etc 系统管理和配置文件<br>/etc/rc.d 启动的配置文件和脚本<br>/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示<br>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序<br>/tmp 公用的临时文件存储点<br>/root 系统管理员的主目录（呵呵，特权阶级）<br>/mnt 系统提供这个目录是让用户临时挂载其他的文件系统。<br>/lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里<br>/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/var 某些大文件的溢出区，比方说各种服务的日志文件<br>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：<br>/usr/x11r6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快查-Python</title>
      <link href="/2018/02/13/%E5%BF%AB%E6%9F%A5-Python/"/>
      <url>/2018/02/13/%E5%BF%AB%E6%9F%A5-Python/</url>
      <content type="html"><![CDATA[<p>初学编程的时候就学过 Python 了，当时写了几个模拟登陆获取成绩的接口，后来一直用的 PHP，过了这么久现在回想基本记不起了，可能当时写几个接口，学的是在太浅了。最近开始学习人工智能，需要用到 Python，就复习复习然后深入吧。本篇不能当做 python 学习的教程，只能用于本人快速翻阅。</p><h1 id="一、学习准备"><a href="#一、学习准备" class="headerlink" title="一、学习准备"></a>一、学习准备</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰老师的Python教程</a>     很多代码样例参考自此</li><li><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Python</a></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>系统：Linux-<a href="https://www.deepin.org/" target="_blank" rel="noopener">deepin</a></li><li>Python环境配置：<a href="https://www.anaconda.com/download/#linux" target="_blank" rel="noopener">Anaconda</a></li></ul><p>注：deepin 中自带了 python2.7 和 python3.5 但是如果贸然修改或升级系统自带的 python 版本可能会导致系统问题，所以建议用 <code>Anaconda</code> 安装 python 的开发环境。</p><h3 id="1-Anaconda-安装"><a href="#1-Anaconda-安装" class="headerlink" title="1. Anaconda 安装"></a>1. Anaconda 安装</h3><p><a href="https://docs.anaconda.com/anaconda/install/linux" target="_blank" rel="noopener">官方安装指导</a></p><p>最后输入 <code>anaconda-navigator</code> 进入 <a href="https://docs.anaconda.com/anaconda/navigator/" target="_blank" rel="noopener">Anaconda Navigator</a>。</p><h3 id="2-设置国内镜像"><a href="#2-设置国内镜像" class="headerlink" title="2. 设置国内镜像"></a>2. 设置国内镜像</h3><pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes</code></pre><h3 id="3-新建一个环境"><a href="#3-新建一个环境" class="headerlink" title="3. 新建一个环境"></a>3. 新建一个环境</h3><p>打开 <code>Anaconda Navigator</code>，在 <code>environments</code> 一栏中已经有一个 <code>root</code> 环境，这个环境是你下载是选择的 <code>Anaconda</code> 的版本，如果你选择的是 2.7 的版本那个这个环境的 python 版本就是 python 2.7 。</p><blockquote><p>新建一个环境：点击下面 create ————&gt; 输入环境名字 ————&gt; 选择 python 版本 ————&gt; 确定</p></blockquote><p><strong>用命令行的方式新建一个环境</strong></p><pre><code># 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）conda create --name python34 python=3.4# 安装好后，使用activate激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Mac# 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH# 此时，再次输入python --version# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境# 如果想返回默认的python 2.7环境，运行deactivate python34 # for Windowssource deactivate python34 # for Linux &amp; Mac# 删除一个已有的环境conda remove --name python34 --all</code></pre><h3 id="4-conda-的包管理命令"><a href="#4-conda-的包管理命令" class="headerlink" title="4. conda 的包管理命令"></a>4. conda 的包管理命令</h3><pre><code># 安装scipyconda install scipy# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库）# 查看已经安装的packagesconda list# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy# 更新conda，保持conda最新conda update conda# 更新anacondaconda update anaconda# 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本</code></pre><h3 id="5-Pycharm-中使用-Anaconda"><a href="#5-Pycharm-中使用-Anaconda" class="headerlink" title="5. Pycharm 中使用 Anaconda"></a>5. Pycharm 中使用 Anaconda</h3><blockquote><p>File ——&gt; settings ————&gt; Project Interpreter ————&gt; Add Local ————&gt; 添加 Anaconda 环境（这里你命名一个，就会自动在 Anaconda 中新建一个环境）</p></blockquote><h3 id="6-VS-code-中使用-Anaconda"><a href="#6-VS-code-中使用-Anaconda" class="headerlink" title="6. VS code 中使用 Anaconda"></a>6. VS code 中使用 Anaconda</h3><ul><li>安装扩展中安装量最高的扩展</li><li>输入命令 <code>Python: Select Interpreter</code> 选择 Anaconda 配置的环境</li></ul><h3 id="7-激活环境"><a href="#7-激活环境" class="headerlink" title="7. 激活环境"></a>7. 激活环境</h3><pre><code>// 激活环境source activate py364// 进入 python 交互模式python</code></pre><h3 id="8-详细教程"><a href="#8-详细教程" class="headerlink" title="8. 详细教程"></a>8. <a href="https://www.zhihu.com/question/58033789" target="_blank" rel="noopener">详细教程</a></h3><h1 id="二、如何运行一个程序"><a href="#二、如何运行一个程序" class="headerlink" title="二、如何运行一个程序"></a>二、如何运行一个程序</h1><h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><p>交互模式下，每一行变成如下的样子：<code>&gt;&gt;&gt;</code></p><pre><code>// 交互模式下简单运行&gt;&gt;&gt; 100 + 200300</code></pre><h2 id="命令行执行文件"><a href="#命令行执行文件" class="headerlink" title="命令行执行文件"></a>命令行执行文件</h2><p>和其他脚本一样</p><pre><code>// cd 到该目录下$ python hello.py</code></pre><h1 id="三、代码编写"><a href="#三、代码编写" class="headerlink" title="三、代码编写"></a>三、代码编写</h1><h2 id="a-语法表示"><a href="#a-语法表示" class="headerlink" title="a) 语法表示"></a>a) 语法表示</h2><ol><li>使用 <code>#</code> 作为注释符，且可以不用分号来结束一行；</li><li>使用 <code>:</code> 作为代码块开始，并以后面缩进的内容为代码块内容；</li><li>浮点数的科学计数法： $1.23\times10^9$ 就是 <code>1.23e9</code> ，或者 <code>12.3e8</code>，0.000012 可以写成 <code>1.2e-5</code>;</li><li>可以在字符串前面加上 <code>r</code>, 表示默认不转义,例如 <code>print(r&#39;\\\t\\&#39;)</code>,输出 <code>\\\t\\</code>;</li><li>多行字符串: 可以用 <code>&#39;&#39;&#39;第一行内容[换行]第二行内容[换行]第三行内容&#39;&#39;&#39;</code> 来表示多行内容;</li><li>布尔值: <code>True</code> 、<code>False</code> (注意首字母大写);</li><li>布尔运算: <code>and</code> (与: 全真为真)、<code>or</code> (或: 存真为真) 和 <code>not</code> (非);</li><li>空值: <code>None</code>;</li><li>常量: 全大写为常量,比如 <code>PI = 3.1415926535</code>, 这并不像其他语言一样是锁死的,你可以改变;</li><li>除法: python 中有两种除法,<strong>除法<code>/</code></strong>和<strong>地板除<code>//</code></strong>，除法无论能不能整除都会取浮点数，地板除无论能不能整除都会取整数；</li><li><p>python 文件的字符编码</p><pre><code class="python">#!/usr/bin/env python3# -*- coding: utf-8 -*-</code></pre><p>第一行告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；<br>第二行告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码；</p></li><li>占位符：和C语言类似，格式为：<code>&#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)</code>，一个占位符时，括号可以省略，另外可以两个 <code>%%</code> ，表示一个 <code>%</code>；</li><li>用 <code>elif</code> 而不是 <code>else if</code>；</li><li>用 <code>input()</code> 请求和读取用户的输入，返回字符串，python 中不能把整型和字符串进行比较；</li><li><p>循环语句：</p><pre><code class="python"># 例1names = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]for name in names:    print(name)#例2sum = 0for x in range(101):    sum = sum + xprint(sum)&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]# 例3n = 1while n &lt;= 100:    if n &gt; 10:          # 当n = 11时，条件满足，执行break语句        break           # break语句会结束当前循环    if n % 2 == 0:      # 如果n是偶数，执行continue语句        continue        # continue语句会直接继续下一轮循环，后续的print()语句不会执行    print(n)    n = n + 1print(&#39;END&#39;)</code></pre></li><li><p><code>str</code> 是不可变对象</p><pre><code>&gt;&gt;&gt; a = &#39;abc&#39;&gt;&gt;&gt; b = a.replace(&#39;a&#39;, &#39;A&#39;)&gt;&gt;&gt; b&#39;Abc&#39;&gt;&gt;&gt; a&#39;abc&#39;</code></pre></li><li><p>可以把函数名赋给一个变量</p><pre><code>&gt;&gt;&gt; a = abs     # 变量a指向abs函数&gt;&gt;&gt; a(-1)       # 所以也可以通过a调用abs函数1</code></pre></li><li><p>函数的定义：需要用到 <code>def</code>：</p><pre><code>def my_abs(x):    return abs(x)           # return None 可以简写为 return，若不写 return 则默认当做 return None    return x, x+1           # 可以同时返回多个值，实际上是返回了一个 tuplefrom abstest import my_abs  # 从 abstest.py 文件中导入 my_abs 函数if age &gt;= 18:    pass                    # 可以用 pass 作为空占位符而避免代码出错</code></pre></li><li><p>函数的可变参数：</p><pre><code>def calc(*numbers):     # 在参数前面加上一个 * 号，表示可以传入任意个参数    sum = 0    for n in numbers:        sum = sum + n * n    return sumnumbers = [1, 2, 3]     # 就算 numbers 是一个 list 或 tuplecacl(*numbers)          # 也可以这么调用</code></pre></li><li><p>关键字参数：</p><pre><code>def person(name, age, **kw):    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)&gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=extra[&#39;city&#39;], job=extra[&#39;job&#39;])name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}&gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **extra)name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}</code></pre></li><li>命名关键字参数</li></ol><h2 id="b-数据类型"><a href="#b-数据类型" class="headerlink" title="b) 数据类型"></a>b) 数据类型</h2><h3 id="1-python-中的“数组”"><a href="#1-python-中的“数组”" class="headerlink" title="1. python 中的“数组”"></a>1. python 中的“数组”</h3><p><strong>list：</strong></p><pre><code class="python">p = [&#39;asp&#39;, &#39;php&#39;]p[-1]               # 倒着取元素L = []              # 空listlen()               # 长度pop([i])            # 取末尾元素，或指定元素append()            # 插入到末尾insert(1, &#39;Jack&#39;)   # 插入到指定位置</code></pre><p><strong>tuple：</strong><br>相当于赋值后就无法改变值的 list</p><pre><code class="python">t = (1, 2)                  # 赋值用括号t = (1,)                    # 单个元素时，要这么写t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])  # 可变的 tuple</code></pre><p><strong>dict：</strong><br>相当于键值数组</p><pre><code class="python">d = {&#39;M&#39;: 95, &#39;B&#39;: 75, &#39;T&#39;: 85}     # 定义一个 dictd[&#39;M&#39;]                              # 取对应的值，注意 d[0] 会报错d[&#39;Thomas&#39;]                         # 取不存在的会报错&#39;Thomas&#39; in d                       # 判断是否存在，返回布尔值d.get(&#39;Thomas&#39;, [-1])               # 存在则返回值，不存在则返回None(并不显示)，或指定的值</code></pre><p><strong>set：</strong><br>一组key的集合，但不存储value，且key不能重复</p><pre><code>&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s{1, 2, 3}</code></pre><pre><code class="python">add(4)      # 添加remove(4)    # 移除</code></pre><h2 id="c-高级特性"><a href="#c-高级特性" class="headerlink" title="c) 高级特性"></a>c) 高级特性</h2><h3 id="1-切片"><a href="#1-切片" class="headerlink" title="1. 切片"></a>1. 切片</h3><p>可以用来截取 <code>list</code> 或 <code>tuple</code> 的元素。</p><pre><code class="python">L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]L[0:3]      # 索引 0 开始，到索引 3 为止，但不包括索引 3L[:3]       # 如果第一个索引是 0 ，可以省略 0L[-2:]      # 取倒数两个元素L[-2:-1]    # 取倒数一个元素L[:10:2]    # 前十个数，每两个取一个L[::5]      # 所有数，每五个取一个L[:]        # 原样复制一个(0, 1, 2, 3, 4, 5)[:3]      # tuple 的截取</code></pre><h3 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h3><p>可以用 Collection 模块的 Iterable 类型来判断该数据类型是否可以用 <code>for ... in ...</code> 迭代。</p><pre><code>&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)         # str是否可迭代true&gt;&gt;&gt; isinstance(x, str)                  # 判断 x 是不是字符串</code></pre><p>可以用内置函数 enumerate 把一个list变成索引-元素对</p><pre><code>for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):     # i 为索引，value 为值</code></pre><h3 id="3-列表生成式"><a href="#3-列表生成式" class="headerlink" title="3. 列表生成式"></a>3. 列表生成式</h3><p>可以非常方便的用一行代码生成列表</p><pre><code>&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]     # 还可以加上 if 判断[4, 16, 36, 64, 100]&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]           # 两层循环[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</code></pre><h3 id="4-生成器-Generator"><a href="#4-生成器-Generator" class="headerlink" title="4. 生成器 Generator"></a>4. 生成器 Generator</h3><p>把列表生成器的 <code>[]</code> 改成 <code>()</code> 即可，调用可以用 <code>next(g)</code> 或循环，建议用循环，因为 next 到了最后一个会报错。</p><pre><code>&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</code></pre><p>还可以用函数的方式构造生成器</p><pre><code class="python">def fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        yield b             # 一个函数中如果含有 yield ，那么它就是一个生成器        a, b = b, a + b        n = n + 1    return &#39;done&#39;f = fib(6)                  # 这样得到一个生成器对象</code></pre><h3 id="5-迭代器-Iterator"><a href="#5-迭代器-Iterator" class="headerlink" title="5. 迭代器 Iterator"></a>5. 迭代器 Iterator</h3><p>可以被 <code>next()</code> 函数不断调用并返回下一个值的对象,判断一个对象是不是迭代器：</p><pre><code>&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)    # 生成器都是迭代器对象True</code></pre><p>可以用 <code>iter()</code> 函数把<code>list</code>、<code>dict</code>、<code>str</code>等 <code>Iterable</code> 变成<code>Iterator</code>：</p><pre><code>&gt;&gt;&gt; isinstance(iter([]), Iterator)True</code></pre><h2 id="d-函数"><a href="#d-函数" class="headerlink" title="d) 函数"></a>d) 函数</h2><h3 id="1-函数名"><a href="#1-函数名" class="headerlink" title="1. 函数名"></a>1. 函数名</h3><p>函数名其实是个变量，可以赋值给其他的变量，甚至让函数名这个变量指向其他值，二使函数失效。可以通过 <code>__name__</code> 属性获得函数名字。</p><h3 id="2-map-reduce-filter-sorted"><a href="#2-map-reduce-filter-sorted" class="headerlink" title="2. map/ reduce / filter / sorted"></a>2. map/ reduce / filter / sorted</h3><p><strong>map</strong></p><pre><code class="python">r = map(函数名, Iterable)   # 循环 Iterable 中的值让函数名所指的函数处理并返回一个 Iterator（惰性）list(r)                     # 最后会把 Iterator 处理完并返回一个 list# 例子&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</code></pre><p><strong>reduce</strong></p><pre><code class="python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)   # 这里的等于符号是“等价于”的意思# 一个样例，看懂就理解了，lambda 可以理解成 python 中匿名函数的写法 from functools import reduceDIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}def char2num(s):    return DIGITS[s]def str2int(s):    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</code></pre><p><strong>filter</strong><br>用于过滤序列，参数和返回都与 map 类似，不同之处在于：filter 根据返回值布尔属性来决定元素的去留。</p><pre><code class="python">def is_odd(n):    return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果: [1, 5, 9, 15]</code></pre><p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p><p><strong>sorted</strong><br>sorted 能够让你用非常简单的代码实现较为复杂的逻辑</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])            # 普通排序[-21, -12, 5, 9, 36]&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)   # 添加函数处理[5, 9, -12, -21, 36]&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)    # 添加函数处理2[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)  # 逆序[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]</code></pre><h3 id="3-返回函数"><a href="#3-返回函数" class="headerlink" title="3. 返回函数"></a>3. 返回函数</h3><p>可以把函数作为返回值，在需要的时候再执行：</p><pre><code class="python">def lazy_sum(*args):    def sum():        ax = 0        for n in args:            ax = ax + n        return ax    return sum&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;&gt;&gt;&gt; f()25</code></pre><p><strong>闭包</strong><br>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p><h3 id="4-装饰器-Decorator"><a href="#4-装饰器-Decorator" class="headerlink" title="4. 装饰器 Decorator"></a>4. 装饰器 Decorator</h3><p>在代码运行期间动态增加功能的方式。理解有点复杂，建议看<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000" target="_blank" rel="noopener">原文</a>。</p><h3 id="5-偏函数"><a href="#5-偏函数" class="headerlink" title="5. 偏函数"></a>5. 偏函数</h3><p>可以设定参数的默认值，降低函数调用的难度。<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143184474383175eeea92a8b0439fab7b392a8a32f8fa000" target="_blank" rel="noopener">原文</a></p><h2 id="e-模块"><a href="#e-模块" class="headerlink" title="e) 模块"></a>e) 模块</h2><p>模块第一个需要解决的问题是冲突问题，python 中用模块和顶层包名的方法来防止冲突。一个顶层报名和模块的结构如下：</p><pre><code>mycompany ├─ web │  ├─ __init__.py │  ├─ utils.py │  └─ www.py ├─ __init__.py  # 这个是必须存在的文件，否则这个目录就会被当做普通目录，且其本身为一个模块，名为mycompany ├─ abc.py └─ xyz.py</code></pre><pre><code class="python">#!/usr/bin/env python3# -*- coding: utf-8 -*-&#39; a test module &#39;       # 任何模块的第一个字符串为模块注释，可用 __doc__ 访问__author__ = &#39;Michael Liao&#39;import sys              # 导入一个模块def test():    args = sys.argv    if len(args)==1:        print(&#39;Hello, world!&#39;)    elif len(args)==2:        print(&#39;Hello, %s!&#39; % args[1])    else:        print(&#39;Too many arguments!&#39;)if __name__==&#39;__main__&#39;:    # 这一行如果直接执行本文件则会运行，如果当做模块被导入不会运行    test()</code></pre><p><strong>作用域</strong><br>private 变量命名方式：<code>_xxx</code> 和 <code>__xxx</code> ，但这并不是限定死的，你完全可以应用而不报错，但最好不要。</p><p><strong>第三方模块</strong><br>python 用 <code>pip</code> 进行包管理：</p><pre><code>pip install Pillow  # 第三方包一般会在官网上注册，这样就可以这用直接引用</code></pre><h2 id="d-面向对象编程"><a href="#d-面向对象编程" class="headerlink" title="d) 面向对象编程"></a>d) 面向对象编程</h2><p><strong>class的定义</strong><br><code>Class</code> 的定义：括号中的 <code>object</code> 表示该类是从哪个类继承下来的，如果没有合适的类，就继承 <code>object</code>。</p><pre><code class="python">class Student(object):    def __init__(self, name, score):    # 可以这样定义必须填写的属性        self.name = name        self.__score = score            # 可以在前面加上 __ ，这样就是一个 private 变量， 外部无法访问    def print_score(self):              # 数据封装        print(&#39;%s: %s&#39; % (self.name, self.__score))s = Student()s.age = 18          # python 可以这样自由定义属性</code></pre><p><strong>python</strong>语言的“<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000#0" target="_blank" rel="noopener">鸭子类型</a>”特性。</p><p><strong>type()</strong><br>可以用这个函数来获取数据对象的类型：</p><pre><code>&gt;&gt;&gt; type(123)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type(&#39;str&#39;)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &#39;NoneType&#39;&gt;</code></pre><p><strong>isinstance()</strong><br>也可以用这个函数来判断数据对象的类型</p><pre><code>object -&gt; Animal -&gt; Dog -&gt; Husky&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True</code></pre><p><strong>dir() \ getattr() \ setattr() \ hasattr()</strong><br>可以用 <code>dir()</code> 函数返回一个 list ，包含一个数据对象的所有属性和方法：</p><pre><code>&gt;&gt;&gt; dir(&#39;ABC&#39;)[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]</code></pre><p>其他三个方法可以用于判断和设置数据对象的属性：</p><pre><code>&gt;&gt;&gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？False&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？True&gt;&gt;&gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;19&gt;&gt;&gt; obj.y # 获取属性&#39;y&#39;19&gt;&gt;&gt; del obj.y # 删除实例的属性# 可以传入一个default参数，如果属性不存在，就返回默认值&gt;&gt;&gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404404</code></pre><p><strong>类属性</strong><br>定义在方法之外，class 之内的叫做类属性：</p><pre><code>&gt;&gt;&gt; class Student(object):...     name = &#39;Student&#39;...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student</code></pre><h2 id="e-高级面向对象编程"><a href="#e-高级面向对象编程" class="headerlink" title="e) 高级面向对象编程"></a>e) 高级面向对象编程</h2><h3 id="1-给实例或类动态绑定方法"><a href="#1-给实例或类动态绑定方法" class="headerlink" title="1. 给实例或类动态绑定方法"></a>1. 给实例或类动态绑定方法</h3><pre><code>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法...     self.age = age...&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法&gt;&gt;&gt; s.age # 测试结果25&gt;&gt;&gt; def set_score(self, score):...     self.score = score...&gt;&gt;&gt; Student.set_score = set_score</code></pre><h3 id="2-slots"><a href="#2-slots" class="headerlink" title="2. slots"></a>2. <strong>slots</strong></h3><p>限制实例的属性：</p><pre><code>class Student(object):    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称，这是一个白名单# 以上定义后 Student 的实例只能拥有 tuple 中的属性，其他属性在定义时会报错# 子类可以定义自己的 __slots__ ，这样实例同时可以定义子类加上父类开放的属性</code></pre><h3 id="3-property-装饰器"><a href="#3-property-装饰器" class="headerlink" title="3. @property 装饰器"></a>3. @property 装饰器</h3><p>可以简化 <code>setter</code> 和 <code>getter</code> ，具体看<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186781871161bc8d6497004764b398401a401d4cce000" target="_blank" rel="noopener">这</a></p><p>简单理解，值在属性上面放一个 <code>@property</code> 就是只读。</p><h3 id="4-多重继承"><a href="#4-多重继承" class="headerlink" title="4. 多重继承"></a>4. 多重继承</h3><p>写法：</p><pre><code>class Bat(Mammal, Flyable):    pass</code></pre><h3 id="5-定制类"><a href="#5-定制类" class="headerlink" title="5. 定制类"></a>5. 定制类</h3><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319098638265527beb24f7840aa97de564ccc7f20f6000#0" target="_blank" rel="noopener">具体看这</a>，定制类可以让 python 的函数具有极大的可定制性，你可以用定制类重新定义函数的基本底层。</p><h3 id="6-枚举类"><a href="#6-枚举类" class="headerlink" title="6. 枚举类"></a>6. 枚举类</h3><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191235886950998592cd3e426e91687cdae696e64b000" target="_blank" rel="noopener">具体看这</a><br>便于一些关系常量的统一定义。</p><h3 id="7-元类"><a href="#7-元类" class="headerlink" title="7. 元类"></a>7. <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000" target="_blank" rel="noopener">元类</a></h3><p>可以改变类创建时的行为。</p><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-错误、调试和测试"><a href="#1-错误、调试和测试" class="headerlink" title="1. 错误、调试和测试"></a>1. 错误、调试和测试</h3><p><strong>try…except…finally…错误处理机制</strong><br><code>try</code> 中的代码块会在发生错误的一行停止执行；<br><code>except</code> 中的代码块会在错误发生时执行，因为错误可能有多种，所以这个代码块也可能有多个；<br><code>else</code> 会在没有任何错误发生时执行；<br><code>finally</code> 可写可不写，但是其中的代码块一定会执行；</p><pre><code class="python">import loggingtry:    print(&#39;try...&#39;)    r = 10 / int(&#39;2&#39;)    print(&#39;result:&#39;, r)except ValueError as e:    print(&#39;ValueError:&#39;, e)except ZeroDivisionError as e:    print(&#39;ZeroDivisionError:&#39;, e)except Exception as e:    logging.exception(e)    # 记录错误到日志else:    print(&#39;no error!&#39;)finally:    print(&#39;finally...&#39;)print(&#39;END&#39;)</code></pre><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见错误及其继承关系</a></p><p><strong>调试</strong><br>调试的方式主要有以下几种：</p><ul><li>print</li><li>断言（assert）</li><li>logging：输出到日志 ———— 推荐</li><li>pdb：单步调试</li><li>pdb.set_trace()：相当于调试中的断点</li></ul><p><strong><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191629979802b566644aa84656b50cd484ec4a7838000" target="_blank" rel="noopener">单元测试</a></strong><br>对一个模块、一个函数或者一个类来进行正确性检验的测试工作。我个人理解是，可以把一些特殊的样例较为周全的写到单元测试的代码里面，以减少每一次修改代码后需要手动输入进行测试的数据。通过测试的代码不一定没有bug。</p><p><strong><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319170285543a4d04751f8846908770660de849f285000" target="_blank" rel="noopener">文档测试</a></strong><br>以注释的形式写在代码里，作用和单元测试类似，有一个很重要的作用就是可以用来自动生成代码。</p><h3 id="2-I-O编程————磁盘文件读写"><a href="#2-I-O编程————磁盘文件读写" class="headerlink" title="2. I\O编程————磁盘文件读写"></a>2. I\O编程————磁盘文件读写</h3><p><strong>文件读</strong></p><p>基本操作</p><pre><code class="python">f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)    # 得到一个流，默认编码 UTF-8f.read()                                    # 读到内存f.close()                                   # 关闭（这是必须的）read(size)                                  # 每次最多读取 size 字节的内容readline()                                  # 每次读一行readlines()                                 # 一次读取所有内容并按行返回 listf = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)   # 图片、视频等二进制文件，用&#39;rb&#39;模式打开文件即可f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;) # 其他编码的文件f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)    # 忽略读取文件中的编码错误</code></pre><p>错误处理</p><pre><code class="python">try:    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)    print(f.read())finally:    if f:        f.close()</code></pre><p>错误处理的一种简便写法</p><pre><code class="python">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:    print(f.read())</code></pre><p><strong>文件写</strong></p><p>基本操作</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;)&gt;&gt;&gt; f.write(&#39;Hello, world!&#39;)&gt;&gt;&gt; f.close()</code></pre><p>简便写法</p><pre><code class="python">with open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) as f:    f.write(&#39;Hello, world!&#39;)</code></pre><p><a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener">完整文档</a></p><h3 id="3-I-O编程————内存读写"><a href="#3-I-O编程————内存读写" class="headerlink" title="3. I\O编程————内存读写"></a>3. I\O编程————内存读写</h3><p><strong>StringIO 和 BytesIO</strong></p><pre><code>&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&#39;hello&#39;)5&gt;&gt;&gt; f.write(&#39; &#39;)1&gt;&gt;&gt; f.write(&#39;world!&#39;)6&gt;&gt;&gt; print(f.getvalue())hello world!&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)&gt;&gt;&gt; while True:...     s = f.readline()...     if s == &#39;&#39;:...         break...     print(s.strip())...Hello!Hi!Goodbye!</code></pre><h3 id="3-操作文件或目录"><a href="#3-操作文件或目录" class="headerlink" title="3. 操作文件或目录"></a>3. 操作文件或目录</h3><pre><code># 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)&#39;/Users/michael&#39;# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join(&#39;/Users/michael&#39;, &#39;testdir&#39;)&#39;/Users/michael/testdir&#39;# 然后创建一个目录:&gt;&gt;&gt; os.mkdir(&#39;/Users/michael/testdir&#39;)# 删掉一个目录:&gt;&gt;&gt; os.rmdir(&#39;/Users/michael/testdir&#39;)---# 两个路径的合并，这样可以正确处理不同系统下的路径os.path.join()# 路径拆解&gt;&gt;&gt; os.path.split(&#39;/Users/michael/testdir/file.txt&#39;)(&#39;/Users/michael/testdir&#39;, &#39;file.txt&#39;)# 拆解扩展名&gt;&gt;&gt; os.path.splitext(&#39;/path/to/file.txt&#39;)(&#39;/path/to/file&#39;, &#39;.txt&#39;)---# 对文件重命名:&gt;&gt;&gt; os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)# 删掉文件:&gt;&gt;&gt; os.remove(&#39;test.py&#39;)# 但是 os 中没有复制函数，可 shutil 模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充---# 过滤&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)][&#39;.lein&#39;, &#39;.local&#39;, &#39;.m2&#39;, &#39;.npm&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;.vim&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, ...]&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;][&#39;apis.py&#39;, &#39;config.py&#39;, &#39;models.py&#39;, &#39;pymonitor.py&#39;, &#39;test_db.py&#39;, &#39;urls.py&#39;, &#39;wsgiapp.py&#39;]</code></pre><h3 id="4-Json-序列化"><a href="#4-Json-序列化" class="headerlink" title="4. Json 序列化"></a>4. Json 序列化</h3><p><strong>序列化</strong></p><pre><code>&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name=&#39;Bob&#39;, age=20, score=88)&gt;&gt;&gt; json.dumps(d)&#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;# dump()方法可以直接把JSON写入一个file-like Object</code></pre><p><strong>反序列化</strong></p><pre><code>&gt;&gt;&gt; json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;&gt;&gt;&gt; json.loads(json_str){&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;}# JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化</code></pre><p><strong>对象的 Json 化</strong></p><pre><code>def student2dict(std):    return {        &#39;name&#39;: std.name,        &#39;age&#39;: std.age,        &#39;score&#39;: std.score    }&gt;&gt;&gt; print(json.dumps(s, default=student2dict)){&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}</code></pre><p><strong>Json 的对象化</strong></p><pre><code>def dict2student(d):    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])&gt;&gt;&gt; json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x10cd3c190&gt;</code></pre><hr><h2 id="五、其他特性"><a href="#五、其他特性" class="headerlink" title="五、其他特性"></a>五、其他特性</h2><p>后面的特性我只需要知道有这个东西和它在其他语言中不同的地方，等到需要用的时候再来具体看。大概看遍，这里只记标题和觉得值得记得地方。</p><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><ul><li>多核多线程在python中不可用（当然也不是没有办法）</li></ul><h2 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h2><p>异步I\O</p><h2 id="3-正则"><a href="#3-正则" class="headerlink" title="3. 正则"></a>3. 正则</h2><p>可以先预编译，提高效率。</p><h2 id="4-常用内建模块"><a href="#4-常用内建模块" class="headerlink" title="4. 常用内建模块"></a>4. 常用内建模块</h2><ul><li><p>datatime</p></li><li><p>collections</p><ul><li><p>deque<br>  增删效率高于 list</p></li><li><p>defaultdict<br>  使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict</p></li><li><p>OrderedDict<br>  使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用OrderedDict。</p></li><li><p>Counter<br>  Counter是一个简单的计数器，例如可以统计字符出现的个数。</p></li></ul></li><li><p>base64<br>  处理字节。</p></li><li><p>hashlib<br>  常见的摘要算法。</p></li><li><p>hmac<br>  可以理解为加盐哈希。</p></li><li><p>itertools<br>  提供处理迭代功能的函数。</p></li><li><p>contextlib<br>  上下文管理，在一段代码之前先执行什么，在一段代码执行完后执行什么。</p></li><li><p>urllib<br>  一系列用于操作URL的功能。可以用于抓取网页内容，模拟请求。</p></li><li><p>XML</p></li><li><p>HTMLParser<br>  解析HTML。</p></li></ul><h2 id="5-常用第三方模块"><a href="#5-常用第三方模块" class="headerlink" title="5. 常用第三方模块"></a>5. 常用第三方模块</h2><ul><li><p>Pillow<br>  图像处理。</p></li><li><p>requests<br>  相当于第三方的urllib，有更多高级功能，更好用。</p></li><li><p>chardet<br>  检测bytes的编码，并转化成str。</p></li><li><p>psutil<br>  运维好伙伴，用于获取系统信息</p></li></ul><h2 id="6-virtualenv"><a href="#6-virtualenv" class="headerlink" title="6. virtualenv"></a>6. virtualenv</h2><p>隔离不用版本环境的 python。</p><h2 id="7-图形界面"><a href="#7-图形界面" class="headerlink" title="7. 图形界面"></a>7. 图形界面</h2><ul><li>Tk</li><li>wxWidgets</li><li>Qt</li><li>GTK</li></ul><h2 id="8-网络编程"><a href="#8-网络编程" class="headerlink" title="8. 网络编程"></a>8. 网络编程</h2><h2 id="9-电子邮件"><a href="#9-电子邮件" class="headerlink" title="9. 电子邮件"></a>9. 电子邮件</h2><h2 id="10-数据库访问"><a href="#10-数据库访问" class="headerlink" title="10. 数据库访问"></a>10. 数据库访问</h2><h2 id="11-Web开发"><a href="#11-Web开发" class="headerlink" title="11. Web开发"></a>11. Web开发</h2><p>WCGI</p><h2 id="12-异步IO"><a href="#12-异步IO" class="headerlink" title="12. 异步IO"></a>12. 异步IO</h2>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 快查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel/Lumen教程4-JWT的基本使用</title>
      <link href="/2018/01/11/Laravel-Lumen%E6%95%99%E7%A8%8B4-JWT%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/01/11/Laravel-Lumen%E6%95%99%E7%A8%8B4-JWT%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>2018/5/7</p><p>说实话，官方文档也是相当的乱，这次根据文档并查看源码实验了很多地方，大改了一次。</p></blockquote><p><strong>JWT</strong> 全称 <strong>JSON Web Tokens</strong> ，是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。</p><h1 id="一、安装之前"><a href="#一、安装之前" class="headerlink" title="一、安装之前"></a>一、安装之前</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>先摆出几个参考资料，可以把连接都打开，方便查阅：</p><ul><li><a href="https://github.com/tymondesigns/jwt-auth/wiki/Installation" target="_blank" rel="noopener">项目Wiki</a></li><li><a href="https://mp.weixin.qq.com/s/KVUQE2DUetNB2kqxHs0VDg" target="_blank" rel="noopener">公众号coding01</a>，<a href="https://juejin.im/post/5a0812a16fb9a0451704ad96" target="_blank" rel="noopener">JWT安装及简单例子</a></li><li><a href="http://jwt-auth.readthedocs.io/en/docs/laravel-installation/" target="_blank" rel="noopener">官方安装指导文档</a></li><li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">JWT的介绍</a></li></ul><h1 id="二、安装及基础配置"><a href="#二、安装及基础配置" class="headerlink" title="二、安装及基础配置"></a>二、安装及基础配置</h1><p>##　Laravel</p><h3 id="1-使用-composer-安装"><a href="#1-使用-composer-安装" class="headerlink" title="1. 使用 composer 安装"></a>1. 使用 composer 安装</h3><pre><code class="shell"># 建议使用1.0以上版本composer require tymon/jwt-auth 1.*@rc</code></pre><h3 id="2-进行一些配置"><a href="#2-进行一些配置" class="headerlink" title="2. 进行一些配置"></a>2. 进行一些配置</h3><h4 id="2-1-发布配置文件"><a href="#2-1-发布配置文件" class="headerlink" title="2.1 发布配置文件"></a>2.1 发布配置文件</h4><p>这里指的注意的是，有些文档会说要添加 <code>Tymon\JWTAuth\Providers\LaravelServiceProvider::class</code> ，这只在 Laravel 5.4 及以下版本是必要的，更新的 Laravel 版本无需添加。</p><p>还有一些文档说要添加 <code>Tymon\JWTAuth\Providers\JWTAuthServiceProvider</code> 这是很久以前的 JWT 版本的（大概0.5.3 以前的版本）。</p><pre><code class="shell"># 这条命令会在 config 下增加一个 jwt.php 的配置文件php artisan vendor:publish --provider=&quot;Tymon\JWTAuth\Providers\LaravelServiceProvider&quot;</code></pre><h4 id="2-2-生成加密密钥"><a href="#2-2-生成加密密钥" class="headerlink" title="2.2 生成加密密钥"></a>2.2 生成加密密钥</h4><pre><code class="shell"># 这条命令会在 .env 文件下生成一个加密密钥，如：JWT_SECRET=foobarphp artisan jwt:secret</code></pre><h4 id="2-3-更新你的模型"><a href="#2-3-更新你的模型" class="headerlink" title="2.3 更新你的模型"></a>2.3 更新你的模型</h4><p>如果你使用默认的 User 表来生成 token，你需要在该模型下增加一段代码</p><pre><code class="php">&lt;?phpnamespace App;use Tymon\JWTAuth\Contracts\JWTSubject;use Illuminate\Notifications\Notifiable;use Illuminate\Foundation\Auth\User as Authenticatable;class User extends Authenticatable implements JWTSubject    # 这里别忘了加{    use Notifiable;    // Rest omitted for brevity    /**     * Get the identifier that will be stored in the subject claim of the JWT.     *     * @return mixed     */    public function getJWTIdentifier()    {        return $this-&gt;getKey();    }    /**     * Return a key value array, containing any custom claims to be added to the JWT.     *     * @return array     */    public function getJWTCustomClaims()    {        return [];    }}</code></pre><h4 id="2-4-注册两个-Facade"><a href="#2-4-注册两个-Facade" class="headerlink" title="2.4 注册两个 Facade"></a>2.4 注册两个 Facade</h4><p>这两个 Facade 并不是必须的，但是使用它们会给你的代码编写带来一点便利。</p><p><strong>config/app.php</strong></p><pre><code class="php">&#39;aliases&#39; =&gt; [        ...        // 添加以下两行        &#39;JWTAuth&#39; =&gt; &#39;Tymon\JWTAuth\Facades\JWTAuth&#39;,        &#39;JWTFactory&#39; =&gt; &#39;Tymon\JWTAuth\Facades\JWTFactory&#39;,],</code></pre><p><strong>如果你不使用这两个 Facade，你可以使用辅助函数 auth()</strong></p><p>auth() 是一个辅助函数，返回一个guard，暂时可以看成 Auth Facade。</p><p>对于它有很多有必要说的，可以看我单独写的一篇文章——<a href="/2018/05/8/Laravel-辅助函数auth与JWT扩展详解">Laravel 辅助函数 auth 与 JWT 扩展详解</a></p><pre><code class="php">// 如果你不用 Facade，你可以这么写auth(&#39;api&#39;)-&gt;refresh();// 用 JWTAuth FacadeJWTAuth::parseToken()-&gt;refresh();</code></pre><p>两个 Facede 常用可使用方法，可以看文章后面的附录。</p><p>####2.5 注册一些路由</p><p>注意：在 Laravel 下，<code>route/api.php</code> 中的路由默认都有前缀 <code>api</code> 。</p><pre><code class="php">Route::group([    &#39;prefix&#39; =&gt; &#39;auth&#39;], function ($router) {    Route::post(&#39;login&#39;, &#39;AuthController@login&#39;);    Route::post(&#39;logout&#39;, &#39;AuthController@logout&#39;);    Route::post(&#39;refresh&#39;, &#39;AuthController@refresh&#39;);    Route::post(&#39;me&#39;, &#39;AuthController@me&#39;);});</code></pre><h4 id="2-6-创建-token-控制器"><a href="#2-6-创建-token-控制器" class="headerlink" title="2.6 创建 token 控制器"></a>2.6 创建 token 控制器</h4><pre><code class="shell">php artisan make:controller AuthController</code></pre><p><strong>AuthController</strong></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use Illuminate\Support\Facades\Auth;use App\Http\Controllers\Controller;class AuthController extends Controller{    /**     * Create a new AuthController instance.     * 要求附带email和password（数据来源users表）     *      * @return void     */    public function __construct()    {        $this-&gt;middleware(&#39;auth:api&#39;, [&#39;except&#39; =&gt; [&#39;login&#39;]]);    }    /**     * Get a JWT via given credentials.     *     * @return \Illuminate\Http\JsonResponse     */    public function login()    {        $credentials = request([&#39;email&#39;, &#39;password&#39;]);        if (! $token = auth()-&gt;attempt($credentials)) {            return response()-&gt;json([&#39;error&#39; =&gt; &#39;Unauthorized&#39;], 401);        }        return $this-&gt;respondWithToken($token);    }    /**     * Get the authenticated User.     *     * @return \Illuminate\Http\JsonResponse     */    public function me()    {        return response()-&gt;json(auth()-&gt;user());    }    /**     * Log the user out (Invalidate the token).     *     * @return \Illuminate\Http\JsonResponse     */    public function logout()    {        auth()-&gt;logout();        return response()-&gt;json([&#39;message&#39; =&gt; &#39;Successfully logged out&#39;]);    }    /**     * Refresh a token.     * 刷新token，如果开启黑名单，以前的token便会失效。     * 值得注意的是用上面的getToken再获取一次Token并不算做刷新，两次获得的Token是并行的，即两个都可用。     * @return \Illuminate\Http\JsonResponse     */    public function refresh()    {        return $this-&gt;respondWithToken(auth()-&gt;refresh());    }    /**     * Get the token array structure.     *     * @param  string $token     *     * @return \Illuminate\Http\JsonResponse     */    protected function respondWithToken($token)    {        return response()-&gt;json([            &#39;access_token&#39; =&gt; $token,            &#39;token_type&#39; =&gt; &#39;bearer&#39;,            &#39;expires_in&#39; =&gt; auth()-&gt;factory()-&gt;getTTL() * 60        ]);    }}</code></pre><h2 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h2><h3 id="1-使用-composer-安装-1"><a href="#1-使用-composer-安装-1" class="headerlink" title="1. 使用 composer 安装"></a>1. 使用 composer 安装</h3><p>上面是用命令行安装的，这里用 composer.json 安装。</p><pre><code class="json">// 我当时可用的版本是这个&quot;require&quot;: {&quot;dingo/api&quot;:&quot;1.*@rc&quot;}</code></pre><p>执行</p><pre><code class="shell">composer update</code></pre><h3 id="2-进行一些配置-1"><a href="#2-进行一些配置-1" class="headerlink" title="2. 进行一些配置"></a>2. 进行一些配置</h3><h4 id="2-1-开启-Facade-和-Eloquent"><a href="#2-1-开启-Facade-和-Eloquent" class="headerlink" title="2.1 开启 Facade 和 Eloquent"></a>2.1 开启 Facade 和 Eloquent</h4><p>取消以下行的注释。</p><p><strong>bootstrap/app.php</strong></p><pre><code class="php">// $app-&gt;withFacades();// $app-&gt;withEloquent();</code></pre><h4 id="2-2-开启中间件认证"><a href="#2-2-开启中间件认证" class="headerlink" title="2.2 开启中间件认证"></a>2.2 开启中间件认证</h4><p>取消以下行的注释。</p><p><strong>bootstrap/app.php</strong></p><pre><code class="php">// $app-&gt;routeMiddleware([//     &#39;auth&#39; =&gt; App\Http\Middleware\Authenticate::class,// ]);// $app-&gt;register(App\Providers\AuthServiceProvider::class);</code></pre><h4 id="2-3-添加服务提供者"><a href="#2-3-添加服务提供者" class="headerlink" title="2.3 添加服务提供者"></a>2.3 添加服务提供者</h4><p><strong>bootstrap/app.php</strong> </p><pre><code class="php">// 有些文档里是说添加 Tymon\JWTAuth\Providers\JWTAuthServiceProvider::class，那是旧版本的$app-&gt;register(\Tymon\JWTAuth\Providers\LumenServiceProvider::class);</code></pre><h4 id="2-4-生成加密密钥"><a href="#2-4-生成加密密钥" class="headerlink" title="2.4 生成加密密钥"></a>2.4 生成加密密钥</h4><pre><code class="shell"># 这条命令会在 .env 文件下生成一个加密密钥，如：JWT_SECRET=foobarphp artisan jwt:secret</code></pre><h4 id="2-5-更新你的模型"><a href="#2-5-更新你的模型" class="headerlink" title="2.5 更新你的模型"></a>2.5 更新你的模型</h4><p>如果你使用默认的 User 表来生成 token，你需要在该模型下增加一段代码</p><pre><code class="php">&lt;?phpnamespace App;use Illuminate\Auth\Authenticatable;use Laravel\Lumen\Auth\Authorizable;use Illuminate\Database\Eloquent\Model;use Illuminate\Contracts\Auth\Authenticatable as AuthenticatableContract;use Illuminate\Contracts\Auth\Access\Authorizable as AuthorizableContract;use Tymon\JWTAuth\Contracts\JWTSubject;class User extends Model implements AuthenticatableContract, AuthorizableContract, JWTSubject{    use Authenticatable, Authorizable;    ...    /**     * Get the identifier that will be stored in the subject claim of the JWT.     *     * @return mixed     */    public function getJWTIdentifier()    {        return $this-&gt;getKey();    }    /**     * Return a key value array, containing any custom claims to be added to the JWT.     *     * @return array     */    public function getJWTCustomClaims()    {        return [];    }}</code></pre><h4 id="2-6-注册两个-Facade"><a href="#2-6-注册两个-Facade" class="headerlink" title="2.6 注册两个 Facade"></a>2.6 注册两个 Facade</h4><p>Lumen 中没有辅助函数 auth()，这两个 Facade 就挺有用了。</p><p><strong>bootstrap/app.php</strong></p><p>把原先去了注释的那一行再改一下。</p><pre><code class="php">$app-&gt;withFacades(true, [    &#39;Tymon\JWTAuth\Facades\JWTAuth&#39; =&gt; &#39;JWTAuth&#39;,    &#39;Tymon\JWTAuth\Facades\JWTFactory&#39; =&gt; &#39;JWTFactory&#39;,]);</code></pre><h4 id="2-7-设置-auth-php"><a href="#2-7-设置-auth-php" class="headerlink" title="2.7 设置 auth.php"></a>2.7 设置 auth.php</h4><p>把 <code>\vendor\laravel\lumen-framework\config\auth.php</code> 也复制到 <code>config</code> 文件夹（没有就新建）</p><p><strong>auth.php</strong></p><p>按下面进行添加或修改。</p><pre><code class="php">&#39;guards&#39; =&gt; [    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;jwt&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],],...&#39;providers&#39; =&gt; [    &#39;users&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; \App\User::class]</code></pre><h4 id="2-8-注册一些路由"><a href="#2-8-注册一些路由" class="headerlink" title="2.8 注册一些路由"></a>2.8 注册一些路由</h4><pre><code class="php">Route::group([    &#39;prefix&#39; =&gt; &#39;auth&#39;], function ($router) {    Route::post(&#39;login&#39;, &#39;AuthController@login&#39;);    Route::post(&#39;logout&#39;, &#39;AuthController@logout&#39;);    Route::post(&#39;refresh&#39;, &#39;AuthController@refresh&#39;);    Route::post(&#39;me&#39;, &#39;AuthController@me&#39;);});</code></pre><h4 id="2-9-创建-token-控制器"><a href="#2-9-创建-token-控制器" class="headerlink" title="2.9 创建 token 控制器"></a>2.9 创建 token 控制器</h4><p>Lumen 还精简了很多辅助函数，比如 auth 和 bcrypt 等。</p><p>可以安装 <a href="https://packagist.org/packages/cosmicvelocity/lumen-helpers" target="_blank" rel="noopener">cosmicvelocity/lumen-helpers</a> 或 <a href="https://packagist.org/packages/albertcht/lumen-helpers" target="_blank" rel="noopener">albertcht/lumen-helpers</a> 补全（建议用后者，更好安装）</p><p>或者使用上面说的两个 Facade。</p><p><strong>AuthController.php</strong> </p><p>如果你没使用扩展补充的辅助函数，你需要这么写，不然直接用上面的 Larvavel 那个</p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Tymon\JWTAuth\Facades\JWTAuth;class AuthController extends Controller{    /**     * Create a new AuthController instance.     *     * @return void     */    public function __construct()    {        $this-&gt;middleware(&#39;auth:api&#39;, [&#39;except&#39; =&gt; [&#39;login&#39;]]);    }    /**     * Get a JWT via given credentials.     *     * @return \Illuminate\Http\JsonResponse     */    public function login(Request $request)    {        $credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);        if (! $token = JWTAuth::attempt($credentials)) {            return response()-&gt;json([&#39;error&#39; =&gt; &#39;Unauthorized&#39;], 401);        }        return $this-&gt;respondWithToken($token);    }    /**     * Get the authenticated User.     *     * @return \Illuminate\Http\JsonResponse     */    public function me()    {        return response()-&gt;json(JWTAuth::parseToken()-&gt;touser());    }    /**     * Log the user out (Invalidate the token).     *     * @return \Illuminate\Http\JsonResponse     */    public function logout()    {        JWTAuth::parseToken()-&gt;invalidate();        return response()-&gt;json([&#39;message&#39; =&gt; &#39;Successfully logged out&#39;]);    }    /**     * Refresh a token.     *     * @return \Illuminate\Http\JsonResponse     */    public function refresh()    {        return $this-&gt;respondWithToken(JWTAuth::parseToken()-&gt;refresh());    }    /**     * Get the token array structure.     *     * @param  string $token     *     * @return \Illuminate\Http\JsonResponse     */    protected function respondWithToken($token)    {        return response()-&gt;json([            &#39;access_token&#39; =&gt; $token,            &#39;token_type&#39; =&gt; &#39;bearer&#39;,            &#39;expires_in&#39; =&gt; JWTAuth::factory()-&gt;getTTL() * 60        ]);    }}</code></pre><h1 id="三、JWT-Token-详解"><a href="#三、JWT-Token-详解" class="headerlink" title="三、JWT Token 详解"></a>三、JWT Token 详解</h1><h2 id="1-token-的获取、使用、删除和刷新"><a href="#1-token-的获取、使用、删除和刷新" class="headerlink" title="1. token 的获取、使用、删除和刷新"></a>1. token 的获取、使用、删除和刷新</h2><p>以下用 postman 演示，<code></code> 为 postman 全局变量：<code>test.yfree.ccc</code></p><h3 id="1-1-获取-token"><a href="#1-1-获取-token" class="headerlink" title="1.1 获取 token"></a>1.1 获取 token</h3><p><img src="Laravel-Lumen教程4——JWT的基本使用.assets/1525762596233.png" alt="获取token"></p><h3 id="1-2-使用-token"><a href="#1-2-使用-token" class="headerlink" title="1.2 使用 token"></a>1.2 使用 token</h3><p>有两种使用方法：</p><ul><li>加到 url 中：<code>?token=你的token</code></li><li>加到 header 中，建议用这种，因为在 https 情况下更安全：<code>Authorization:Bearer 你的token</code> </li></ul><p><img src="Laravel-Lumen教程4——JWT的基本使用.assets/1525762643801.png" alt="使用 token"></p><blockquote><p>添加中间件保护的就需要使用 token进行访问</p><p>可以使用的中间件有 auth、auth:api、jwt.auth、jwt.refresh</p><p>关于这些中间件之间有什么差别，可以看我的另一篇文章：<a href="/2018/05/8/Laravel-辅助函数auth与JWT扩展详解">Laravel 辅助函数 auth 与 JWT 扩展详解</a></p></blockquote><h3 id="1-3-删除-token"><a href="#1-3-删除-token" class="headerlink" title="1.3 删除 token"></a>1.3 删除 token</h3><p><img src="Laravel-Lumen教程4——JWT的基本使用.assets/1525763059181.png" alt="删除 token"></p><p>删除 <code>token</code> 后，token就会失效，无法再利用其获取数据。</p><h3 id="1-4-刷新-token"><a href="#1-4-刷新-token" class="headerlink" title="1.4 刷新 token"></a>1.4 刷新 token</h3><p><img src="Laravel-Lumen教程4——JWT的基本使用.assets/1525763138371.png" alt="刷新 token"></p><p>刷新后，旧 token 将会失效,但是你可以设置一个宽限时间，这个在后面具体说。</p><h2 id="2-token-的组成、创建以及解析"><a href="#2-token-的组成、创建以及解析" class="headerlink" title="2. token 的组成、创建以及解析"></a>2. token 的组成、创建以及解析</h2><h3 id="2-1-token-的组成"><a href="#2-1-token-的组成" class="headerlink" title="2.1 token 的组成"></a>2.1 token 的组成</h3><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名，中间用 <code>.</code> 分隔，例如：<code>xxxxx.yyyyy.zzzzz</code></p><h4 id="头部（header）"><a href="#头部（header）" class="headerlink" title="头部（header）"></a>头部（header）</h4><p>头部通常由两部分组成：令牌的类型（即JWT）和正在使用的散列算法（如HMAC SHA256 或 RSA.）。<br>例如：</p><pre><code class="json">{  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;}</code></pre><p>然后用 <code>Base64Url</code> 编码得到头部，即 <code>xxxxx</code>。</p><h4 id="载荷（Payload）"><a href="#载荷（Payload）" class="headerlink" title="载荷（Payload）"></a>载荷（Payload）</h4><p>载荷中放置了 <code>token</code> 的一些基本信息，以帮助接受它的服务器来理解这个 <code>token</code>，载荷的属性也分三类：预定义（Registered）、公有（public）和私有（private），接下来主要介绍预定义的。</p><pre><code class="json">{  &quot;sub&quot;: &quot;1&quot;,  &quot;iss&quot;: &quot;http://localhost:8000/auth/login&quot;,  &quot;iat&quot;: 1451888119,  &quot;exp&quot;: 1454516119,  &quot;nbf&quot;: 1451888119,  &quot;jti&quot;: &quot;37c107e4609ddbcc9c096ea5ee76c667&quot;}</code></pre><p>这里面的前6个字段都是由JWT的<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank" rel="noopener">标准</a>所定义的，也就是预定义（Registered claims）的。</p><blockquote><ul><li>sub: 该JWT所面向的用户</li><li>iss: 该JWT的签发者</li><li>iat(issued at): 在什么时候签发的token</li><li>exp(expires): token什么时候过期</li><li>nbf(not before)：token在此时间之前不能被接收处理</li><li>jti：JWT ID为web token提供唯一标识</li></ul></blockquote><p>将上面的 <code>json</code> 进行 <code>Base64Url</code> 编码得到载荷，，即 <code>yyyyy</code>。</p><h4 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h4><p>签名时需要用到前面编码过的两个字符串，如果以 <code>HMACSHA256</code> 加密，就如下：</p><pre><code class="php">HMACSHA256(    base64UrlEncode(header) + &quot;.&quot; +    base64UrlEncode(payload),    secret)</code></pre><p>加密后再进行 <code>base64url</code> 编码最后得到的字符串就是 <code>token</code> 的第三部分 <code>zzzzz</code>。</p><p>组合便可以得到 <code>token：xxxxx.yyyyy.zzzzz</code>。</p><p><strong>PHP 代码示例</strong></p><pre><code class="php">// 这里要开启true$zzzzz = $this-&gt;base64url_encode(hash_hmac(&#39;sha256&#39;, &#39;xxxxx.yyyyy&#39;, getenv(&#39;JWT_SECRET&#39;), true));protected function base64url_encode($data) {    return rtrim(strtr(base64_encode($data), &#39;+/&#39;, &#39;-_&#39;), &#39;=&#39;);}</code></pre><p>这里插一嘴签名的作用：保证 JWT 没有被篡改过，原理如下：</p><blockquote><p>HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的secret）由客户端和服务端共享，服务端把 token 发给客户端后，客户端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。</p></blockquote><h3 id="2-2-token-的创建"><a href="#2-2-token-的创建" class="headerlink" title="2.2 token 的创建"></a>2.2 token 的创建</h3><p>前面的 <code>AuthController.php</code> 中有两行展现了这一种 <code>token</code> 的创建方法，即用用户所给的账号和密码进行<strong>尝试</strong>，密码正确则用对应的 <code>User</code> 信息返回一个 <code>token</code> 。</p><p>但 <code>token</code> 的创建方法不止这一种，接下来介绍 <code>token</code> 的三种创建方法：</p><ul><li>基于账密参数</li><li>基于 users 模型返回的实例</li><li>基于 users 模型中的用户主键 id</li></ul><h4 id="a-基于账密参数"><a href="#a-基于账密参数" class="headerlink" title="a) 基于账密参数"></a>a) 基于账密参数</h4><p>这就是刚刚说的哪一种，贴出具体代码。</p><pre><code class="php">// 使用辅助函数$credentials = request([&#39;email&#39;, &#39;password&#39;]); $token = auth()-&gt;attempt($credentials)// 使用 Facade$credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);$token = JWTAuth::attempt($credentials);</code></pre><h4 id="b-基于-users-模型返回的实例"><a href="#b-基于-users-模型返回的实例" class="headerlink" title="b) 基于 users 模型返回的实例"></a>b) 基于 users 模型返回的实例</h4><pre><code class="php">// 使用辅助函数$user = User::first();$token = auth()-&gt;login($user);// 使用 Facade$user = User::first();$token = JWTAuth::fromUser($credentials);</code></pre><h4 id="c-基于-users-模型中的主键-id"><a href="#c-基于-users-模型中的主键-id" class="headerlink" title="c) 基于 users 模型中的主键 id"></a>c) 基于 users 模型中的主键 id</h4><pre><code class="php">// 使用辅助函数$token = auth()-&gt;tokenById(1);// 使用 Facade源码中没找到</code></pre><h3 id="2-3-token-的解析"><a href="#2-3-token-的解析" class="headerlink" title="2.3 token 的解析"></a>2.3 token 的解析</h3><h4 id="a-解析-token-到对象"><a href="#a-解析-token-到对象" class="headerlink" title="a) 解析 token 到对象"></a>a) 解析 token 到对象</h4><p>只有 Facade 需要这样。</p><pre><code class="php">// 把请求发送过来的直接解析到对象JWTAuth::parseToken();</code></pre><h4 id="b-获取-token-中的-user-信息"><a href="#b-获取-token-中的-user-信息" class="headerlink" title="b) 获取 token 中的 user 信息"></a>b) 获取 token 中的 user 信息</h4><pre><code class="php">// 辅助函数$user = auth()-&gt;user();// Facade$user = JWTAuth::parseToken()-&gt;authenticate();</code></pre><h4 id="c-获取-token"><a href="#c-获取-token" class="headerlink" title="c) 获取 token"></a>c) 获取 token</h4><p>如果 token 被设置则会返回，否则会尝试使用方法从请求中解析 token ，如果token未被设置或不能解析最终返回false。</p><pre><code class="php">// 辅助函数$token = auth()-&gt;getToken();// Facade$token = JWTAuth::parseToken()-&gt;getToken();</code></pre><p>更多方法可以看文章后面的附录。</p><h4 id="d-如果是前端"><a href="#d-如果是前端" class="headerlink" title="d) 如果是前端"></a>d) 如果是前端</h4><p>直接 <code>base64</code> 解码 <code>token</code> 的前两段即可以知道所需的信息。</p><h2 id="3-载荷的设置和获取"><a href="#3-载荷的设置和获取" class="headerlink" title="3. 载荷的设置和获取"></a>3. 载荷的设置和获取</h2><h4 id="a-载荷设置"><a href="#a-载荷设置" class="headerlink" title="a) 载荷设置"></a>a) 载荷设置</h4><p>载荷信息会在 token 解码时得到，同时越大的数组会生成越长的 token ，所以不建议放太多的数据。同时因为载荷是用 <code>Base64Url</code> 编码，所以相当于明文，因此绝对不能放密码等敏感信息。</p><pre><code class="php">$customClaims = [&#39;foo&#39; =&gt; &#39;bar&#39;, &#39;baz&#39; =&gt; &#39;bob&#39;];// 辅助函数$token = auth()-&gt;claims($customClaims)-&gt;attempt($credentials);// Facade - 1$token = JWTAuth::claims($customClaims)-&gt;attempt($credentials);--- 下面两种试了好像不行，不过前面的够用了// Facade - 2$payload = JWTFactory::make($customClaims);$token = JWTAuth::encode($payload);// Facade - 3$payload = JWTFactory::sub(123)-&gt;aud(&#39;foo&#39;)-&gt;foo([&#39;bar&#39; =&gt; &#39;baz&#39;])-&gt;make();$token = JWTAuth::encode($payload);</code></pre><h4 id="b-载荷解析"><a href="#b-载荷解析" class="headerlink" title="b) 载荷解析"></a>b) 载荷解析</h4><p>从请求中把载荷解析出来。可以去看扩展源代码，里面还有很多的方法。</p><pre><code class="php">// 辅助函数$exp = auth()-&gt;payload()-&gt;get(&#39;exp&#39;);$json = auth()-&gt;payload()-&gt;toJson();$array = auth()-&gt;payload()-&gt;jsonSerialize();$sub = $array[&#39;sub&#39;];// Facade - 1$payload = JWTAuth::parseToken()-&gt;getPayload();$payload-&gt;get(&#39;sub&#39;); // = 123$payload[&#39;jti&#39;]; // = &#39;asfe4fq434asdf&#39;$payload(&#39;exp&#39;) // = 123456$payload-&gt;toArray(); // = [&#39;sub&#39; =&gt; 123, &#39;exp&#39; =&gt; 123456, &#39;jti&#39; =&gt; &#39;asfe4fq434asdf&#39;] etc// Facade - 2$exp = JWTAuth::parseToken()-&gt;getClaim(&#39;exp&#39;);</code></pre><p>#### </p><h2 id="4-token-的三个时间"><a href="#4-token-的三个时间" class="headerlink" title="4. token 的三个时间"></a>4. token 的三个时间</h2><p>一个 <code>token</code> 一般来说有三个时间属性，其配置都在 <strong>config/jwt.php</strong> 内。</p><h4 id="有效时间"><a href="#有效时间" class="headerlink" title="有效时间"></a>有效时间</h4><p>有效时间指的的是你获得 <code>token</code> 后，在多少时间内可以凭这个 <code>token</code> 去获取内容，逾时无效。</p><pre><code class="php">// 单位：分钟&#39;ttl&#39; =&gt; env(&#39;JWT_TTL&#39;, 60)</code></pre><h4 id="刷新时间"><a href="#刷新时间" class="headerlink" title="刷新时间"></a>刷新时间</h4><p>刷新时间指的是在这个时间内可以凭旧 <code>token</code> 换取一个新 <code>token</code>。例如 <code>token</code> 有效时间为 60 分钟，刷新时间为 20160 分钟，在 60 分钟内可以通过这个 <code>token</code> 获取新 <code>token</code>，但是超过 60 分钟是不可以的，然后你可以一直循环获取，直到总时间超过 20160 分钟，不能再获取。</p><pre><code class="php">// 单位：分钟&#39;refresh_ttl&#39; =&gt; env(&#39;JWT_REFRESH_TTL&#39;, 20160)</code></pre><h4 id="宽限时间"><a href="#宽限时间" class="headerlink" title="宽限时间"></a>宽限时间</h4><p>宽限时间是为了解决并发请求的问题，假如宽限时间为 0s ，那么在新旧 <code>token</code> 交接的时候，并发请求就会出错，所以需要设定一个宽限时间，在宽限时间内，旧 <code>token</code> 仍然能够正常使用。</p><pre><code class="php">// 宽限时间需要开启黑名单（默认是开启的），黑名单保证过期token不可再用，最好打开&#39;blacklist_enabled&#39; =&gt; env(&#39;JWT_BLACKLIST_ENABLED&#39;, true)// 设定宽限时间，单位：秒&#39;blacklist_grace_period&#39; =&gt; env(&#39;JWT_BLACKLIST_GRACE_PERIOD&#39;, 60)</code></pre><h2 id="5-关于-JWT-的讨论"><a href="#5-关于-JWT-的讨论" class="headerlink" title="5. 关于 JWT 的讨论"></a>5. 关于 JWT 的讨论</h2><h3 id="5-1-为什么用-JWT？"><a href="#5-1-为什么用-JWT？" class="headerlink" title="5.1 为什么用 JWT？"></a>5.1 为什么用 JWT？</h3><p>首先因为 <code>HTTP</code> 是无状态的协议，每一个请求都不会受到前后请求的状态影响，所以就需要 <strong>维护和验证登录状态</strong> 。</p><p><strong>传统方法</strong>：<code>cookies</code> 和 <code>session</code>  </p><p><strong>只用cookies</strong>：由于用于验证的敏感信息都保存在本地，即使进行了加密，也并不是特别安全。  </p><p><strong>session</strong>：需要在 <code>cookies</code> 中保存 <code>sessionID</code> ，然后在服务器中保存 <code>session</code> ，其中包括会话ID和用户ID ，同时由于 <code>session</code> 常常保存在内存中，所以会对服务器造成比较大的压力。</p><p>再加上 <code>cookies</code> 的不可跨域名性（子域名之间也算跨域名），跨域操作也存在问题。</p><p><strong>JWT</strong>：<br>使用 <code>JWT</code> 可以做到前后端脱离，解决跨域问题，消除服务器存储session的压力，但是同时增加了计算压力。这两者怎么选择，开发者可以自行考虑。</p><h3 id="5-2-token-的刷新问题？"><a href="#5-2-token-的刷新问题？" class="headerlink" title="5.2 token 的刷新问题？"></a>5.2 token 的刷新问题？</h3><p><strong>a) token 为什么要刷新吗？</strong></p><p>首先 <code>Basic Auth</code> 是一种最简单的认证方法，但是由于每次请求都带用户名和密码，频繁的传输肯定不安全，所以才有 <code>cookies</code> 和 <code>session</code> 的运用。如果 <code>token</code> 不刷新，那么 <code>token</code> 就相当于上面的用户名+密码，只要获取到了，就可以一直盗用，因此 <code>token</code> 设置有效期并能够进行刷新是必要的。</p><p><strong>b) token 有效期多久合适，刷新频率多久合适？</strong></p><p>有效期越长，风险性越高，有效性越短，刷新频率越高，刷新就会存在刷新开销，所以这需要综合考虑。我个人一般考虑的范围是：15min ~ 120min。</p><p><strong>c) 有没有必要每次都刷新 token ？</strong></p><p>上面考虑的 15min ~ 120min，会存在一个问题，就是<strong>重放攻击</strong>风险，防御这个风险，在 <code>JWT</code> 可用的方案是每次请求后都刷新一次 <code>token</code> ，但这样又会存在一个新的问题：并发请求。一次并发请求是用的一个 <code>token</code> ，第一个完成的请求会导致后面的请求全部失败。可用的解决方案是设置<strong>宽限时间</strong>，即一个 <code>token</code> 刷新后，旧 <code>token</code> 仍然短暂的可用。可惜这样并不能完美的解决重放攻击，只是增大了不法者攻击的成本。这个问题在 <code>JWT</code> 中并没有很好的解决。</p><pre><code class="php">// 每次刷新的话需要用到第二个中间件，会把新 token 放到返回的 header 头中// 第一个中间件起名可能会让你以为是获取一个 user 什么的，其实并不是那么回事，直接用旧可以了protected $routeMiddleware = [    ...    &#39;jwt.auth&#39; =&gt; &#39;Tymon\JWTAuth\Middleware\GetUserFromToken&#39;,    &#39;jwt.refresh&#39; =&gt; &#39;Tymon\JWTAuth\Middleware\RefreshToken&#39;,];</code></pre><h3 id="5-3-token-的刷新总结"><a href="#5-3-token-的刷新总结" class="headerlink" title="5.3 token 的刷新总结"></a>5.3 token 的刷新总结</h3><p>因为无法完全解决重放攻击，所以在因重放攻击会导致巨大安全问题和损失的地方，建议使用其他安全认证措施。而日常 <code>Api</code> 使用建议如下设置： </p><pre><code>有效时间：15min ~ 120min刷新时间：7天 ~ 30天宽限时间：60s</code></pre><h1 id="三、附录"><a href="#三、附录" class="headerlink" title="三、附录"></a>三、附录</h1><h2 id="1-JWT-的-两个-Facade"><a href="#1-JWT-的-两个-Facade" class="headerlink" title="1. JWT 的 两个 Facade"></a>1. JWT 的 两个 Facade</h2><h3 id="1-1-JWTAuth"><a href="#1-1-JWTAuth" class="headerlink" title="1.1 JWTAuth"></a>1.1 JWTAuth</h3><p><code>JWTAuth::parseToken-&gt;方法()</code> 一般都可以换成 <code>auth()-&gt;方法()</code>。</p><h4 id="token-生成"><a href="#token-生成" class="headerlink" title="token 生成"></a>token 生成</h4><p><strong>attempt</strong></p><p>根据 user 账密新建一个 token。</p><pre><code class="php">$credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);$token = JWTAuth::attempt($credentials)；</code></pre><p><strong>fromUser</strong> or <strong>fromSubject</strong></p><p>根据 user 对象生成一个 token。后者是前者别名。</p><pre><code class="php">$user = User::find(1);$token = JWTAuth::fromUser($user);</code></pre><h4 id="token-控制"><a href="#token-控制" class="headerlink" title="token 控制"></a>token 控制</h4><p><strong>refresh</strong></p><p>更新 token。</p><pre><code class="php">$newToken = JWTAuth::parseToken-&gt;refresh();</code></pre><p><strong>invalidate</strong></p><p>让一个 token 无效。</p><pre><code class="php">JWTAuth::parseToken-&gt;invalidate();</code></pre><p><strong>check</strong></p><p>检验 token 的有效性。</p><pre><code class="php">if(JWTAuth::parseToken-&gt;check()) {    dd(&quot;token是有效的&quot;);}</code></pre><h4 id="token-解析"><a href="#token-解析" class="headerlink" title="token 解析"></a>token 解析</h4><p><strong>authenticate</strong> or <strong>toUser</strong> or <strong>user</strong></p><p>这三个效果是一样的，<code>toUser</code> 是 <code>authenticate</code> 的别名，而 <code>user</code> 比前两者少一个 user id 的校验，但并没有什么影响。</p><pre><code class="php">$user = JWTAuth::parseToken-&gt;toUser();</code></pre><p><strong>parseToken</strong></p><p>从 request 中解析 token 到对象中，以便进行下一步操作。</p><pre><code class="php">JWTAuth::parseToken();</code></pre><p><strong>getToken</strong></p><p>从 request 中获取token。</p><pre><code class="php">$token = JWTAuth::getToken();  // 这个不用 parseToken ，因为方法内部会自动执行一次</code></pre><h4 id="载荷控制"><a href="#载荷控制" class="headerlink" title="载荷控制"></a>载荷控制</h4><p><strong>customClaims</strong> or <strong>claims</strong></p><p>设置载荷的 customClaims 部分。后者是前者的别名。</p><pre><code class="php">$customClaims = [&#39;sid&#39; =&gt; $sid, &#39;code&#39; =&gt; $code];$credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);$token = JWTAuth::customClaims($customClaims)-&gt;attempt($credentials);</code></pre><p><strong>getCustomClaims</strong></p><p>获取载荷的 customClaims 部分，返回一个数组。</p><pre><code class="php">$customClaims = JWTAuth::parseToken-&gt;getCustomClaims()</code></pre><p><strong>getPayload</strong> or <strong>payload</strong></p><p>获取所有载荷，三个都是一样的，最后一个一般用来检验 token 的有效性</p><pre><code class="php">$payload = JWTAuth::parseToken-&gt;payload();// then you can access the claims directly e.g.$payload-&gt;get(&#39;sub&#39;); // = 123$payload[&#39;jti&#39;]; // = &#39;asfe4fq434asdf&#39;$payload(&#39;exp&#39;) // = 123456$payload-&gt;toArray(); // = [&#39;sub&#39; =&gt; 123, &#39;exp&#39; =&gt; 123456, &#39;jti&#39; =&gt; &#39;asfe4fq434asdf&#39;] etc</code></pre><p><strong>getClaim</strong></p><p>获取载荷中指定的一个元素。</p><pre><code class="php">$sub = JWTAuth::parseToken-&gt;getClaim(&#39;sub&#39;);</code></pre><h3 id="1-2-JWTGuard"><a href="#1-2-JWTGuard" class="headerlink" title="1.2 JWTGuard"></a>1.2 JWTGuard</h3><p>这个 Facade 主要进行载荷的管理，返回一个载荷对象，然后可以通过 JWTAuth 来对其生成一个 token。</p><pre><code class="php">// 载荷的高度自定义$payload = JWTFactory::sub(123)-&gt;aud(&#39;foo&#39;)-&gt;foo([&#39;bar&#39; =&gt; &#39;baz&#39;])-&gt;make();$token = JWTAuth::encode($payload);</code></pre><pre><code class="php">$customClaims = [&#39;foo&#39; =&gt; &#39;bar&#39;, &#39;baz&#39; =&gt; &#39;bob&#39;];$payload = JWTFactory::make($customClaims);$token = JWTAuth::encode($payload);</code></pre><h3 id="1-3-其他一些用法"><a href="#1-3-其他一些用法" class="headerlink" title="1.3 其他一些用法"></a>1.3 其他一些用法</h3><p>这里用 auth 的写法，因为 Laravel 有多个 guard，默认 guard 也不是 api ，所以需要写成 <code>auth(&#39;api&#39;)</code> 否则，<code>auth()</code> 即可。 </p><h4 id="设置载荷"><a href="#设置载荷" class="headerlink" title="设置载荷"></a>设置载荷</h4><pre><code class="php">$token = auth(&#39;api&#39;)-&gt;claims([&#39;foo&#39; =&gt; &#39;bar&#39;])-&gt;attempt($credentials);</code></pre><h4 id="显示设置-token"><a href="#显示设置-token" class="headerlink" title="显示设置 token"></a>显示设置 token</h4><pre><code class="php">$user = auth(&#39;api&#39;)-&gt;setToken(&#39;eyJhb...&#39;)-&gt;user();</code></pre><h4 id="显示设置请求"><a href="#显示设置请求" class="headerlink" title="显示设置请求"></a>显示设置请求</h4><pre><code class="php">$user = auth(&#39;api&#39;)-&gt;setRequest($request)-&gt;user();</code></pre><h4 id="重写有效时间"><a href="#重写有效时间" class="headerlink" title="重写有效时间"></a>重写有效时间</h4><pre><code class="php">$token = auth(&#39;api&#39;)-&gt;setTTL(7200)-&gt;attempt($credentials);</code></pre><h4 id="验证账密是否正确"><a href="#验证账密是否正确" class="headerlink" title="验证账密是否正确"></a>验证账密是否正确</h4><pre><code class="php">$boolean = auth(&#39;api&#39;)-&gt;validate($credentials);</code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> PHP </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> Lumen </tag>
            
            <tag> PHP </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel/Lumen教程3-dingo的基本使用</title>
      <link href="/2017/12/31/Laravel-Lumen%E6%95%99%E7%A8%8B3-dingo%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/31/Laravel-Lumen%E6%95%99%E7%A8%8B3-dingo%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>dingo 是 Laravel/Lumen 下一款便捷开发 Api 的组件，本篇主要介绍其基本安装、配置和使用。</p><h1 id="一、安装之前"><a href="#一、安装之前" class="headerlink" title="一、安装之前"></a>一、安装之前</h1><p>打开以下两个文档，准备随时翻阅：</p><ul><li><a href="https://github.com/dingo/api/wiki/Installation" target="_blank" rel="noopener">官方安装指导文档</a></li><li><a href="https://github.com/liyu001989/dingo-api-wiki-zh" target="_blank" rel="noopener">中文翻译文档</a></li></ul><h1 id="二、安装及基础配置"><a href="#二、安装及基础配置" class="headerlink" title="二、安装及基础配置"></a>二、安装及基础配置</h1><h2 id="1-使用-composer-安装"><a href="#1-使用-composer-安装" class="headerlink" title="1. 使用 composer 安装"></a>1. 使用 composer 安装</h2><p>打开 <code>composer.json</code> 文件,增加以下内容：</p><pre><code class="php">// 我当时可用的版本是这个&quot;require&quot;: {&quot;dingo/api&quot;:&quot;1.*@dev&quot;}</code></pre><p>执行</p><pre><code>composer update</code></pre><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>根据框架决定后续</p><h3 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h3><p>打开 <code>config/app.php</code> ,注册服务提供者：</p><pre><code class="php">&#39;providers&#39; =&gt; [    Dingo\Api\Provider\LaravelServiceProvider::class]</code></pre><p>如果你想进行额外的配置，执行以下命令即可发布一个配置文件（<code>api.php</code>）到 <code>config</code> 文件夹中（Lumen 中没有这个命令，当然你也可以安装这个命令，不过没必要）：</p><pre><code>php artisan vendor:publish --provider=&quot;Dingo\Api\Provider\LaravelServiceProvider&quot;</code></pre><h3 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h3><p>打开 <code>bootstrap/app.php</code>，注册服务提供者：</p><pre><code class="php">$app-&gt;register(Dingo\Api\Provider\LumenServiceProvider::class);</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>大部分配置可以在 <code>.env</code> 文件中配置好，一些微调需要在你发布的配置文件（Laravel）或者 <code>bootstrap/app.php</code>（Lumen）中配置。<code>.env</code>文件的配置如下：</p><pre><code>API_STANDARDS_TREE=xAPI_SUBTYPE=laravel-apiAPI_NAME=MyAPIAPI_VERSION=v1API_PREFIX=api    // 这个前缀会体现在 URL 中API_CONDITIONAL_REQUEST=falseAPI_STRICT=falseAPI_DEFAULT_FORMAT=jsonAPI_DEBUG=true</code></pre><blockquote><p>API_STANDARDS_TREE - API规格 </p><blockquote><p>x 本地或私有环境<br>prs 非商业销售的项目<br>vnd 公开的以及商业销售的项目 </p></blockquote><p>API_SUBTYPE - API简称<br>API_PREFIX - API前缀（或使用API_DOMAIN - API子域名）<br>API_VERSION - API默认版本<br>API_NAME - API名称<br>API_CONDITIONAL_REQUEST - 带条件的请求，由于缓存API请求的时候会使用客户端缓存功能，所以默认开启了带条件的请求<br>API_STRICT - 严格模式，要求客户端发送Accept头而不是默认在配置文件中指定的版本<br>API_DEFAULT_FORMAT - 响应格式，默认的响应格式是JSON<br>API_DEBUG - 调试模式</p></blockquote><h3 id="Facades-这以后再写"><a href="#Facades-这以后再写" class="headerlink" title="Facades(这以后再写)"></a>Facades(这以后再写)</h3><hr><h1 id="三、简单demo"><a href="#三、简单demo" class="headerlink" title="三、简单demo"></a>三、简单demo</h1><h2 id="1-基本路由"><a href="#1-基本路由" class="headerlink" title="1. 基本路由"></a>1. 基本路由</h2><h3 id="routes-web-php"><a href="#routes-web-php" class="headerlink" title="routes/web.php"></a>routes/web.php</h3><pre><code class="php">// dingo 使用自有的路由器，所以你需要先获取其实例$api = app(&#39;Dingo\Api\Routing\Router&#39;);// 必须定义一个版本分组，“v1”来自于 .env 文件，必须填写才生效$api-&gt;version(&#39;v1&#39;, [&#39;namespace&#39; =&gt; &#39;App\Http\Controllers&#39;], function ($api) {  // 认证部分：获取token  $api-&gt;get(&#39;/auth/token&#39;, &#39;AuthController@createToken&#39;);  // 认证部分：刷新token  $api-&gt;patch(&#39;/auth/token&#39;, &#39;AuthController@refreshToken&#39;);  // 认证部分：删除token  $api-&gt;delete(&#39;/auth/token&#39;, &#39;AuthController@deleteToken&#39;);  // jwt-auth的路由保护，放在这里面的就需要带上token访问  $api-&gt;group([&#39;middleware&#39; =&gt; &#39;auth:api&#39;], function ($api) {      // 资源获取：users      $api-&gt;resource(&#39;users&#39;, &#39;UserController&#39;);  });});</code></pre><p>访问 <code>127.0.0.1:8003/api/test</code> (8003 是我在 Nginx 中设置的端口)</p><h2 id="2-对返回数据进行统一格式化"><a href="#2-对返回数据进行统一格式化" class="headerlink" title="2. 对返回数据进行统一格式化"></a>2. 对返回数据进行统一格式化</h2><p>有时候我们需要对从数据库取得的数据进行处理，然后才返回，这就需要用到 <code>transformer</code>，接下来简单介绍一下如何使用 <code>transformer</code>。</p><h3 id="2-1-用-migrate-新建数据表，用-seeder-填充数据"><a href="#2-1-用-migrate-新建数据表，用-seeder-填充数据" class="headerlink" title="2.1 用 migrate 新建数据表，用 seeder 填充数据"></a>2.1 用 <code>migrate</code> 新建数据表，用 <code>seeder</code> 填充数据</h3><p>首先我们要新建一个 <code>users</code> 表，然后填充几条测试数据，<code>Laravel</code> 中用 <code>数据迁移</code> 来进行表的创建和管理。</p><h4 id="新建数据表"><a href="#新建数据表" class="headerlink" title="新建数据表"></a>新建数据表</h4><p><code>Laravel</code> 的 <code>database/migrations</code> 下有两个默认文件，执行以下命令即可生成两个默认表：</p><pre><code>php artisan migrate</code></pre><p><code>Lumen</code> 的对应目录下默认没有那两个文件，可以从 <code>Laravel</code> 复制过去在用同样的命令生成。</p><h4 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h4><p>在 <code>database/seeds</code> 中新建文件 <code>UsersTableSeeder.php</code>，写入：</p><pre><code class="php">&lt;?phpuse Illuminate\Database\Seeder;class UsersTableSeeder extends Seeder{  public function run()  {    DB::table(&#39;users&#39;)-&gt;insert([      &#39;name&#39; =&gt; str_random(10),      &#39;email&#39; =&gt; str_random(10).&#39;@gmail.com&#39;,      &#39;password&#39; =&gt; bcrypt(&#39;secret&#39;),      // Lumen 中没有 bcrypt() 这个函数，可以用下面一行代替      // &#39;password&#39; =&gt; app(&#39;hash&#39;)-&gt;make(&#39;secret&#39;),    ]);  }}</code></pre><p>把 <code>database/seeds/DatabaseSeeder.php</code> 中</p><pre><code class="php">// $this-&gt;call(&#39;UsersTableSeeder&#39;);</code></pre><p>取消注释。</p><p>执行以下其中一句即可生成一条数据，执行三次，生成三条测试数据。</p><pre><code>composer dump-autoload  // 如果以下运行不成功，先运行这个php artisan db:seed  // 不指定的话，默认调用DatabaseSeederphp artisan db:seed --class=UsersTableSeeder</code></pre><h3 id="2-2-新建-Model-绑定数据表，新建-Controller-取出数据"><a href="#2-2-新建-Model-绑定数据表，新建-Controller-取出数据" class="headerlink" title="2.2 新建 Model 绑定数据表，新建 Controller 取出数据"></a>2.2 新建 <code>Model</code> 绑定数据表，新建 <code>Controller</code> 取出数据</h3><h4 id="新建模型绑定数据表"><a href="#新建模型绑定数据表" class="headerlink" title="新建模型绑定数据表"></a>新建模型绑定数据表</h4><p>在 <code>app</code> 目录下，新建 <code>Models/DB/api_lumen2/User.php</code> （目录也是新建的，分这么多级目录是个人习惯），写入：</p><pre><code class="php">&lt;?phpnamespace App\Models\DB\api_lumen2;use Illuminate\Database\Eloquent\Model;class User extends Model{    protected $connection = &#39;mysql&#39;;  // 多数据库操作时最好进行绑定    protected $table = &#39;users&#39;; // 指定表    protected $primaryKey = &#39;id&#39;; // 指定主键    public $timestamps = true;  // 是否自动维护时间戳}</code></pre><h4 id="新建控制器取出数据"><a href="#新建控制器取出数据" class="headerlink" title="新建控制器取出数据"></a>新建控制器取出数据</h4><p>在 <code>app/Http/Controllers</code> 中新建 <code>UserController.php</code>，写入：</p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use App\Models\DB\api_lumen2\User;class UserController extends Controller{  // 返回所有的user  public function index()  {    $user = User::all();    return $user;  }  // 按ID返回user  public function show($id)  {    $user = User::findOrFail($id);      return $user;  }}</code></pre><h4 id="设置路由"><a href="#设置路由" class="headerlink" title="设置路由"></a>设置路由</h4><pre><code class="php">$api-&gt;version(&#39;v1&#39;, function ($api) {  $api-&gt;group([&#39;namespace&#39; =&gt; &#39;App\Http\Controllers&#39;], function ($api) {    $api-&gt;resource(&#39;users&#39;, &#39;UserController&#39;);  // 这里用到了资源路由，具体看文档  }); });</code></pre><p>访问 <code>http://127.0.0.1:8003/api/users</code> 和 <code>http://127.0.0.1:8003/api/users/1</code> 就可以看到返回的数据</p><p><strong>这样就成功实现了数据的取出操作，接下来介绍如何使用 <code>tansfomer</code> 来进行数据的格式化</strong></p><h3 id="2-3-Transfomer-的使用"><a href="#2-3-Transfomer-的使用" class="headerlink" title="2.3 Transfomer 的使用"></a>2.3 <code>Transfomer</code> 的使用</h3><h4 id="使用方法0"><a href="#使用方法0" class="headerlink" title="使用方法0"></a>使用方法0</h4><p>一种官方文档没有记录的用法</p><pre><code class="php">$res = (new UserTransformer)-&gt;transform($res);</code></pre><h4 id="使用方法1"><a href="#使用方法1" class="headerlink" title="使用方法1"></a>使用方法1</h4><p>还不知道怎么用</p><pre><code class="php">app(&#39;Dingo\Api\Transformer\Factory&#39;)-&gt;register(&#39;User&#39;, &#39;UserTransformer&#39;);</code></pre><h4 id="使用方法2"><a href="#使用方法2" class="headerlink" title="使用方法2"></a>使用方法2</h4><h5 id="新建转换器"><a href="#新建转换器" class="headerlink" title="新建转换器"></a>新建转换器</h5><p>在 <code>app/Http/</code> 目录下新建 <code>Tansfomer</code> 文件夹，新建 <code>UserTransfomer.php</code>，写入：</p><pre><code class="php">&lt;?phpnamespace App\Http\Transformers;use App\Models\DB\api_lumen2\User;use League\Fractal\TransformerAbstract;class UserTransformer extends TransformerAbstract{  public function transform(User $user)  {    return [        &#39;id&#39; =&gt; $user-&gt;id,        &#39;user_name&#39; =&gt; $user-&gt;name,        &#39;user_email&#39; =&gt; $user-&gt;email,    ];  }}</code></pre><h5 id="修改控制器"><a href="#修改控制器" class="headerlink" title="修改控制器"></a>修改控制器</h5><p>使用 <code>transfomer</code>，需要用到 <code>Dingo\Api\Routing\Helpers</code> 这个 <code>trait</code>，可以新建一个 <code>ApiController.php</code> 继承自基础控制器，在这个控制器中使用 <code>trait</code>，然后其他控制器继承这个控制器。</p><p><strong>ApiController</strong></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use Dingo\Api\Routing\Helpers;use Laravel\Lumen\Routing\Controller as BaseController;class ApiController extends BaseController{  use Helpers;}</code></pre><p><strong>UserController</strong></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use App\Models\DB\api_lumen2\User;use App\Http\Transformers\UserTransformer;class UserController extends ApiController{  // 返回所有的user  public function index()  {    $user = User::all();    return $this-&gt;response-&gt;collection($user, new UserTransformer);  }  // 按ID返回user  public function show($id)  {    // 这里返回的数据类型是 collection，后面的响应大部分是要以 collection 来进行转换    $user = User::findOrFail($id);      // 这里有诸多的响应方式，可以参考官方文档    return $this-&gt;response-&gt;item($user, new UserTransformer);  }}</code></pre><p>再访问 <code>http://127.0.0.1:8003/api/users</code> 和 <code>http://127.0.0.1:8003/api/users/1</code> 就可以看到格式化返回的数据</p><h4 id="自定义转换层"><a href="#自定义转换层" class="headerlink" title="自定义转换层"></a>自定义转换层</h4><p>一直没弄懂怎么用，以后有时间具体在研究</p><hr><h2 id="3-响应"><a href="#3-响应" class="headerlink" title="3. 响应"></a>3. 响应</h2><h3 id="3-1-对数据进行再包装"><a href="#3-1-对数据进行再包装" class="headerlink" title="3.1 对数据进行再包装"></a>3.1 对数据进行再包装</h3><p>有时候，我们需要把需要的数据放在 <code>data</code> 中，然后 <code>data</code> 的同级，有一个 <code>code</code> 或 <code>errMsg</code>，要实现这种效果，我本来该想过进行两次 <code>tansfomer</code>，但是一直没成功，后来换了个思路，在 <code>ApiController</code> 中新建一个方法，对数据进行打包，用这种办法的话就不好用 <code>transfomer</code> 进行数据转换，因为 <code>transfomer</code> 直接返回了一个 <code>response</code> 对象，并不好再继续修改，所以必须自己实现数据转换。</p><p><strong>ApiController.php</strong></p><pre><code class="php">&lt;?phpnamespace App\Http\Controllers;use Dingo\Api\Routing\Helpers;use Laravel\Lumen\Routing\Controller as BaseController;class ApiController extends BaseController{    use Helpers;    public $errcode;    public $errmsg;    public $status;    public $header = &#39;未封包&#39;;    public $debug = &#39;未调试&#39;;    // 构造响应基本框架    public function createResponse($data, $status, $errcode)    {        // 设置 errMsg        $this-&gt;__setErrMsg($errcode);        $body = array(            &#39;errcode&#39; =&gt; $errcode,            &#39;status&#39; =&gt; $status,            &#39;errmsg&#39; =&gt; $this-&gt;errmsg,            &#39;header&#39; =&gt; $this-&gt;header,            &#39;debug&#39; =&gt; $this-&gt;debug,            &#39;data&#39; =&gt; $data        );        // 如果对返回数据有更多设置需求，安装文档指导改这里即可。        return $this-&gt;response-&gt;array($body)-&gt;setStatusCode($status);    }    // 设置debug内容，个人习惯，可以无视    public function setDebug($debug)    {        $this-&gt;debug = $debug;    }    // 当 envelope=true 时将，将 header 头插入返回体中，个人想要实现一个特效，可以无视    public function setHeader($header)    {        $this-&gt;header = $header;    }    // 设置错误码和错误内容    public function __setErrMsg($errcode)    {        $msgForCode = array(            0 =&gt; &#39;成功&#39;,            1 =&gt; &#39;成功(未修改密码)&#39;,            2 =&gt; &#39;成功(未绑定邮箱) 请前往教务系统绑定邮箱 ：http://jwxt.***.edu.cn/jsxsd/&#39;,            3 =&gt; &#39;删除了不存在的数据&#39;,            -1 =&gt; &#39;网络故障&#39;,            -2 =&gt; &#39;未知错误&#39;,            -3 =&gt; &#39;验证码错误&#39;,            -4 =&gt; &#39;用户名或密码错误&#39;,            -5 =&gt; &#39;HTTP错误&#39;,            -6 =&gt; &#39;唯一性限制&#39;,            -7 =&gt; &#39;更新不存在的数据，导致失败&#39;,            -8 =&gt; &#39;数据不存在&#39;,            -9 =&gt; &#39;越权限操作&#39;,            -10 =&gt; &#39;账户可调用次数不足&#39;,            -65535 =&gt; &#39;参数错误&#39;        );        $this-&gt;errmsg = $msgForCode[$errcode];    }}</code></pre><p><strong>UserController.php</strong></p><pre><code class="php">// 返回所有的userpublic function index(){  $user = User::all();  $userArray = $user-&gt;toArray();  $userData = array();  foreach ($userArray as $key =&gt; $value) {    $array = array(      &#39;id&#39; =&gt; $value[&#39;id&#39;],      &#39;user_name&#39; =&gt; $value[&#39;name&#39;],      &#39;user_email&#39; =&gt; $value[&#39;email&#39;]    );    $userData[] = $array;  }  $data = json_encode($userData);  return $this-&gt;createResponse($data, 201, 0);}</code></pre><p><strong>最后返回的数据</strong></p><pre><code class="json">{  &quot;errcode&quot;: 0,  &quot;status&quot;: 201,  &quot;errmsg&quot;: &quot;成功&quot;,  &quot;header&quot;: &quot;未封包&quot;,  &quot;debug&quot;: &quot;未调试&quot;,  &quot;data&quot;: &quot;数据略...&quot;}</code></pre><h3 id="3-2-修改默认的错误返回格式"><a href="#3-2-修改默认的错误返回格式" class="headerlink" title="3.2 修改默认的错误返回格式"></a>3.2 修改默认的错误返回格式</h3><p>在上面，我返回的数据格式是我自定义的，但是有时候返回一些错误的时候，其格式和我定义的格式并不相符，作为接口，当然最后是错误和正确的返回格式一致，所以就需要对错误的返回格式进行修改。</p><p><strong>错误示例：</strong></p><pre><code class="php">return $this-&gt;response-&gt;errorNotFound();</code></pre><pre><code class="json">{  &quot;message&quot;: &quot;Not Found&quot;,  &quot;status_code&quot;: 404}</code></pre><p><strong>设置方法：</strong><br>在 <code>bootstrap/app.php</code> 中配置：</p><pre><code class="php">$app[&#39;Dingo\Api\Exception\Handler&#39;]-&gt;setErrorFormat([    &#39;errcode&#39; =&gt; -5,    &#39;status&#39; =&gt; &#39;:status_code&#39;,    &#39;errmsg&#39; =&gt; &#39;:message&#39;,    &#39;data&#39; =&gt; null,    &#39;header&#39; =&gt; &quot;未封包&quot;,    &#39;debug&#39; =&gt; &#39;:debug&#39;]);</code></pre><p>注意放在 <code>$app-&gt;register(Dingo\Api\Provider\LumenServiceProvider::class);</code> 之后。</p><p>这样错误返回为：</p><pre><code class="json">{  &quot;errcode&quot;: -5,  // 这里-5固定为HTTP错误  &quot;status&quot;: 404,  &quot;errmsg&quot;: &quot;NOT FOUND&quot;,  &quot;data&quot;: null,  &quot;header&quot;: &quot;未封包&quot;,  &quot;debug&quot;: &quot;数据略...&quot;}</code></pre><h2 id="4-结合认证"><a href="#4-结合认证" class="headerlink" title="4. 结合认证"></a>4. 结合认证</h2><p><code>dingo</code> 支持三种认证方式</p><blockquote><p>HTTP Basic (Dingo\Api\Auth\Provider\Basic)<br>JSON Web Tokens (Dingo\Api\Auth\Provider\JWT)<br>OAuth 2.0 (Dingo\Api\Auth\Provider\OAuth2)</p></blockquote><p>因为我个人主要使用 <code>JWT</code> 方式，所以接下来另开几篇文章来介绍如何使用 <code>JWT</code>。</p><h2 id="5-Response-总结"><a href="#5-Response-总结" class="headerlink" title="5. Response 总结"></a>5. Response 总结</h2><pre><code class="php">// dingo：controller 中return $this-&gt;response-&gt;error(&#39;This is an error.&#39;, 404);return $this-&gt;response-&gt;errorNotFound();// laravel/lumen 自带的响应return response(&#39;Unauthorized.&#39;, 401);return response()-&gt;json([&#39;errmsg&#39; =&gt; &#39;Unauthorized&#39;], 401);</code></pre><h2 id="6-Lumen-框架下的路由小坑"><a href="#6-Lumen-框架下的路由小坑" class="headerlink" title="6. Lumen 框架下的路由小坑"></a>6. Lumen 框架下的路由小坑</h2><p>假设路由是这样的：</p><pre><code class="php">$api-&gt;get(&#39;/edu/grade/{term}&#39;, &#39;EduGradeController@getGrade&#39;);</code></pre><p>本来 <code>Laravel</code> 框架下，获取路由路径中的参数可以用以下两种方式：</p><pre><code class="php">$term = $request-&gt;term;$term = $request-&gt;route(&#39;term&#39;);</code></pre><p>但是 <code>Lumen</code> 都不可以，你必须自己解析 <code>$request-&gt;route()</code>:</p><pre><code class="php">// 定义这个方法function route_parameter($name, $default = null){    $routeInfo = app(&#39;request&#39;)-&gt;route();    return array_get($routeInfo[2], $name, $default);}// 打印你的参数dd($this-&gt;route_parameter(&#39;term&#39;));</code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> Lumen </tag>
            
            <tag> PHP </tag>
            
            <tag> Dingo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel/Lumen教程2-安装以及项目新建</title>
      <link href="/2017/12/30/Laravel-Lumen%E6%95%99%E7%A8%8B2-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%96%B0%E5%BB%BA/"/>
      <url>/2017/12/30/Laravel-Lumen%E6%95%99%E7%A8%8B2-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%96%B0%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>这一篇主要介绍如何安装 Laravel 和 Lumen ，以及如何新建一个项目。</p><h1 id="一、使用-Homestead"><a href="#一、使用-Homestead" class="headerlink" title="一、使用 Homestead"></a>一、使用 Homestead</h1><h2 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h2><h3 id="1-安装-Laravel"><a href="#1-安装-Laravel" class="headerlink" title="1. 安装 Laravel"></a>1. 安装 Laravel</h3><pre><code class="shell">composer global require &quot;laravel/installer&quot;</code></pre><h3 id="2-新建项目"><a href="#2-新建项目" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h3><pre><code class="shell">laravel new blog# orcomposer create-project --prefer-dist laravel/laravel blog</code></pre><h2 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h2><h3 id="1-安装-Lumen"><a href="#1-安装-Lumen" class="headerlink" title="1. 安装 Lumen"></a>1. 安装 Lumen</h3><pre><code class="shell">composer global require &quot;laravel/lumen-installer&quot;</code></pre><h3 id="2-新建项目-1"><a href="#2-新建项目-1" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h3><pre><code class="shell">lumen new blogcomposer install   # 如果到后面报错，后头执行这一句cp .env.example .env# orcomposer create-project --prefer-dist laravel/lumen blog</code></pre><h1 id="二、不用-Homestead"><a href="#二、不用-Homestead" class="headerlink" title="二、不用 Homestead"></a>二、不用 Homestead</h1><h2 id="1-composer-相关"><a href="#1-composer-相关" class="headerlink" title="1. composer 相关"></a>1. composer 相关</h2><p>在安装之前先确保 <code>.composer/vendor/bin</code> 目录已经在系统环境变量中，确保系统能够找到 Laravel 或 Lumen 的可执行文件。</p><h3 id="找到对应目录"><a href="#找到对应目录" class="headerlink" title="找到对应目录"></a>找到对应目录</h3><ul><li>Windows 系统的一般在“我的文档”的 <code>AppData\Roaming</code> 里；</li></ul><ul><li>Linux 系统的一般在 <code>home/你的账户/</code> 里，如果是 deepin ，该目录下有个 <code>.config</code> 文件夹，一般在这里；</li></ul><h3 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h3><p>Windows 系统不多说；</p><p>Linux 系统（deepin）如下：</p><pre><code class="shell">cd /etcsudo vim bash.bashrc# 末尾加上PATH=&quot;$PATH:/home/arony/.config/composer/vendor/bin&quot;# 保存后执行更新命令source bash.bashrc</code></pre><h2 id="2-安装和新建项目"><a href="#2-安装和新建项目" class="headerlink" title="2. 安装和新建项目"></a>2. 安装和新建项目</h2><h3 id="Laravel-1"><a href="#Laravel-1" class="headerlink" title="Laravel"></a>Laravel</h3><h4 id="1-安装-Laravel-1"><a href="#1-安装-Laravel-1" class="headerlink" title="1. 安装 Laravel"></a>1. 安装 Laravel</h4><pre><code class="shell">composer global require &quot;laravel/installer&quot;</code></pre><h4 id="2-新建项目-2"><a href="#2-新建项目-2" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h4><pre><code class="shell">laravel new blog# orcomposer create-project --prefer-dist laravel/laravel blog</code></pre><h3 id="Lumen-1"><a href="#Lumen-1" class="headerlink" title="Lumen"></a>Lumen</h3><h4 id="1-安装-Lumen-1"><a href="#1-安装-Lumen-1" class="headerlink" title="1. 安装 Lumen"></a>1. 安装 Lumen</h4><pre><code class="shell">composer global require &quot;laravel/lumen-installer&quot;</code></pre><h4 id="2-新建项目-3"><a href="#2-新建项目-3" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h4><pre><code class="shell">lumen new blogcomposer install   # 如果到后面报错，后头执行这一句cp .env.example .env# orcomposer create-project --prefer-dist laravel/lumen blog</code></pre><p>新建项目后把 <code>storage</code> 目录的可写权限给web服务器。</p><h1 id="三、其他配置"><a href="#三、其他配置" class="headerlink" title="三、其他配置"></a>三、其他配置</h1><h2 id="1-Lumen-相关"><a href="#1-Lumen-相关" class="headerlink" title="1. Lumen 相关"></a>1. Lumen 相关</h2><h3 id="1-1-Lumen-artisan"><a href="#1-1-Lumen-artisan" class="headerlink" title="1.1 Lumen artisan"></a>1.1 Lumen artisan</h3><p>Lumen 中精简了很多 artisan 命令。</p><p>可以安装 <a href="https://packagist.org/packages/flipbox/lumen-generator" target="_blank" rel="noopener">flipbox/lumen-generator</a> 增加 <code>lumen</code> 中缺失的 <code>Laravel</code> 中的 <code>aritisan</code> 命令。</p><h3 id="1-2-Lumen-helpers"><a href="#1-2-Lumen-helpers" class="headerlink" title="1.2 Lumen helpers"></a>1.2 Lumen helpers</h3><p>Lumen 还精简了很多辅助函数，比如 auth 和 bcrypt 等。</p><p>可以安装 <a href="https://packagist.org/packages/cosmicvelocity/lumen-helpers" target="_blank" rel="noopener">cosmicvelocity/lumen-helpers</a> 或 <a href="https://packagist.org/packages/albertcht/lumen-helpers" target="_blank" rel="noopener">albertcht/lumen-helpers</a> 补全。</p><h3 id="1-3-Lumen-其他一些配置"><a href="#1-3-Lumen-其他一些配置" class="headerlink" title="1.3 Lumen 其他一些配置"></a>1.3 Lumen 其他一些配置</h3><p>打开 <code>bootstrap/app/php</code> ，把下面两行去掉注释，以开启 Facades 功能和 Eloquent 功能。</p><pre><code>$app-&gt;withFacades();$app-&gt;withEloquent();</code></pre><h2 id="2-加密key"><a href="#2-加密key" class="headerlink" title="2. 加密key"></a>2. 加密key</h2><ol><li>执行 <code>php artisan key:generate</code> 生成 <code>.env</code> 文件中的加密 key。</li></ol><h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h2><p>打开 <code>.env</code> 文件</p><pre><code class="php">DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=api_lumen  // 填入需要访问的数据库名DB_USERNAME=root       // 账号DB_PASSWORD=root       // 密码</code></pre><h3 id="3-1-多数据库配置"><a href="#3-1-多数据库配置" class="headerlink" title="3.1 多数据库配置"></a>3.1 多数据库配置</h3><p><strong>.env</strong></p><pre><code class="php">DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=api_lumen  // 填入需要访问的数据库名DB_DATABASE2=passport  // 填入需要访问的第二个数据库名DB_USERNAME=root       // 账号DB_PASSWORD=root       // 密码</code></pre><p><strong>config/database.php</strong></p><pre><code class="php">&#39;mysql-passport&#39; =&gt; [    &#39;driver&#39; =&gt; &#39;mysql&#39;,    &#39;host&#39; =&gt; env(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;),    &#39;port&#39; =&gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),    &#39;database&#39; =&gt; env(&#39;DB_DATABASE2&#39;, &#39;passport&#39;),    &#39;username&#39; =&gt; env(&#39;DB_USERNAME&#39;, &#39;root&#39;),    &#39;password&#39; =&gt; env(&#39;DB_PASSWORD&#39;, &#39;root&#39;),    &#39;unix_socket&#39; =&gt; env(&#39;DB_SOCKET&#39;, &#39;&#39;),    &#39;charset&#39; =&gt; &#39;utf8mb4&#39;,    &#39;collation&#39; =&gt; &#39;utf8mb4_unicode_ci&#39;,    &#39;prefix&#39; =&gt; &#39;&#39;,    &#39;strict&#39; =&gt; true,    &#39;engine&#39; =&gt; null,],</code></pre><p><strong>migrate</strong></p><pre><code class="php">// users表，用户状态信息表Schema::connection(&#39;mysql-passport&#39;)-&gt;create(&#39;users&#39;, function (Blueprint $table) {    $table-&gt;increments(&#39;id&#39;);    $table-&gt;timestamps();});</code></pre><p><strong>ORM模型操作数据库时</strong></p><pre><code class="php">protected $connection = &#39;mysql-passport&#39;;  // 在该model中使用testdb2库protected $table = &#39;article&#39;;</code></pre><p><strong>DB Facade</strong></p><pre><code class="php">DB::connection(&#39;mysql-passport&#39;)-&gt;select(...);php</code></pre><h2 id="4-nginx-Homestead-下无需担心"><a href="#4-nginx-Homestead-下无需担心" class="headerlink" title="4. nginx (Homestead 下无需担心)"></a>4. nginx (Homestead 下无需担心)</h2><p>我这是 phpstudy 下的配置：</p><ol><li>打开 <code>phpstudy/nginx/conf/vhosts.conf</code> ;</li><li><p>写入以下配置，配置多个时，写入多个即可，配置完记得重启 nginx</p><pre><code>server { listen       8001;      // 改成你想要的端口 server_name  localhost; root   D:/phpStudy/WWW/lumen/api/public;   // 改成你的项目 public 目录 index index.html index.htm index.php; location / {     try_files $uri $uri/ /index.php?$query_string;  // 如果是403，多半是这个没加 } location ~ \.php$ {     fastcgi_pass   127.0.0.1:9000;     fastcgi_index  index.php;     fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;     include        fastcgi_params; } location ~ /.ht {     deny  all; } error_page   500 502 503 504  /50x.html; location = /50x.html {     root   /usr/share/nginx/html; }        }</code></pre></li></ol><h3 id="4-1-测试是否可以访问"><a href="#4-1-测试是否可以访问" class="headerlink" title="4.1 测试是否可以访问"></a>4.1 测试是否可以访问</h3><p>浏览器打开：<a href="http://127.0.0.1:8001" target="_blank" rel="noopener">http://127.0.0.1:8001</a></p><h1 id="五、插一嘴关于-Lumen-的配置"><a href="#五、插一嘴关于-Lumen-的配置" class="headerlink" title="五、插一嘴关于 Lumen 的配置"></a>五、插一嘴关于 Lumen 的配置</h1><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p>默认情况下, Lumen 使用单一的 .env 文件来配置你的应用, 然而, 你也可以使用 Laravel 风格 的配置方法.</p><p>只需要把 <code>vendor/laravel/lumen-framework/config</code> 文件夹下对应的配置文件复制到根目录下的 <code>config</code> 文件（没有的话自己创建）里面就行，并且例如 <code>JWT</code> 这样的库，也可以直接在 <code>vendor</code> 下找到这样的配置文件复制过去。</p><p>使用这种方法, 能有更多的配置灵活度。例如可以把其下的 <code>database.php</code> 复制过来，便于进行多数据库连接。</p><h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>你可以创建自定义的配置文件, 并使用 <code>$app-&gt;configure()</code> 方法进行加载.</p><p>举个栗子, 把自定义配置文件放置于 <code>config/options.php</code>, 可以这样加载:</p><pre><code class="php">// 在 bootstrap/app.php 中$app-&gt;configure(&#39;options&#39;);</code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> Lumen </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel/Lumen教程1-基础环境搭建</title>
      <link href="/2017/12/30/Laravel-Lumen%E6%95%99%E7%A8%8B1-%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/12/30/Laravel-Lumen%E6%95%99%E7%A8%8B1-%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<blockquote><p>2018/4/20</p><p>今天再次尝试了 Homestead，的确非常好用，建议还是用 Homestead来弄，除非你喜欢折腾。</p><p><a href="/2018/04/20/舍弃phpStudy用Homestead搭建Laravel环境">舍弃phpStudy用Homestead搭建Laravel环境</a></p></blockquote><p>网上搭建 Laravel/Lumen 环境的文章挺多的，但是一路操作下来还是很多坑，在此我整理了 Windows 和 Linux 下几种环境搭建方法。</p><h1 id="一、-Windows篇"><a href="#一、-Windows篇" class="headerlink" title="一、 Windows篇"></a>一、 Windows篇</h1><h2 id="1-下载最新版-phpstudy、mysql（压缩版）、PHPmyadmin"><a href="#1-下载最新版-phpstudy、mysql（压缩版）、PHPmyadmin" class="headerlink" title="1. 下载最新版 phpstudy、mysql（压缩版）、PHPmyadmin"></a>1. 下载最新版 phpstudy、mysql（压缩版）、PHPmyadmin</h2><p>如果要用较新版本的 Laravel 或 Lumen ，对PHP以及其他软件的版本都有要求，然后 phpstudy 中mysql的版本较低，就需要手动来升级，当然如果所有环境都是手动搭建，没有使用 phpstudy 这样的工具可以忽略这里。</p><h2 id="2-更新-phpstudy-中的-mysql"><a href="#2-更新-phpstudy-中的-mysql" class="headerlink" title="2. 更新 phpstudy 中的 mysql"></a>2. 更新 phpstudy 中的 mysql</h2><ol><li>把 phpstud 目录下的 MYSQL 文件夹重命名备份，新建一个空MYSQL文件夹；</li><li>把下载的压缩版 mysql ，解压到 MYSQL ，确保里面没有 data 文件夹，有的话删掉；</li><li>以管理员权限进入其中的bin目录，执行 <code>mysqld --initialize</code> ，成功后执行 <code>mysqld -install</code> ,成功后再执行 <code>net start mysql</code> 进行启动测试；</li><li><code>mysql -uroot -p</code> ，执行后要求输入密码，输入enter，提示错误，不用管；</li><li>前往data文件夹找到err文件，记事本打开你们可以找到一个随机密码，复制随机密码（随机密码是 mysql5.7 以上才有的，以前的版本没有密码）;</li><li>再次 <code>mysql -uroot -p</code> ，执行后输入刚刚复制的密码;</li><li><p>修改密码，命令如下：</p><pre><code>// 两种方法，优先试第一个SET PASSWORD = PASSWORD(&#39;root&#39;);//或update mysql.user set authentication_string=password(&#39;root&#39;) where user=&#39;root&#39; and Host = &#39;localhost&#39;;//原先改密码都是password列，但是5.7改成了authentication_string</code></pre></li></ol><h2 id="3-更新-phpmyadmin-，不更新的话进行数据库迁移时可能报编码方面的错误"><a href="#3-更新-phpmyadmin-，不更新的话进行数据库迁移时可能报编码方面的错误" class="headerlink" title="3. 更新 phpmyadmin ，不更新的话进行数据库迁移时可能报编码方面的错误"></a>3. 更新 phpmyadmin ，不更新的话进行数据库迁移时可能报编码方面的错误</h2><p>直接下载最新版，和更新 mysql 一样备份、新建、粘贴即可。</p><h2 id="4-按上述操作存在的问题："><a href="#4-按上述操作存在的问题：" class="headerlink" title="4. 按上述操作存在的问题："></a>4. 按上述操作存在的问题：</h2><ol><li>mysql 更新后一直常驻服务中，phpstudy的控制器不能控制其关闭，解决办法为到系统服务中设置mysql服务为手动模式，然后停止，然后在phpstudy上重启两个服务即可。</li></ol><h2 id="5-安装-composer-环境"><a href="#5-安装-composer-环境" class="headerlink" title="5. 安装 composer 环境"></a>5. 安装 composer 环境</h2><p>Windows 下建议使用<a href="http://docs.phpcomposer.com/00-intro.html#Installation-Windows" target="_blank" rel="noopener">自动安装程序</a>，会自动配置好环境变量，比较方便。配置国内镜像地址什么的就不多说了。</p><h2 id="6-安装-node-js-环境"><a href="#6-安装-node-js-环境" class="headerlink" title="6. 安装 node.js 环境"></a>6. 安装 node.js 环境</h2><p>这个在 Laravel 渲染页面时需要用到，只用Lumen的话可以先不装。</p><h1 id="二、-Linux篇"><a href="#二、-Linux篇" class="headerlink" title="二、 Linux篇"></a>二、 Linux篇</h1><p>Linux 下环境配置有多种选择：</p><ul><li>laradock（基于docker）</li><li>直接在本地搭建</li><li>Homestead（基于虚拟机）</li></ul><h2 id="使用-docker-laradock-在-deepin-上搭建"><a href="#使用-docker-laradock-在-deepin-上搭建" class="headerlink" title="使用 docker + laradock 在 deepin 上搭建"></a>使用 docker + laradock 在 deepin 上搭建</h2><h3 id="1-安装-docker"><a href="#1-安装-docker" class="headerlink" title="1. 安装 docker"></a>1. 安装 docker</h3><p>深度官方deepin已经集成了docker，不过不是docker-ce这样的最新版。要想使用最新版可以参考官网debian安装教程安装，不过由于深度在定制过程中进行了大量修改，所以使用官方教程是安装不成功的。具体需要几个地方进行调整。先说说安装步骤：</p><p>1.如果以前安装过老版本，可以先卸载以前版本</p><pre><code>sudo apt-get remove docker docker-engine</code></pre><p>2.安装docker-ce与密钥管理与下载相关的依赖库</p><pre><code>sudo apt-get install apt-transport-https ca-certificates curl python-software-properties software-properties-common</code></pre><p>3.下载并安装密钥<br>建议选用国内源</p><pre><code>官方源：curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -国内源：curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</code></pre><p>4.添加源</p><pre><code>官方源：sudo add-apt-repository   &quot;deb [arch=amd64] https://download.docker.com/linux/debian   wheezy   stable&quot;国内源：sudo add-apt-repository   &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian   wheezy   stable&quot;</code></pre><p>5.更新仓库缓存</p><pre><code>sudo apt-get update</code></pre><p>6.安装docker-ce</p><pre><code>sudo apt-get install docker-ce</code></pre><h3 id="2-安装docker-compose"><a href="#2-安装docker-compose" class="headerlink" title="2. 安装docker-compose"></a>2. 安装docker-compose</h3><pre><code>pip install docker-compose</code></pre><h3 id="3-安装laradock"><a href="#3-安装laradock" class="headerlink" title="3. 安装laradock"></a>3. 安装laradock</h3><p>1.首先将 Laradock 项目代码克隆到本地：</p><pre><code>git clone https://github.com/Laradock/laradock.git</code></pre><p>2.进入 laradock 目录将 env-example 重命名为 .env：</p><pre><code>cp env-example .env</code></pre><p>3.运行容器：</p><pre><code>docker-compose up -d nginx mysql</code></pre><p>如果指定端口已经被占用，运行上述命令会报错，关闭相应的服务再重新运行上述命令即可。<br>如果找不到相关进程，在<code>.env</code>文件和<code>docker-compose.yml</code>文件中把nginx所用的403端口改成其他不冲突的即可。</p><p>报错内容如下：</p><blockquote><p>ERROR: for cd993bb246d5_laradock_nginx_1  Cannot start service nginx: driver failed programming external connectivity on endpoint cd993bb246d5_laradock_nginx_1 (7649ab2378acba94e996a87b242e44b4aa559cb3fa3223c53845d5fde233cd60): Error starting userland proxy: listen tcp 0.0.0.0:443: bind: address already in use</p></blockquote><blockquote><p>ERROR: for nginx  Cannot start service nginx: driver failed programming external connectivity on endpoint cd993bb246d5_laradock_nginx_1 (7649ab2378acba94e996a87b242e44b4aa559cb3fa3223c53845d5fde233cd60): Error starting userland proxy: listen tcp 0.0.0.0:443: bind: address already in use</p></blockquote><blockquote><p>ERROR: Encountered errors while bringing up the project.</p></blockquote><p>4.进入容器并切换到laradock用户</p><pre><code>docker-compose exec workspace bashsu laradock</code></pre><p>直接以laradock身份进入会报错，我也不知道为什么</p><p>报错内容如下：</p><blockquote><p>Traceback (most recent call last):<br>  File “/usr/local/bin/docker-compose”, line 11, in <module><br>    sys.exit(main())<br>  File “/usr/local/lib/python2.7/dist-packages/compose/cli/main.py”, line 68, in main<br>    command()<br>  File “/usr/local/lib/python2.7/dist-packages/compose/cli/main.py”, line 121, in perform_command<br>    handler(command, command_options)<br>  File “/usr/local/lib/python2.7/dist-packages/compose/cli/main.py”, line 417, in exec_command<br>    service = self.project.get_service(options[‘SERVICE’])<br>  File “/usr/local/lib/python2.7/dist-packages/compose/project.py”, line 147, in get_service<br>    raise NoSuchService(name)<br>  File “/usr/local/lib/python2.7/dist-packages/compose/project.py”, line 666, in <strong>init</strong><br>    self.msg = “No such service: %s” % self.name<br>UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe2 in position 0: ordinal not in range(128)</module></p></blockquote><h3 id="4-安装-composer-和-node-js"><a href="#4-安装-composer-和-node-js" class="headerlink" title="4. 安装 composer 和 node.js"></a>4. 安装 composer 和 node.js</h3><p>参考本地环境搭建的步骤3 和 Windows 篇的步骤6。</p><h2 id="直接在-Linux（deepin）-本地搭建环境"><a href="#直接在-Linux（deepin）-本地搭建环境" class="headerlink" title="直接在 Linux（deepin） 本地搭建环境"></a>直接在 Linux（deepin） 本地搭建环境</h2><h3 id="1-安装LNMP-和-phpmyadmin"><a href="#1-安装LNMP-和-phpmyadmin" class="headerlink" title="1. 安装LNMP 和 phpmyadmin"></a>1. 安装LNMP 和 phpmyadmin</h3><pre><code>sudo apt install lnmpsudo apt install phpmyadmin</code></pre><p>设置软链接</p><pre><code>sudo ln -s /usr/share/phpmyadmin /var/www/html</code></pre><h3 id="2-配置nginx："><a href="#2-配置nginx：" class="headerlink" title="2. 配置nginx："></a>2. 配置nginx：</h3><p>打开<code>/etc/nginx/sites-available</code>目录，修改<code>default</code>：</p><ul><li>将<code>server_name _;</code>改成<code>server_name localhost;</code></li><li>将其中php部分改成如下：</li></ul><pre><code># pass PHP scripts to FastCGI server#location ~ \.php$ {    include snippets/fastcgi-php.conf;    # With php-fpm (or other unix sockets):    fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;    # With php-cgi (or other tcp sockets):    #fastcgi_pass 127.0.0.1:9000;}</code></pre><ul><li>重启nginx</li><li>打开<a href="http://localhost/phpmyadmin，可以正常打开则配置完毕" target="_blank" rel="noopener">http://localhost/phpmyadmin，可以正常打开则配置完毕</a></li></ul><h3 id="3-安装composer并设置到全局"><a href="#3-安装composer并设置到全局" class="headerlink" title="3. 安装composer并设置到全局"></a>3. 安装composer并设置到全局</h3><p>安装</p><pre><code>curl -sS https://getcomposer.org/installer | php//orphp -r &quot;readfile(&#39;https://getcomposer.org/installer&#39;);&quot; | php</code></pre><p>设置全局</p><pre><code>sudo chmod a+x composer.pharsudo mv composer.phar /usr/local/bin/composer</code></pre><p>设置自动更新</p><pre><code>sudo composer self-update</code></pre><p>设置国内镜像源</p><pre><code>composer config -g repo.packagist composer https://packagist.phpcomposer.com</code></pre><h2 id="用-Homestead（基于虚拟机）搭建环境"><a href="#用-Homestead（基于虚拟机）搭建环境" class="headerlink" title="用 Homestead（基于虚拟机）搭建环境"></a>用 Homestead（基于虚拟机）搭建环境</h2><p>Homestead 环境我没有搭成功，坑比较多，这里给出一篇教程，感兴趣的可以按着来，下面我还会贴出我碰到的一些坑。</p><p><a href="https://d.laravel-china.org/docs/5.5/homestead" target="_blank" rel="noopener">Laravel 虚拟开发环境 Homestead</a>。</p><h3 id="坑1-box文件的下载以及add"><a href="#坑1-box文件的下载以及add" class="headerlink" title="坑1: box文件的下载以及add"></a><strong>坑1:</strong> box文件的下载以及add</h3><p>1.安装上面文档的指引，需要执行这个命令来下载box文件</p><pre><code class="shell">vagrant box add laravel/homestead</code></pre><blockquote><p>由于下载box的时候需要挂 VPN ，而且下载文件大小比较大，为了节省时间，所以在下载的时候，按 ctrl+c 取消，复制下载地址，格式如下：<br><a href="https://atlas.hashicorp.com/laravel/boxes/homestead/versions/4.0.0/providers/virtualbox.box" target="_blank" rel="noopener">https://atlas.hashicorp.com/laravel/boxes/homestead/versions/4.0.0/providers/virtualbox.box</a><br>其中版本改成执行命令后系统默认选择的版本</p></blockquote><p>2.下载完之后放在任意一个英文目录下重命名为 homestead.box<br>3.在.box文件同目录下新建 metadata.json 文件</p><pre><code class="json">{  &quot;name&quot;: &quot;laravel/homestead&quot;,  &quot;versions&quot;: [{    &quot;version&quot;: &quot;4.0.0&quot;,    &quot;providers&quot;: [{      &quot;name&quot;: &quot;virtualbox&quot;,      &quot;url&quot;: &quot;./homestead.box&quot;    }]  }]}</code></pre><p>4.运行指令安装 box</p><pre><code>vagrant box add metadata.json</code></pre><p>5.查看安装的box</p><pre><code>vagrant box listlaravel/homestead (virtualbox, 4.0.0)﻿​</code></pre><h3 id="坑2-NFS"><a href="#坑2-NFS" class="headerlink" title="坑2: NFS"></a><strong>坑2:</strong> NFS</h3><p>NFS是为了提高本机和虚拟机之间文件共享的效率，安装文档中也有提及。<br>但是但我们执行</p><pre><code>vagrant up</code></pre><p>提示错误：</p><blockquote><p>It appears your machine doesn’t support NFS, or there is not an<br>adapter to enable NFS on this machine for Vagrant. Please verify<br>that `nfsd` is installed on your machine, and try again. If you’re<br>on Windows, NFS isn’t supported. If the problem persists, please<br>contact Vagrant support.</p></blockquote><p>这是因为我们没有安装nfs工具，我用的是deepin，所以我执行</p><pre><code>sudo apt install nfs-kernel-server</code></pre><p>即可，其他系统改一下前面的包管理工具。</p><h3 id="坑3-NFS继续报错（卡在这不想继续弄了，感兴趣的可以继续）"><a href="#坑3-NFS继续报错（卡在这不想继续弄了，感兴趣的可以继续）" class="headerlink" title="坑3: NFS继续报错（卡在这不想继续弄了，感兴趣的可以继续）"></a><strong>坑3:</strong> NFS继续报错（卡在这不想继续弄了，感兴趣的可以继续）</h3><p>在我输入<code>vagrant up</code>后，NFS居然又抱错了，如下：</p><blockquote><p>==&gt; homestead-7: Mounting NFS shared folders…<br>The following SSH command responded with a non-zero exit status.<br>Vagrant assumes that this means the command failed!</p></blockquote><blockquote><p>mount -o vers=3,udp,actimeo=1,nolock 192.168.10.1:/home/arony/Code/Lumen /home/vagrant/code/Lumen<br>result=$?<br>if test $result -eq 0; then<br>if test -x /sbin/initctl &amp;&amp; command -v /sbin/init &amp;&amp; /sbin/init 2&gt;/dev/null –version | grep upstart; then<br>/sbin/initctl emit –no-wait vagrant-mounted MOUNTPOINT=/home/vagrant/code/Lumen<br><strong>……太占地方，省略</strong><br>mesg: ttyname failed: Inappropriate ioctl for device<br>mount.nfs: Connection timed out</p></blockquote><h1 id="三、-mac-篇"><a href="#三、-mac-篇" class="headerlink" title="三、 mac 篇"></a>三、 mac 篇</h1><p>可以参考 Linux，或者使用 mac 独有的 <a href="https://d.laravel-china.org/docs/5.5/valet" target="_blank" rel="noopener">valet</a>。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> Lumen </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Markdown</title>
      <link href="/2017/11/01/%E5%85%B3%E4%BA%8EMarkdown/"/>
      <url>/2017/11/01/%E5%85%B3%E4%BA%8EMarkdown/</url>
      <content type="html"><![CDATA[<blockquote><p>2018/3/23 更新</p><p>后来找到好几个支持 Markdown 导出 PDF 的工具，都已经添加第一点中，所以好像这个项目也没什么用了。</p><p>留个记录吧。</p></blockquote><h2 id="一、MarkDown工具"><a href="#一、MarkDown工具" class="headerlink" title="一、MarkDown工具"></a>一、MarkDown工具</h2><p>自从学了 Markdown ，从此特别喜欢用 Markdown 写东西，用过的工具有:</p><ul><li>vscode：仅有一个优点，代码编辑器，快捷键用到爽。</li><li><a href="http://www.jianshu.com/" target="_blank" rel="noopener">简书</a>：云同步，预览也好看，图片插入也不是问题，但是不能导出，数据放别人那总有点不安心。</li><li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a>：云同步，预览好看，但是导出和插图要付费。</li><li><a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">HexoEditor</a>：国内插图的一个完美解决方案，还可以导出PDF，但是暂不支持云同步。</li><li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>：写 Markdown 最爽的，图片存本地，也是一种比较好的解决方案，导出也OK。</li></ul><p>其实我个人觉得 Markdown 的两个痛点在于图片插入和导出，这个两个功能大部分都是需要付费的，然后还有一个加分项就是云同步，所以上面的工具见仁见智吧。</p><h2 id="二、导出成PDF"><a href="#二、导出成PDF" class="headerlink" title="二、导出成PDF"></a>二、导出成PDF</h2><p>Markdown用的多了，有时候要给其他人写一些文档就很不适应再用Word啥的，但是又不能要求别人能够把md文件拖到解析markdown的工具里显示，于是导出成PDF就成了一种比较好的解决方案。于是问题来了？</p><blockquote><p>如何方便的将markdown文件导出成漂亮的PDF文件？  </p></blockquote><p>市面上大多数将markdown导出成pdf的工具都需要开会员，于是我找了两个方法来解决这个问题。</p><h2 id="三、两种导出漂亮PDF文件的方法"><a href="#三、两种导出漂亮PDF文件的方法" class="headerlink" title="三、两种导出漂亮PDF文件的方法"></a>三、两种导出漂亮PDF文件的方法</h2><h3 id="1-通过vscode插件"><a href="#1-通过vscode插件" class="headerlink" title="1. 通过vscode插件"></a>1. 通过vscode插件</h3><p>上面的集中书写工具中，vscode可以通过安装<code>Markdown PDf</code>插件，将markdown格式的文件导出成PDF，同时支持自定义markdown的样式，成了一种不错的解决方案，但是需要自己写css样式或者去网上找比较漂亮的样式，否则导出的PDF文件美观程度上实在差强人意。</p><blockquote><p>在window系统下，通过上面的步骤就可以了，但是在Linux或者MAC下，安装后右键–convert to pdf会报错：ERROR: phantomjs binary does not exist: /Users/username/.vscode/extensions/yzane.markdown-pdf-0.1.7/node_modules/phantomjs-prebuilt/lib/phantom\bin\phantomjs.exe<br>这时候需要安装phantomjs才可以使用：<br>MAC：brew install phantomjs<br>Linux：sudo apt-apt install phantomjs</p></blockquote><h3 id="2-通过Cmd-Markdown导出的无样式html"><a href="#2-通过Cmd-Markdown导出的无样式html" class="headerlink" title="2. 通过Cmd Markdown导出的无样式html"></a>2. 通过Cmd Markdown导出的无样式html</h3><p>第二种方法比较复杂，但是可以导出比较漂亮PDF文件，并且支持甘特图和流程图等，当然如果第一种方法有比较漂亮的CSS样式且不需要用太多复杂的加强markdown语法，就还是建议用第一种方案，毕竟更简单。</p><h4 id="第一步：将markdown转换为html文件"><a href="#第一步：将markdown转换为html文件" class="headerlink" title="第一步：将markdown转换为html文件"></a>第一步：将markdown转换为html文件</h4><p>Cmd Markdown 支持导出无样式的html、有样式的html、PDF，但是后两者需要开通会员，不用去考虑。就选择导出为无样式的html，导出后得到的显示效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2662764-90d3c5d69f8f73da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不带样式的html"></p><h4 id="第二步：将html文件补足样式"><a href="#第二步：将html文件补足样式" class="headerlink" title="第二步：将html文件补足样式"></a>第二步：将html文件补足样式</h4><p>这样得到的html文件没有样式并不好看，哪去哪找漂亮的样式呢？答案是<a href="https://www.zybuluo.com/static/editor/cmd-manual.html" target="_blank" rel="noopener">Cmd Markdown 自己的带样式网页</a>。<br>从这个页面上把css下载过来，link到不带样式的html文件中，得到带样式的网页：</p><p><img src="http://upload-images.jianshu.io/upload_images/2662764-5b4f301c31ff5cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="带样式的html"></p><p>但是还存在一个问题，link了CSS文件后，内容的显示占了屏幕的100%宽度，并不好看 ，自己对比之后发现官方的页面中id为<code>wmd-preview</code>的元素的Class为<code>wmd-preview wmd-preview-full-reader</code>，而导出的无样式文件不含<code>wmd-preview-full-reader</code>这个class，可以用js插入这个class：</p><pre><code class="javascript">&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(document).ready(function () {    // 修改样式    $(&quot;#wmd-preview&quot;).addClass(&quot;wmd-preview-full-reader&quot;);    })  });&lt;/script&gt;</code></pre><h4 id="第三步：将html页面进一步美化"><a href="#第三步：将html页面进一步美化" class="headerlink" title="第三步：将html页面进一步美化"></a>第三步：将html页面进一步美化</h4><p>Cmd Markdown的官方样式已经很漂亮了，但是比较简书，有一点美中不足，简书中插入的图片下面会有一个图片的alt作为图片的标题，可以让文档看起来更清晰，还有其他的一些细节也是比Cmd Markdown做的好的。因此结合此两者的样式就可以得到一个漂亮的样式了。</p><p><img src="http://upload-images.jianshu.io/upload_images/2662764-94a819ed95fad14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="简书下用alt作为图片的名字"></p><p>因此可以进一步修改Cmd Markdown的官方样式，使其拥有简书的效果，代码如下：<br>Js修改样式：</p><pre><code class="javascript">&lt;link href=&quot;../static/assets/myCss.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(document).ready(function () {    // 修改样式    $(&quot;#wmd-preview&quot;).addClass(&quot;wmd-preview-full-reader&quot;);    $(&quot;body&quot;).css(&quot;background-color&quot;, &quot;#fcfaf2&quot;);    $(&quot;.white-blockquote&quot;).css(&quot;background&quot;, &quot;whitesmoke&quot;);    $(&quot;body&quot;).css(&quot;background-color&quot;, &quot;#fcfaf2&quot;);    $(&quot;h1,h2,h3,h4,h5,h6&quot;).css(&quot;font-weight&quot;, &quot;700&quot;);    $(&quot;pre.prettyprint&quot;).css(&quot;background-color&quot;, &quot;whitesmoke&quot;);    $(&quot;.theme-white&quot;).css(&quot;background-color&quot;, &quot;#e5e5e5&quot;);    $(&quot;.theme-white.sequence-diagram [fill=&#39;#ffffff&#39;], .theme-white.flow-diagram [fill=&#39;#ffffff&#39;]&quot;).css(&quot;fill&quot;, &quot;#e5e5e5&quot;);    $(&quot;img&quot;).parent().addClass(&quot;image-package&quot;)    $(&quot;img&quot;).each(function () {      var that = $(this);      var alt = that.attr(&quot;alt&quot;);      var add = &#39;&lt;br&gt;&lt;div class=&quot;image-caption&quot;&gt;&#39;+ alt +&#39;&lt;/div&gt;&#39;;      var html = that.parent().html() + add;      that.parent().html(html);    })  });&lt;/script&gt;</code></pre><p>复制简书该图片效果的样式到myCss.css中</p><pre><code class="css">.image-package {  padding-bottom: 25px;  text-align: center;}.image-caption {  min-width: 20%;  max-width: 80%;  min-height: 22px;  display: inline-block;  padding: 10px;  margin: 0 auto;  border-bottom: 1px solid #d9d9d9;  font-size: 14px;  color: #969696;  line-height: 1.7;}</code></pre><p>修改后得到的html显示效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2662764-8ad47d0bbb9b4c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>自此，就成功的将markdown转变成了比较漂亮的html文件。<a href="http://md.yfree.cc/page" target="_blank" rel="noopener">样例地址</a><br>这时候可以把文件上传到gitpage或者自己的服务器，然后得到链接就能发给其他人看了，但是一般大家也不会用html文件来作为互相发送的文档（虽然我个人觉得这样用起来也可以），所以继续下一步：将html转换为pdf。</p><h4 id="第四步：将html转换为pdf"><a href="#第四步：将html转换为pdf" class="headerlink" title="第四步：将html转换为pdf"></a>第四步：将html转换为pdf</h4><p>在网上找了很久，将html转换为html大多也是要付费的，但也有免费而且效果不错的，下面列举出来：</p><ol><li>用chrome浏览器，Ctrl+P，然后点击<em>更改</em>，可以选择<em>保存为PDF</em>，但是这样导出的PDF没有样式，不推荐，不过也在此提一下；</li><li><a href="https://pdfcrowd.com/" target="_blank" rel="noopener">PDFCROWD</a>，这个可以导出带样式的，但是需要先将html文件带上样式都传到服务器上，然后把链接给过去，缺点是不付费的话导出的pdf纸张大小很奇怪，还每一页都加上了水印，也不推荐。</li><li><a href="https://www.html-to-pdf.net/free-online-pdf-converter.aspx" target="_blank" rel="noopener">EXPERT</a>，这个可以完美的导出带样式的PDF，但是要求先把html文件和样式传到服务器上，然后给出链接。推荐给有服务器的同学。</li><li><a href="https://wkhtmltopdf.org/index.html" target="_blank" rel="noopener">wkhtmltopdf</a>，最推荐的一个，本地安装一下，然后敲个命令行就可以了。<pre><code class="shell">wkhtmltopdf 本地或网上页面的地址 要导出的路径</code></pre><h2 id="四、github项目地址"><a href="#四、github项目地址" class="headerlink" title="四、github项目地址"></a>四、github项目地址</h2><a href="https://github.com/skyArony/md-style" target="_blank" rel="noopener">github项目地址</a></li></ol>]]></content>
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一次项目的 RESRful API 设计记录</title>
      <link href="/2017/10/27/%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E7%9A%84RESRful-API%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/10/27/%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E7%9A%84RESRful-API%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="一、RESTful是什么"><a href="#一、RESTful是什么" class="headerlink" title="一、RESTful是什么"></a>一、RESTful是什么</h1><p>RESTful API是一种 Web 设计架构，翻译成中文就是「表现层状态转移」。</p><ul><li>资源：网络上的每一个实体或数据信息，都是一个资源。</li><li>表现层：资源以某种序列化的格式展现出来的形式。</li><li>URI：只代表资源的实体，而不代表资源的形式。相当于起标识符和地址，每一个资源都有其URI与之对应，最典型的URI就是URL</li><li>状态转化：就是通过某种手段让 URI 所代表的实体在表现层发生状态的转化，表现在HTTP协议里面，就是GET/POST/PUT/DELETE 四种动作对应的四种操作</li></ul><p>基于以上特点，阮一峰老师给出了一个比较易懂的解释：</p><blockquote><p>（1）每一个URI代表一种资源；</p><p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p></blockquote><p>如果还看不到，我这还有一个更加通俗化的解释：</p><blockquote><p>看Url就知道要什么<br>看http method就知道干什么<br>看http status code就知道结果如何  </p><p>——知乎 徐磊</p></blockquote><p>接下来，列举网上找到的参考资料，然后通过这些资料整理一个适合工作室的RESTful设计规范，并以此规范完成工作室<code>API2.0</code>。</p><h1 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h1><ul><li>GitHub上一个项目：<a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">RESTful API 设计参考文献列表</a></li><li><a href="https://blog.igevin.info/posts/restful-api-get-started-to-write/" target="_blank" rel="noopener">RESTful API 编写指南</a></li><li><a href="https://www.zhihu.com/question/58686782" target="_blank" rel="noopener">知乎-关于 RESTful API 中 HTTP 状态码的定义的疑问？-Liril</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰老师的跨域资源共享 CORS 详解</a></li><li><a href="https://blog.igevin.info/posts/restful-architecture-in-general/" target="_blank" rel="noopener">RESTful 架构风格概述 - Gevin</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">阮一峰老师的理解RESTful架构</a></li></ul><h1 id="三、RESTful设计"><a href="#三、RESTful设计" class="headerlink" title="三、RESTful设计"></a>三、RESTful设计</h1><h2 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h2><p>必须https。</p><h2 id="2-单独的域名"><a href="#2-单独的域名" class="headerlink" title="2. 单独的域名"></a>2. 单独的域名</h2><pre><code>https://api.example.com</code></pre><h2 id="3-HTTP动词"><a href="#3-HTTP动词" class="headerlink" title="3. HTTP动词"></a>3. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><pre><code>GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。DELETE（DELETE）：从服务器删除资源。</code></pre><p>下面是一些例子</p><pre><code>GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</code></pre><p>值得注意的是PUT和PATCH的区别：</p><ul><li>更新一个资源的全部信息时采用<code>PUT</code></li><li>更新一个资源的部分信息时采用<code>PATCH</code></li></ul><h2 id="4-版本化"><a href="#4-版本化" class="headerlink" title="4. 版本化"></a>4. 版本化</h2><p>将API的版本号放进URL中：</p><pre><code># 这样比较方便直观https://api.example.com/v1/# 放到 header 中，这样更符合 RESTful 设计理念X-GitHub-Media-Type: github.v3</code></pre><p>到底该怎么办，见仁见智吧，因为 RESTful 只是一种设计理念，太过于教条化的追求反而犯了更大的错误。</p><h2 id="5-路径"><a href="#5-路径" class="headerlink" title="5. 路径"></a>5. 路径</h2><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有<strong>名词</strong>，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用<strong>复数</strong>。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样：</p><pre><code>https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees</code></pre><h2 id="6-分析-amp-限制"><a href="#6-分析-amp-限制" class="headerlink" title="6. 分析&amp;限制"></a>6. 分析&amp;限制</h2><p>对整个API系统必须有一套完整的跟踪和分析系统，要求实现以下功能：</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>记录接口调用次数（要求可以自定义时间段进行统计，自定义用户进行查询）</li><li>记录接口的输入和调用结果</li><li>记录接口的平均耗时和最高耗时（要求可以自定义时间段进行统计，自定义用户进行查询） // 这个暂时不用实现</li></ol><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>针对用户权限进行调用次数的限制<br>为了避免请求泛滥，给API设置速度限制很重要。为此 RFC 6585 引入了HTTP状态码429（too many requests）。加入速度设置之后，应该提示用户,流行的方法是使用HTTP的返回头。</p><p>下面是几个必须的返回头（依照twitter的命名规则）：</p><ul><li>X-Rate-Limit-Limit :当前时间段允许的并发请求数</li><li>X-Rate-Limit-Remaining :当前时间段保留的请求数</li><li>X-Rate-Limit-Used : 当前时间段已用的请求数</li><li>X-Rate-Limit-Reset :当前时间段剩余秒数</li></ul><h2 id="7-过滤-amp-分页"><a href="#7-过滤-amp-分页" class="headerlink" title="7. 过滤&amp;分页"></a>7. 过滤&amp;分页</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p><pre><code>?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件</code></pre><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，<code>GET /zoo/ID/animals</code> 与 <code>GET /animals?zoo_id=ID</code> 的含义是相同的。</p><h2 id="8-状态码-amp-数据缓存"><a href="#8-状态码-amp-数据缓存" class="headerlink" title="8. 状态码 &amp; 数据缓存"></a>8. 状态码 &amp; 数据缓存</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><a href="http://clojure-liberator.github.io/liberator/doc/decisions.html" target="_blank" rel="noopener">完整的状态码处理逻辑图</a></p><p>在 Response header 中设置http状态码<br>同时还应在 Response body 中设置其他信息：</p><ul><li>错误code</li><li>错误信息</li><li>header（可选）</li><li>debug（可选）</li></ul><ul><li>http status码（可选，只是为了方便）</li></ul><p>服务器向用户返回的状态码和提示信息，本设计规范会用到的有以下这些（方括号中是该状态码对应的HTTP动词）。</p><blockquote><ul><li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功，没有需要返回的内容，不需要刷新当前视图。<strong>但是要真这么写的话，dingo中一旦用了204就什么都不返回了，所以看到不要奇怪</strong></li></ul><ul><li>304 Not Modified - [GET]：请求的数据没有更新。</li></ul><ul><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的，所有不想明确区分的客户端请求出错都可以返回 400，比如参数错误</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的，比如低权限账户请求了高权限账户才能请求的接口。</li><li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li><li>405 Method Not Allowed - [*]：用户发出的请求方式是不被允许通过的。</li><li>408 Request Timeout - [*]：客户端请求超时。我们想 POST 创建一个用户，虽然建立了连接，但是网络不好，服务器在规定时间内没有得到我们的请求信息，这时候服务器可以返回 408 告诉我们超时了。然后我们可以重新发送请求。</li><li>409 Conflict - [*]：请求冲突。比如说，服务器要求不同用户不能重名，服务器已经有了一个名叫小伟的用户，这时候我们又想创建一个名叫小伟的用户，服务器可以返回 409，告诉我们冲突了，也可以在 body 中明确告知是什么冲突了。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>413 Request Entity Too Large -[POST/PUT/PATCH]：请求体过大。比如说，服务器要求上传文件不能超过 5M，但是我们 POST 了 10M，这时候就返回 413。</li></ul><ul><li>429 too many requests -[*]：请求速度过快、请求次数已达帐号上限。</li></ul><ul><li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li><li>503 Service Unavailable - [*]：服务暂时不可用。比如说，服务器正好在更新代码重启。</li></ul></blockquote><p>状态码的完全列表参见<a href="https://httpstatuses.com/" target="_blank" rel="noopener">这里</a>。</p><blockquote><ul><li><p>1xx范围的状态码是保留给底层HTTP功能使用的，并且估计在你的职业生涯里面也用不着手动发送这样一个状态码出来。</p></li><li><p>2xx范围的状态码是保留给成功消息使用的，你尽可能的确保服务器总发送这些状态码给用户。</p></li><li><p>3xx范围的状态码是保留给重定向用的。大多数的API不会太常使用这类状态码，但是在新的超媒体样式的API中会使用更多一些。</p></li><li><p>4xx范围的状态码是保留给客户端错误用的。例如，客户端提供了一些错误的数据或请求了不存在的内容。这些请求应该是幂等的，不会改变任何服务器的状态。</p></li><li><p>5xx范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，并且开发人员也通常没法处理。发送这类状态码的目的是确保客户端能得到一些响应。收到5xx响应后，客户端没办法知道服务器端的状态，所以这类状态码是要尽可能的避免。</p></li></ul></blockquote><h3 id="关于202"><a href="#关于202" class="headerlink" title="关于202"></a>关于202</h3><p>对耗时的异步任务，服务器端接受客户端传递的参数后，应返回创建成功的任务资源，其中包含了任务的执行状态。客户端可以轮训该任务获得最新的执行进度。</p><pre><code>提交任务：POST /batch-publish-msg[{&quot;from&quot;:0,&quot;to&quot;:1,&quot;text&quot;:&quot;abc&quot;},{},{}...]返回：{&quot;taskId&quot;:3,&quot;createBy&quot;:&quot;Anonymous&quot;,&quot;status&quot;:&quot;running&quot;}GET /task/3{&quot;taskId&quot;:3,&quot;createBy&quot;:&quot;Anonymous&quot;,&quot;status&quot;:&quot;success&quot;}</code></pre><p>如果任务的执行状态包括较多信息，可以把“执行状态”抽象成组合资源，客户端查询该状态资源了解任务的执行情况。</p><pre><code>提交任务：POST /batch-publish-msg[{&quot;from&quot;:0,&quot;to&quot;:1,&quot;text&quot;:&quot;abc&quot;},{},{}...]返回：{&quot;taskId&quot;:3,&quot;createBy&quot;:&quot;Anonymous&quot;}GET /task/3/status{&quot;progress&quot;:&quot;50%&quot;,&quot;total&quot;:18,&quot;success&quot;:8,&quot;fail&quot;:1}</code></pre><h3 id="关于-304"><a href="#关于-304" class="headerlink" title="关于 304"></a>关于 304</h3><p>大部分接口应该在响应头中携带 <code>Last-Modified</code>, <code>ETag</code>, <code>Vary</code>, <code>Date</code> 信息，客户端可以在随后请求这些资源的时候，在请求头中使用 <code>If-Modified-Since</code>, <code>If-None-Match</code> 等请求头来确认资源是否经过修改。</p><p>如果资源没有进行过修改，那么就可以响应 <code>304 Not Modified</code> 并且不在响应实体中返回任何内容。例如：</p><pre><code>curl -i https://api.github.com/userHTTP/1.1 200 OKCache-Control: private, max-age=60ETag: &quot;644b5b0155e6404a9cc4bd9d8b1ae730&quot;Last-Modified: Thu, 05 Jul 2012 15:31:30 GMTStatus: 200 OKVary: Accept, Authorization, CookieX-RateLimit-Limit: 5000X-RateLimit-Remaining: 4996X-RateLimit-Reset: 1372700873curl -i https://api.github.com/user -H &#39;If-None-Match: &quot;644b5b0155e6404a9cc4bd9d8b1ae730&quot;&#39;HTTP/1.1 304 Not ModifiedCache-Control: private, max-age=60ETag: &quot;644b5b0155e6404a9cc4bd9d8b1ae730&quot;Last-Modified: Thu, 05 Jul 2012 15:31:30 GMTStatus: 304 Not ModifiedVary: Accept, Authorization, CookieX-RateLimit-Limit: 5000X-RateLimit-Remaining: 4996X-RateLimit-Reset: 1372700873curl -i https://api.github.com/user -H &quot;If-Modified-Since: Thu, 05 Jul 2012 15:31:30 GMT&quot;HTTP/1.1 304 Not ModifiedCache-Control: private, max-age=60Last-Modified: Thu, 05 Jul 2012 15:31:30 GMTStatus: 304 Not ModifiedVary: Accept, Authorization, CookieX-RateLimit-Limit: 5000X-RateLimit-Remaining: 4996X-RateLimit-Reset: 1372700873</code></pre><hr><h3 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p><strong>“no-cache”和“no-store”</strong></p><p><code>no-cache</code>表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。因此，如果存在合适的验证令牌 (ETag)，<code>no-cache</code> 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。</p><p>相比之下，<code>no-store</code>则要简单得多。它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。</p><p><strong>“public”与“private”</strong></p><p>如果响应被标记为<code>public</code>，则即使它有关联的 HTTP 身份验证，甚至响应状态代码通常无法缓存，也可以缓存响应。大多数情况下，<code>public</code>不是必需的，因为明确的缓存信息（例如<code>max-age</code>）已表示响应是可以缓存的。</p><p>相比之下，浏览器可以缓存<code>private</code>响应。不过，这些响应通常只为单个用户缓存，因此不允许任何中间缓存（CDN等）对其进行缓存。例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。</p><p><strong>“max-age”</strong></p><p>指令指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒）。例如，<code>max-age=60</code>表示可在接下来的 60 秒缓存和重用响应。</p><h4 id="选择合适的Cache-Control"><a href="#选择合适的Cache-Control" class="headerlink" title="选择合适的Cache-Control"></a><strong>选择合适的Cache-Control</strong></h4><p><img src="http://osv9x79o9.bkt.clouddn.com/17-11-7/30809467.jpg" alt="决策树"></p><table><thead><tr><th>Cache-Control指令</th><th>说明</th></tr></thead><tbody><tr><td>max-age=86400</td><td>浏览器以及任何中间缓存均可将响应（如果是“public”响应）缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。</td></tr><tr><td>private, max-age=600</td><td>客户端的浏览器只能将响应缓存最长 10 分钟（60 秒 x 10 分钟）。</td></tr><tr><td>no-store</td><td>不允许缓存响应，每次请求都必须完整获取。</td></tr></tbody></table><h4 id="废弃和更新缓存响应"><a href="#废弃和更新缓存响应" class="headerlink" title="废弃和更新缓存响应"></a><strong>废弃和更新缓存响应</strong></h4><p><em>如何才能鱼和熊掌兼得：客户端缓存和快速更新？</em>您可以在资源内容发生变化时更改它的网址，强制用户下载新响应。通常情况下，可以通过在文件名中嵌入文件的指纹或版本号来实现 - 例如 <code>style.x234dff.css</code>。</p><p><img src="http://osv9x79o9.bkt.clouddn.com/17-11-7/38495502.jpg" alt="一个缓存样例"></p><ul><li><p>HTML 被标记为<code>no-cache</code>，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时获取最新版本。此外，在 HTML 标记内，您在 CSS 和 JavaScript 资产的网址中嵌入指纹：如果这些文件的内容发生变化，网页的 HTML 也会随之改变，并会下载 HTML 响应的新副本。</p></li><li><p>允许浏览器和中间缓存（例如 CDN）缓存 CSS，并将 CSS 设置为 1 年后到期。请注意，您可以放心地使用 1 年的“远期过期”，因为您在文件名中嵌入了文件的指纹：CSS 更新时网址也会随之变化。</p></li><li><p>JavaScript 同样设置为 1 年后到期，但标记为 private，这或许是因为它包含的某些用户私人数据是 CDN 不应缓存的。</p></li><li><p>图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。</p></li></ul><hr><p>相关资料：</p><ul><li><a href="http://tools.ietf.org/html/rfc7232" target="_blank" rel="noopener">RFC 7232</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">HTTP 缓存 - Google Developers</a></li><li><a href="http://tools.ietf.org/html/rfc2616#section-13.2.3" target="_blank" rel="noopener">RFC 2616 中缓存过期时间的算法</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">MDN 版</a>, <a href="http://blog.csdn.net/woxueliuyun/article/details/41077671" target="_blank" rel="noopener">中文版</a></li><li><a href="https://www.imququ.com/post/vary-header-in-http.html" target="_blank" rel="noopener">HTTP 协议中 Vary 的一些研究</a></li><li><a href="https://blog.othree.net/log/2012/12/22/cache-control-and-etag/" target="_blank" rel="noopener">Cache Control 與 ETag</a></li></ul><h2 id="9-预期返回"><a href="#9-预期返回" class="headerlink" title="9. 预期返回"></a>9. 预期返回</h2><p>当使用不同的HTTP动词向服务器请求时，客户端需要在返回结果里面拿到一系列的信息，例如：</p><blockquote><ul><li><p>GET /collection：返回资源对象的列表（数组）</p></li><li><p>GET /collection/resource：返回单个资源对象</p></li><li><p>POST /collection：返回新生成的资源对象</p></li><li><p>PUT /collection/resource：返回完整的资源对象</p></li><li><p>PATCH /collection/resource：返回完整的资源对象</p></li><li><p>DELETE /collection/resource：返回一个空文档</p></li></ul></blockquote><p>总是在响应码为200或是201时返回所有可用资源, 包含 <code>PUT/PATCH</code> 和 <code>DELETE</code> 请求, 例如:</p><pre><code>$ curl -X DELETE \    https://service.com/apps/1f9b/domains/0fd4HTTP/1.1 200 OKContent-Type: application/json;charset=utf-8...{  &quot;created_at&quot;: &quot;2012-01-01T12:00:00Z&quot;,  &quot;hostname&quot;: &quot;subdomain.example.com&quot;,  &quot;id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,  &quot;updated_at&quot;: &quot;2012-01-01T12:00:00Z&quot;}</code></pre><p>当请求状态码为202（已加入异步队列）时，不返回所有可用资源,例如：</p><pre><code>$ curl -X DELETE \    https://service.com/apps/1f9b/dynos/05bdHTTP/1.1 202 AcceptedContent-Type: application/json;charset=utf-8...{}</code></pre><hr><h2 id="10-Hypermedia-amp-超文本驱动（可以看兴趣实现）"><a href="#10-Hypermedia-amp-超文本驱动（可以看兴趣实现）" class="headerlink" title="10. Hypermedia &amp; 超文本驱动（可以看兴趣实现）"></a>10. Hypermedia &amp; 超文本驱动（可以看兴趣实现）</h2><p>超文本驱动可以看做是Hypermedia的更高级实现。</p><h3 id="Hypermedia"><a href="#Hypermedia" class="headerlink" title="Hypermedia"></a>Hypermedia</h3><p>即返回结果中提供链接，连向其他API方法，这样做的好处是：用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到一个关于API文档的说明，就像<a href="https://api.github.com" target="_blank" rel="noopener">api.github.com</a></p><h3 id="超文本驱动"><a href="#超文本驱动" class="headerlink" title="超文本驱动"></a>超文本驱动</h3><p>客户端不再需要将某些接口的 URI 硬编码在代码中，唯一需要存储的只是 API 的 HOST 地址，能够非常有效的降低客户端与服务端之间的耦合，服务端对 URI 的任何改动都不会影响到客户端的稳定。<br>目前有几种方案试图实现这个效果：</p><ul><li><a href="http://tools.ietf.org/html/draft-kelly-json-hal-07" target="_blank" rel="noopener">JSON HAL</a> ，示例可以参考 <a href="http://stateless.co/hal_specification.html" target="_blank" rel="noopener">JSON HAL 作者自己的介绍</a></li><li><a href="https://developer.github.com/v3/#hypermedia" target="_blank" rel="noopener">GitHub API 使用的方案</a> ，应该是一种 JSON HAL 的变体</li><li><a href="http://jsonapi.org/" target="_blank" rel="noopener">JSON API</a> ，（这里有 <a href="https://github.com/justjavac" target="_blank" rel="noopener">@迷渡</a> 发起的 <a href="http://jsonapi.org.cn/" target="_blank" rel="noopener">中文版</a> ），另外一种类似 JSON HAL 的方案</li><li><a href="http://micro-api.org/" target="_blank" rel="noopener">Micro API</a> ，一种试图与 <a href="http://json-ld.org/" target="_blank" rel="noopener">JSON-LD</a> 兼容的方案</li></ul><p>目前所知的方案都实现了发现资源的功能，服务端同时需要实现 OPTIONS 方法，并在响应中携带 Allow 头来告知客户端当前拥有的操作权限。</p><h2 id="11-数据请求格式"><a href="#11-数据请求格式" class="headerlink" title="11. 数据请求格式"></a>11. 数据请求格式</h2><p>采用json。<br>在header中添加<code>Content-Type=application/json</code>。</p><h2 id="12-清晰的文档"><a href="#12-清晰的文档" class="headerlink" title="12. 清晰的文档"></a>12. 清晰的文档</h2><p>api必须拥有清晰的文档。</p><h2 id="13-鉴权-amp-无状态"><a href="#13-鉴权-amp-无状态" class="headerlink" title="13. 鉴权 &amp; 无状态"></a>13. 鉴权 &amp; 无状态</h2><p>JWT</p><h2 id="14-Enveloping"><a href="#14-Enveloping" class="headerlink" title="14. Enveloping"></a>14. Enveloping</h2><p>有两种情况是应该使用envelope的。</p><ul><li>如果API使用者确实无法访问返回头</li><li>API需要支持交叉域请求（通过jsonp）,<strong>本工作室Api需要跨域时请用CORS</strong>，所以这里忽略</li></ul><p>jsonp请求在请求的url中包含了一个<code>callback</code>函数参数。如果给出了这个参数，那么API应该返回200，并且把真正的状态码放到返回值里面（包装在信封里），例如：</p><pre><code>callback_function({  status_code: 200,  next_page: &quot;https://..&quot;,  response: {    ... actual JSON response body ...   }})</code></pre><p>同样为了支持无法访问返回头的API使用者，可以允许<code>envelope=true</code>这样的参数,例如:</p><pre><code>GET /api/v1/users/does-not-exist?envelope=true</code></pre><p>返回码为200，真正的返回码以及其他header信息放到返回的信息中：</p><pre><code>{  &quot;status&quot;: 404,  &quot;headers&quot;: {    &quot;Rate-Limit-Limit&quot;: 100,    &quot;Rate-Limit-Remaining&quot;: 50,    &quot;Rate-Limit-Used&quot;: 0,    &quot;Rate-Limit-Reset&quot;: 25  },  &quot;response&quot;: {    &quot;message&quot;: &quot;Not Found&quot;  }}</code></pre><h2 id="15-数据校验"><a href="#15-数据校验" class="headerlink" title="15. 数据校验"></a>15. 数据校验</h2><p>以json为例，当客户端向服务器发出<code>post</code>,<code>put</code>或<code>patch</code>请求时，通常会同时给服务器发送json格式的相关数据，服务器在做数据处理之前，先做数据校验，是最合理和安全的前后端交互。如果客户端发送的数据不正确或不合理，服务器端经过校验后直接向客户端返回400错误及相应的数据错误信息即可。常见的数据校验包括：</p><ul><li>数据类型校验，如字段类型如果是int，那么给字段赋字符串的值则报错</li><li>数据格式校验，如邮箱或密码，其赋值必须满足相应的正则表达式，才是正确的输入数据</li><li>数据逻辑校验，如数据包含出生日期和年龄两个字段，如果这两个字段的数据不一致，则数据校验失败</li></ul><p>以上三种类型的校验，数据逻辑校验最为复杂，通常涉及到多个字段的配合，或者要结合用户和权限做相应的校验。</p><h2 id="16-CORS——解决跨域"><a href="#16-CORS——解决跨域" class="headerlink" title="16. CORS——解决跨域"></a>16. CORS——解决跨域</h2><p>在RESTful API开发中，主要是为js服务的，CORS即解决javascript 调用 RESTful API时的跨域问题。具体可以参考<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰老师的跨域资源共享 CORS 详解</a></p><h2 id="17-命名规范"><a href="#17-命名规范" class="headerlink" title="17. 命名规范"></a>17. 命名规范</h2><ol><li>不用大写</li><li>RESTful API 应具备良好的可读性，当url中某一个片段（segment）由多个单词组成时，建议使用 - 来隔断单词，而不是使用 _，即：</li></ol><pre><code># Good/api/featured-post/# Bad/api/featured_post/</code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快查-Git</title>
      <link href="/2017/07/29/%E5%BF%AB%E6%9F%A5-Git/"/>
      <url>/2017/07/29/%E5%BF%AB%E6%9F%A5-Git/</url>
      <content type="html"><![CDATA[<p>Git 是管理代码等类文本文件版本最为方便的工具，学会 Git 会让你在版本管理方便省下许多功夫。</p><p>本文整理了一些常用的命令，便于自己快速查阅。</p><p><strong>参考资料：</strong></p><ol><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程-廖雪峰</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">Git简明指南</a></li><li><a href="http://wangchujiang.com/handbook/html/git.html" target="_blank" rel="noopener">handbook-git</a></li><li><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">Git的奇技淫巧</a></li></ol><h1 id="一、完整流程"><a href="#一、完整流程" class="headerlink" title="一、完整流程"></a>一、完整流程</h1><h2 id="1-下载-git"><a href="#1-下载-git" class="headerlink" title="1. 下载 git"></a>1. 下载 git</h2><p>一路点确定安装下去，先不要琢磨每个选项是什么用处，默认就好，以后再次安装时再看自然就明白了。</p><h2 id="2-相关配置"><a href="#2-相关配置" class="headerlink" title="2. 相关配置"></a>2. 相关配置</h2><p>安装好后第一步，就是先配置用户名和邮箱</p><h3 id="修改用户名和地址"><a href="#修改用户名和地址" class="headerlink" title="修改用户名和地址"></a>修改用户名和地址</h3><pre><code class="shell">git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot;</code></pre><h3 id="查看用户名和地址"><a href="#查看用户名和地址" class="headerlink" title="查看用户名和地址"></a>查看用户名和地址</h3><pre><code class="shell">git config user.namegit config user.emailgit config --list            # 查看信息的配置信息</code></pre><h2 id="3-配置SSH"><a href="#3-配置SSH" class="headerlink" title="3. 配置SSH"></a>3. 配置SSH</h2><p>若要与远程git服务器进行数据交互，大部分git服务都可以选择git方式和HTTPS方式，而git方式通过配置ssh可以更加方便的使用，所以接下来配置ssh</p><h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>   </p><ul><li><code>-t</code>是指定要创建的密钥类型，可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)。</li><li><code>-C</code>后面加上的是注释</li><li>生成密钥是第一个输入项是密钥的名字，第二个输入项<code>empty for no passphrase</code>留空并确认可达到登录时无需输入密码的效果</li></ul><p><code>ssh-add ~/.ssh/id_rsa</code>然后添加新生成的私钥，如果提示<code>Could not open a connection to your authentication agent.</code>,那么执行以下命令，然后再执行一次：</p><pre><code class="shell">eval `ssh-agent -s`</code></pre><h3 id="用config管理多个密钥"><a href="#用config管理多个密钥" class="headerlink" title="用config管理多个密钥"></a>用config管理多个密钥</h3><p>在<code>.ssh</code>目录下新建config文件，写入</p><pre><code class="shell">#github【名称】Host github.com【主机地址】HostName github.com【主机名】User git【用户名】IdentityFile ~/.ssh/github【私钥路径】</code></pre><p>以上内容为一组，写入保存后即可用 <code>ssh github.com</code> 来进行连接测试。</p><h3 id="发送公钥到-VPS-或-Git服务商"><a href="#发送公钥到-VPS-或-Git服务商" class="headerlink" title="发送公钥到 VPS 或 Git服务商"></a>发送公钥到 VPS 或 Git服务商</h3><pre><code class="shell"># 可以手动复制，也可以用这个命令发送过去ssh-copy-id -i ~/.ssh/id_rsa.pub &#39;git@vps地址&#39; -p &#39;ssh端口&#39;# 如果报错，把本地的 .ssh 文件夹中的 known_hosts 文件中的对应行删掉即可</code></pre><h3 id="SSH连接测试"><a href="#SSH连接测试" class="headerlink" title="SSH连接测试"></a>SSH连接测试</h3><pre><code class="shell">ssh -T git@&quot;git服务器地址&quot;</code></pre><p><strong>注：</strong></p><ul><li>创建成功后务必进行一次ssh测试</li><li>Windows下，ssh密钥的目录在~/.ssh,生成文件中带<code>.pub</code>后缀的是公钥，add到Gitlab或GitHub的SSH配置中</li><li>有时候还是会莫名其妙报错，去 <code>known_hosts</code> 中删除掉一些不用的远程服务器 key 即可</li></ul><h2 id="4-新建-amp-克隆"><a href="#4-新建-amp-克隆" class="headerlink" title="4. 新建 &amp; 克隆"></a>4. 新建 &amp; 克隆</h2><pre><code class="shell">git init            # 新建git clone 地址       # 克隆    </code></pre><h1 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><pre><code class="shell">git clone 地址    # 复制一个远程仓库git init    # 自己新建一个仓库</code></pre><h2 id="2-远程"><a href="#2-远程" class="headerlink" title="2. 远程"></a>2. 远程</h2><pre><code class="shell">git remote add origin git@jslite.github.com:JSLite/JSLite.git # 添加远程路径git remote set-url --add origin https://gitlab.com/wang/JSLite.js.git  # 再增加一个远程地址git remote set-url --delete origin https://oschina.net/wang/JSLite.js.git  # 删除一个远程地址git remote -v                    # 查看远程库信息git remote remove origin         # 删除该远程路径</code></pre><h2 id="3-拉取-amp-推送"><a href="#3-拉取-amp-推送" class="headerlink" title="3. 拉取 &amp; 推送"></a>3. 拉取 &amp; 推送</h2><pre><code class="shell">git pull                                      # 拉取，拉取只会拉取一个地址的内容git pull origin remotebranch:localbranch          # 拉取远程分支到本地分支git add &lt;filename&gt;                                # 添加文件git add .                                      # 添加所有文件git commit -m  &quot;提交信息&quot;                        # 提交到本地分支git push -u origin master                         # -u 指定默认主机，以后直接 git pushgit push -f                                     # 推送（强制）</code></pre><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><pre><code class="shell">git branch test             # 新建 test 分支git checkout dev         # 切换到指定分支git checkout -b dev       # 创建并同时切换到 dev 分支 git checkout -b dev origin/dev     # 基于远程 dev 分支创建本地 dev 分支并设置追踪git branch -m old new        # 重命名分支</code></pre><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><pre><code class="shell">git branch            # 查看所有分支，显示结果中前面带*号的为当前分支git branch -a         # 查看已知的所有分支（本地和远程）</code></pre><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><pre><code class="shell">git branch -m newname        # 重命名当前分支</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><pre><code class="shell">git merge origin/master     # 在本地分支上合并远程分支git rebase origin/master     # 在本地分支上合并远程分支git merge branchName        # 将 branchName 分支合并到当前分支</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code class="shell">git branch -d &lt;name&gt;    # 删除一个分支git branch -D &lt;name&gt;    # 强行删除一个分支git push origin :remotebranch    # 删除一个远程指定分支</code></pre><h3 id="连接绑定"><a href="#连接绑定" class="headerlink" title="连接绑定"></a>连接绑定</h3><pre><code class="shell">git branch --set-upstream-to=origin/dev dev    # 将本地 dev 分支与远程 dev 分支之间建立链接</code></pre><h2 id="5-版本管理"><a href="#5-版本管理" class="headerlink" title="5. 版本管理"></a>5. 版本管理</h2><h3 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h3><pre><code class="shell">git log            # 可查看当前版本的所有提交记录（不显示回退后未来的提交记录）git reflog        # 可查看版本库建立以来所有的提交记录git status        # 获取当前的状态，非常有用，因为git会提示接下来的能做的操作</code></pre><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><pre><code class="shell">git diff file             # 查看指定文件的差异git diff --stat         # 查看简单的diff结果git diff                 # 比较Worktree和Index之间的差异git diff --cached         # 比较Index和HEAD之间的差异git diff HEAD             # 比较Worktree和HEAD之间的差异git diff branch         # 比较Worktree和branch之间的差异git diff branch1 branch2 # 比较两次分支之间的差异git diff commit commit      # 比较两次提交之间的差异</code></pre><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>commit_id 可以从以前的提交记录或者用 <code>git log</code> 和 <code>git relog</code> 命令得到，还可以用 <code>HEAD^</code> 以及 <code>HEAD^^</code> 表示上一个版本或上两个版本，用 <code>HEAD~100</code> 表示第上100个版本。</p><pre><code class="shell">git reset --hard commit_id </code></pre><h1 id="三、常用操作"><a href="#三、常用操作" class="headerlink" title="三、常用操作"></a>三、常用操作</h1><p>##1. 强制用远程覆盖本地</p><pre><code class="shell">git fetch --all                    # 只是下载代码到本地，不进行合并操作git reset --hard origin/master      # 把HEAD指向最新下载的版本</code></pre><h2 id="2-远程分支与本地分支"><a href="#2-远程分支与本地分支" class="headerlink" title="2. 远程分支与本地分支"></a>2. 远程分支与本地分支</h2><h3 id="远程有-master-和-dev"><a href="#远程有-master-和-dev" class="headerlink" title="远程有 master 和 dev"></a>远程有 master 和 dev</h3><p>要在本地创建 dev 并和远程 dev 关联起来</p><pre><code class="shell">git checkout -b localbranch                 # 新建并切换到本地分支git pull origin remotebranch:localbranch      # 本地分支与远程分支相关联</code></pre><h3 id="远程只有-master"><a href="#远程只有-master" class="headerlink" title="远程只有 master"></a>远程只有 master</h3><p>要在本地创建 test 并推送到远程</p><pre><code class="shell">git checkout -b localbranch                   # 新建并切换到本地分支git push origin localbranch:remotebranch        # 这样远程仓库中也就创建了一个分支</code></pre><h3 id="查看远程分支和本地分支之间的追踪关系"><a href="#查看远程分支和本地分支之间的追踪关系" class="headerlink" title="查看远程分支和本地分支之间的追踪关系"></a>查看远程分支和本地分支之间的追踪关系</h3><pre><code class="shell">git branch -vv</code></pre><h2 id="3-文件忽略"><a href="#3-文件忽略" class="headerlink" title="3. 文件忽略"></a>3. 文件忽略</h2><pre><code class="shell">touch .gitignore                      # 新建 .gitignore 文件echo node_modules/ &gt;&gt; .gitignore     # 添加文件到忽略列表</code></pre><p>编写忽略规则，格式如下：</p><pre><code class="shell"># Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa# 加上感叹号表示不能忽略!README.md</code></pre><h2 id="4-tag-管理"><a href="#4-tag-管理" class="headerlink" title="4. tag 管理"></a>4. tag 管理</h2><h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><ul><li><code>git tag &lt;name&gt;</code> 新增一个标签，默认打到最新的commit上</li><li><code>git tag v0.9 6224937</code> 将标签打到指定的commit上</li><li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code> -a后加标签名，-m后加标签信息</li></ul><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><ul><li><code>git tag</code> 查看所有标签</li><li><code>git show &lt;tagname&gt;</code> 查看改标签的详细信息</li><li><code>git checkout tagname</code>  切换到标签</li></ul><h3 id="推动标签"><a href="#推动标签" class="headerlink" title="推动标签"></a>推动标签</h3><ul><li><code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</li><li><code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</li></ul><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><ul><li><code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签。</li></ul><h3 id="获取远程标签"><a href="#获取远程标签" class="headerlink" title="获取远程标签"></a>获取远程标签</h3><ul><li><code>git pull --all</code>  获取远程所有内容包括tag</li></ul><h2 id="5-分支管理策略"><a href="#5-分支管理策略" class="headerlink" title="5. 分支管理策略"></a>5. 分支管理策略</h2><p>实际开发时，我们应该遵循一定的开发策略，以便于进行管理和开发。</p><blockquote><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；<br>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以 了。</p></blockquote><p>所以，团队合作的分支看起来就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/2662764-a3f4de914acf6e2b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git分支管理策略"></p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><pre><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></pre><h3 id="bug-分支"><a href="#bug-分支" class="headerlink" title="bug 分支"></a>bug 分支</h3><p>一般修复bug会另外开一个专门的bug分支来进行修复，但是如果现在正在分支上进行工作，接到紧急任务需要修复一个bug就会出现一个冲突：工作区是被占用的。<br>此时可以用<code>git stash</code>命令来储存当前工作现场</p><ul><li><code>git stash</code>储存当前工作区</li><li><code>git stash list</code>列出当前已经储存了的工作区</li><li><code>git stash apply &lt;stash@{0}&gt;</code>恢复储存的工作区，此种恢复，不会删除存储的工作区，可以在后面加工作区名，表示要恢复到哪个工作区</li><li><code>git stash drop</code>用来删除指定工作区</li><li><code>git stash pop</code>用来恢复到一个工作区，并删除工作区记录</li></ul><h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><p>用来开发新的功能</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以试图用<code>git push origin &lt;本地分支名&gt;</code>推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;本地分支名&gt;</code>推送就能成功！</p><p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建</p><p>用命令<code>git branch --set-upstream branch-name origin/branch-name</code>创建本地和远程的分支链接</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h2 id="6-撤销修改"><a href="#6-撤销修改" class="headerlink" title="6. 撤销修改"></a>6. 撤销修改</h2><p>git中版本管理分成三个区域：工作区、暂存区和分支<br><img src="http://upload-images.jianshu.io/upload_images/2662764-fb39294c2190f423.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git版本管理"></p><p>在这里引用一段关于解释这个三个区域关系的话：</p><blockquote><p>1).从工作目录，提交到stage。<br>2).从stage提交到master。</p><p>从工作目录提交到stage，需要用add或者rm命令，只提交到stage，而没有提交到master，是不会自动同步到master的。</p><p>从stage提交到master用commit命令。</p><p>退回也是要分两步，一个是从master退回到stage，然后再从stage退回到工作目录。</p><p>对于还没有提交到stage的，可以从stage用checkout命令退回，这一步会取stage中的文件状态，覆盖掉工作目录中文件的状态，跟master完全没关系。</p><p>对于已经到达stage的，想把state中的文件状态用master中的覆盖掉，就用reset命令，这样就把stage中修改用master的状态覆盖掉了，完全跟工作目录没关系</p></blockquote><p>针对这三个区域的撤销修改如下：</p><ul><li>工作区：<code>git checkout -- &lt;filename&gt;</code> 此命令可以将工作区的文件修改成上一次<code>add</code>或<code>commit</code>的状态</li><li>暂存区：<code>git reset HEAD &lt;filename&gt;</code> 通过此命令暂存区的版本回退至想要的版本，然后再用上面工作区的撤销修改命令将工作区文件进行撤销修改</li><li>分支： 参考上面版本回退命令，直接将版本回退至指定版本，然后工作区的文件也会随之改变</li></ul><h2 id="7-自定义git"><a href="#7-自定义git" class="headerlink" title="7. 自定义git"></a>7. 自定义git</h2><pre><code class="shell">git config --global alias.st statusgit config --global alias.br branchgit config --global alias.co checkoutgit config --global alias.ci commit</code></pre><p>配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需：</p><pre><code class="shell">git st</code></pre><h2 id="8-把-fork-分支更新"><a href="#8-把-fork-分支更新" class="headerlink" title="8. 把 fork 分支更新"></a>8. 把 fork 分支更新</h2><p>有时候，我们把一个项目 fork 到了自己的库中，但是源项目更新比较频繁，这时候我们就像要把源更新拉取过来，合并到自己的里面，怎么操作呢？</p><h3 id="不用命令行"><a href="#不用命令行" class="headerlink" title="不用命令行"></a>不用命令行</h3><p>参考知乎上 <a href="https://www.zhihu.com/question/20393785/answer/30725725" target="_blank" rel="noopener"><strong>pezy</strong> 的回答</a></p><h3 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h3><p>当然，那是完全不用命令行的办法，其实我还是更推荐命令行，流程如下：</p><ol><li><p>首先要先确定一下是否建立了主repo的远程源：</p><pre><code>git remote -v</code></pre></li><li><p>如果里面只能看到你自己的两个源(fetch 和 push)，那就需要添加主repo的源：</p><pre><code>git remote add upstream URLgit remote -v</code></pre><p>然后你就能看到upstream了。</p></li><li><p>如果想与主repo合并：</p><p>​</p><pre><code>git fetch upstreamgit merge upstream/master</code></pre></li></ol><h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><h2 id="1-Git忽略规则及-gitignore规则不生效的解决办法"><a href="#1-Git忽略规则及-gitignore规则不生效的解决办法" class="headerlink" title="1. Git忽略规则及.gitignore规则不生效的解决办法"></a>1. Git忽略规则及.gitignore规则不生效的解决办法</h2><p>有时候添加顾略规则会发现并不生效，原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</p><pre><code class="shell">git rm -r --cached .git add .git commit -m &#39;update .gitignore&#39;git rm --cached *    # 取消一个文件的跟踪</code></pre><p>解决方法来自：<a href="http://www.pfeng.org/archives/840" target="_blank" rel="noopener">http://www.pfeng.org/archives/840</a></p><h2 id="2-密码不小心提交到了远程分支"><a href="#2-密码不小心提交到了远程分支" class="headerlink" title="2. 密码不小心提交到了远程分支"></a>2. 密码不小心提交到了远程分支</h2><p>当密码提交到远程分支以后，如果后来把文件加入忽略列表，但是以前的commit中还会留有密码文件。这个时候就得用到核弹级命令<code>git filter-branch</code>，之所以叫核弹级，是因为这个命令十分危险，理论上是可以对你的分支做任何操作。建议先拉一个分支再进行操作。<br>使用方法：</p><ol><li>首先关闭远程分支的分支保护；</li><li>然后执行</li></ol><pre><code class="shell"># 这里是删除 分支中所有的 passwords.txt 文件git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD --all# --env-filte 表示修改邮箱环境# --msg-filter 表示修改提交信息# --tree-filter 表示修改文件列表</code></pre><ol><li>接着</li></ol><pre><code class="shell">git push origin master --force</code></pre><ol><li>最后别忘了把远程分支又改回保护状态。</li></ol><h2 id="3-修改commit的信息"><a href="#3-修改commit的信息" class="headerlink" title="3. 修改commit的信息"></a>3. 修改commit的信息</h2><ul><li><code>git commit --amend</code> 如果没有进行新的提交</li><li><code>git reset --soft xxx</code> 如果进行了新的提交，xxx是提交ID，但是会把后面的提交都合并为一次，因此最好不要这么使用</li><li><code>git rebase -i HEAD~3</code>  修改最近三次的提交说明，或者其中任意一次</li><li><code>git rebase --continue</code> 修改提交说明，退出编辑器</li></ul>]]></content>
      
      <categories>
          
          <category> 快查 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 快查 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序开发日记(一)</title>
      <link href="/2017/06/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-%E4%B8%80/"/>
      <url>/2017/06/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h1 id="微信小程序开发日记（一）"><a href="#微信小程序开发日记（一）" class="headerlink" title="微信小程序开发日记（一）"></a>微信小程序开发日记（一）</h1><p>对于小程序的注册和创建无需废话，官方文档上都有，所以这一篇我主要整理的有：</p><ul><li>小程序的目录结构和各个文件在程序中的地位和作用</li><li>小程序开发过程中所特有和常用的部分（单位<code>rpx</code>，以后发现会继续添加）</li></ul><h2 id="一、目录结构"><a href="#一、目录结构" class="headerlink" title="一、目录结构"></a>一、目录结构</h2><p>先不管那三个文件夹，每个新创建的小程序都会有<code>app.js</code>，<code>app.json</code>，<code>app.wxss</code>三个文件，下面简单介绍一下这三个文件的作用：</p><h3 id="文件作用"><a href="#文件作用" class="headerlink" title="文件作用"></a>文件作用</h3><p>首先是小程序中最常用到的三个文件：</p><ul><li><code>app.js</code>是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的<strong>生命周期函数</strong>、声明<strong>全局变量和方法</strong>，调用框架提供的丰富的 <strong>API</strong>。</li><li><code>app.json</code>对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题，调试开关<strong>注意该文件不可添加任何注释，新页面的添加填写在此。</strong></li><li><code>app.wxss</code>是整个小程序的公共样式表,可以把一些公用样式写在这里。</li></ul><h3 id="目录作用"><a href="#目录作用" class="headerlink" title="目录作用"></a>目录作用</h3><p>新创建的小程序中有<code>pages</code>和<code>utils</code>两个文件夹：</p><ul><li><code>pages</code>第一个页面为小程序首页，每创建一个页面或一个公用组件，在此创建该页面或组件的目录。如存在一个index页面时，会有一个index目录，其下有<code>index.js</code>，<code>index.json</code>，<code>index.wxss</code>，<code>index.wxml</code>四个文件。</li><li><code>utils</code>存放一些小工具吧 比如一些逻辑的处理。可以跟自己的喜好来命名 比如 controller</li></ul><h2 id="二、小程序特有和常用部分"><a href="#二、小程序特有和常用部分" class="headerlink" title="二、小程序特有和常用部分"></a>二、小程序特有和常用部分</h2><h3 id="onload-options"><a href="#onload-options" class="headerlink" title="onload(options)"></a>onload(options)</h3><p><code>option</code>是页面进入时url中所带的参数值。如url?index=0，那么可以用option.index取到为0的值。</p><h3 id="尺寸单位rpx"><a href="#尺寸单位rpx" class="headerlink" title="尺寸单位rpx"></a>尺寸单位rpx</h3><p><code>rpx</code>（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p><p><strong>建议</strong>： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件分成冒泡事件和不冒泡事件，冒泡事件会一直向上冒泡，不冒泡事件则不会。<br>下例中点击事件<code>bindtap</code>的用法以key、value的形式。</p><pre><code class="xml">&lt;view id=&quot;tapTest&quot; data-hi=&quot;MINA&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;  </code></pre><pre><code class="javascript">Page({  tapName: function(event) {    console.log(event)  }})</code></pre><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>在wxml中并没有<code>&lt;a&gt;</code>标签，所以小程序中的跳转是以另外两种方法来实现的：</p><ol><li>逻辑层：使用小程序提供的api <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html#wxnavigatetoobject" target="_blank" rel="noopener"><code>wx.navigateTo</code></a> 来进行跳转<br> <strong>示例代码</strong><pre><code class="js"> wx.navigateTo({     url: &#39;test?id=1&#39; })</code></pre></li><li>视图层：使用<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html" target="_blank" rel="noopener"><code>navigator</code></a>标签</li></ol><h3 id="页面跳转传参"><a href="#页面跳转传参" class="headerlink" title="页面跳转传参"></a>页面跳转传参</h3><p>页面跳转时可以用GET方式将参数添加到链接后面，例如</p><pre><code class="html">/pages/bind/bind?sid=2015551509&amp;password=123456</code></pre><p>这样传过去的参数可以在新页面的<code>onLaunch</code>和<code>onShow</code>函数的参数<code>options</code>中取得。</p><pre><code class="js">onLoad: function (options) {  sid = options.sid  password = options.password},</code></pre><h3 id="条件渲染-amp-循环渲染"><a href="#条件渲染-amp-循环渲染" class="headerlink" title="条件渲染&amp;循环渲染"></a>条件渲染&amp;循环渲染</h3><p>微信小程序中有一个很有意思的条件渲染，用这个可以根据条件来判断显示部分内容</p><pre><code class="html">&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt;</code></pre><p>还可以使用<code>&lt;block&gt;</code>标签来判断是否显示某一块内容</p><pre><code class="html">&lt;block wx:if=&quot;{{true}}&quot;&gt;  &lt;view&gt; view1 &lt;/view&gt;  &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt;</code></pre><p>类似的还有循环渲染</p><pre><code class="html">&lt;view wx:for=&quot;{{[0, 1, 2, 3, 4]}}&quot;&gt; {{item}} &lt;/view&gt;</code></pre><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>微信小程序中可以使用模板来简化开发过程</p><pre><code class="html">&lt;template name=&quot;odd&quot;&gt;  &lt;view&gt; odd &lt;/view&gt;&lt;/template&gt;&lt;template name=&quot;even&quot;&gt;  &lt;view&gt; even &lt;/view&gt;&lt;/template&gt;&lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot; data=&quot;{{...item}}&quot;&gt;    &lt;template is=&quot;{{item % 2 == 0 ? 'even' : 'odd'}}&quot;/&gt;    &lt;view&gt;{{index}}&lt;/view&gt;&lt;/block&gt;</code></pre><pre><code class="js">Page({  data: {    item: {      index: 0,      msg: &#39;this is a template&#39;,      time: &#39;2016-09-15&#39;    }  }})</code></pre><p>用<code>&lt;template&gt;</code>来定义和使用标签，其中<code>name</code>用来定义，<code>is</code>用来使用，此外还可以用运算来决定使用哪个模板。值得注意的是，模板里面的变量是一个独立的作用域，也就是说样例中<code></code>是无法取到<code>0</code>这个值的。</p><h2 id="三、小程序的常见坑和开发捷径"><a href="#三、小程序的常见坑和开发捷径" class="headerlink" title="三、小程序的常见坑和开发捷径"></a>三、小程序的常见坑和开发捷径</h2><h3 id="1-常见的坑"><a href="#1-常见的坑" class="headerlink" title="1. 常见的坑"></a>1. 常见的坑</h3><h4 id="空格和换行怎么输入？"><a href="#空格和换行怎么输入？" class="headerlink" title="空格和换行怎么输入？"></a>空格和换行怎么输入？</h4><h5 id="空格："><a href="#空格：" class="headerlink" title="空格："></a>空格：</h5><ul><li><code>&lt;text&gt;</code>中使用空格。</li><li>中文全角空格</li><li>下面这个<pre><code>{{" "}}</code></pre></li></ul><h5 id="换行："><a href="#换行：" class="headerlink" title="换行："></a>换行：</h5><ul><li><code>&lt;text&gt;</code>中使用<code>\n</code>。</li></ul><h3 id="2-开发捷径"><a href="#2-开发捷径" class="headerlink" title="2. 开发捷径"></a>2. 开发捷径</h3><h4 id="Flex模型"><a href="#Flex模型" class="headerlink" title="Flex模型"></a>Flex模型</h4><p>微信小程序中支持用<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">flex</a>模型来书写样式，用flex模型写，许多盒子模型写起来很麻烦都布局都能轻松完成，可以大大加快小程序的开发。</p>]]></content>
      
      <categories>
          
          <category> 微信 </category>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<blockquote><p>2018/4/2</p></blockquote><p>任何所学之于全部，不过沧海一粟。</p><blockquote><p>2018/4/16</p></blockquote><p>如何快速的整理知识？把一本书整理成一张纸。</p><p>如何确定你已经掌握？把那张纸还原为一本书。</p>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
